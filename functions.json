[
  {
    "task": "Sum of Two Numbers",
    "input": "Integers a and b",
    "output": "a + b",
    "function_name": "sum_two_numbers",
    "code_1": "def sum_two_numbers(a, b):\n    return a + b",
    "code_2": "def sum_two_numbers(a, b):\n    return sum((a, b))"
  },
  {
    "task": "Factorial",
    "input": "Integer x",
    "output": "Product of all integers from 1 to x",
    "function_name": "factorial",
    "code_1": "def factorial(x):\n    \"\"\"Return the factorial of a non-negative integer x.\"\"\"\n    if x < 0:\n        raise ValueError(\"x must be non-negative\")\n    result = 1\n    for i in range(1, x + 1):\n        result *= i\n    return result",
    "code_2": "import math\n\ndef factorial(x):\n    '''Return the factorial of a non-negative integer x.'''\n    if x < 0:\n        raise ValueError('x must be non-negative')\n    return math.prod(range(1, x + 1))"
  },
  {
    "task": "Fibonacci Number",
    "input": "Integer n",
    "output": "n-th number in Fibonacci sequence",
    "function_name": "fibonacci",
    "code_1": "def fibonacci(n):\n    \"\"\"Return the n-th Fibonacci number (0-indexed: fibonacci(0)=0, fibonacci(1)=1).\"\"\"\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"Input must be a non-negative integer\")\n    a, b = 0, 1\n    for _ in range(n):\n        a, b = b, a + b\n    return a",
    "code_2": "def fibonacci(n):\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"Input must be a non-negative integer\")\n    def fib_pair(k):\n        if k == 0:\n            return (0, 1)\n        a, b = fib_pair(k // 2)\n        c = a * (2 * b - a)\n        d = a * a + b * b\n        if k % 2:\n            return (d, c + d)\n        return (c, d)\n    return fib_pair(n)[0]\n"
  },
  {
    "task": "Prime Check",
    "input": "Integer x",
    "output": "Boolean indicating if x is prime",
    "function_name": "is_prime",
    "code_1": "def is_prime(x):\n    \"\"\"Return True if x is a prime number, else False.\"\"\"\n    if x < 2:\n        return False\n    i = 2\n    while i * i <= x:\n        if x % i == 0:\n            return False\n        i += 1\n    return True",
    "code_2": "def is_prime(x):\n    \"\"\"Return True if x is a prime number else False.\"\"\"\n    if x < 2:\n        return False\n    # Check divisibility using Python's all() and range up to sqrt(x)\n    return all(x % i for i in range(2, int(x**0.5) + 1))"
  },
  {
    "task": "Reverse String",
    "input": "String s",
    "output": "String s reversed",
    "function_name": "reverse_string",
    "code_1": "def reverse_string(s):\n    \"\"\"Return the reversed version of the input string s.\"\"\"\n    return s[::-1]",
    "code_2": "def reverse_string(s):\n    \"\"\"Return the reversed version of the input string s.\"\"\"\n    # Use the built-in reversed iterator and join\n    return ''.join(reversed(s))"
  },
  {
    "task": "Count Vowels",
    "input": "String s",
    "output": "Number of vowels in s",
    "function_name": "count_vowels",
    "code_1": "def count_vowels(s):\n    \"\"\"\n    Counts the number of vowels in the input string s.\n    Vowels considered: a, e, i, o, u (both lowercase and uppercase).\n    Returns the total count of vowels.\n    \"\"\"\n    count = 0\n    for char in s.lower():\n        if char in 'aeiou':\n            count += 1\n    return count",
    "code_2": "def count_vowels(s):\n    from collections import Counter\n    counts = Counter(s.lower())\n    return sum(counts[v] for v in 'aeiou')"
  },
  {
    "task": "Palindrome Check",
    "input": "String s",
    "output": "Boolean indicating if s is a palindrome",
    "function_name": "is_palindrome",
    "code_1": "def is_palindrome(s):\n    \"\"\"Return True if string s is a palindrome, False otherwise.\"\"\"\n    return s == s[::-1]",
    "code_2": "def is_palindrome(s):\n    left, right = 0, len(s) - 1\n    while left < right:\n        if s[left] != s[right]:\n            return False\n        left += 1\n        right -= 1\n    return True"
  },
  {
    "task": "GCD",
    "input": "Integers a and b",
    "output": "Greatest common divisor of a and b",
    "function_name": "gcd",
    "code_1": "def gcd(a, b):\n    \"\"\"Return the greatest common divisor of a and b.\"\"\"\n    a, b = abs(a), abs(b)\n    while b:\n        a, b = b, a % b\n    return a",
    "code_2": "def gcd(a, b):\n    \"\"\"Return the greatest common divisor of a and b using Stein's algorithm.\"\"\"\n    a, b = abs(a), abs(b)\n    if a == 0:\n        return b\n    if b == 0:\n        return a\n    # remove common factors of 2\n    shift = 0\n    while ((a | b) & 1) == 0:\n        a >>= 1\n        b >>= 1\n        shift += 1\n    # make a odd\n    while (a & 1) == 0:\n        a >>= 1\n    while b:\n        # remove all factors of 2 in b\n        while (b & 1) == 0:\n            b >>= 1\n        # now both a and b are odd\n        if a > b:\n            a, b = b, a\n        b -= a\n    return a << shift"
  },
  {
    "task": "Sum of Digits",
    "input": "Integer x",
    "output": "Sum of digits in x",
    "function_name": "sum_of_digits",
    "code_1": "def sum_of_digits(x):\n    \"\"\"Return the sum of the digits of integer x.\"\"\"\n    return sum(int(d) for d in str(abs(x)))",
    "code_2": "def sum_of_digits(x):\n    \"\"\"Return the sum of digits of integer x using arithmetic operations.\"\"\"\n    total = 0\n    n = abs(x)\n    while n:\n        n, digit = divmod(n, 10)\n        total += digit\n    return total\n"
  },
  {
    "task": "Remove Duplicates",
    "input": "List of integers",
    "output": "List with duplicates removed",
    "function_name": "remove_duplicates",
    "code_1": "def remove_duplicates(nums):\n    \"\"\"Remove duplicates from a list of integers, preserving order.\"\"\"\n    seen = set()\n    result = []\n    for num in nums:\n        if num not in seen:\n            seen.add(num)\n            result.append(num)\n    return result",
    "code_2": "def remove_duplicates(nums):\n    \"\"\"Remove duplicates from a list of integers, preserving order.\"\"\"\n    return list(dict.fromkeys(nums))"
  },
  {
    "task": "Maximum in List",
    "input": "List of integers",
    "output": "Maximum value in list",
    "function_name": "max_in_list",
    "code_1": "def max_in_list(lst):\n    if not lst:\n        raise ValueError('List is empty')\n    max_val = lst[0]\n    for num in lst[1:]:\n        if num > max_val:\n            max_val = num\n    return max_val",
    "code_2": "from functools import reduce\n\ndef max_in_list(lst):\n    if not lst:\n        raise ValueError('List is empty')\n    return reduce(lambda a, b: a if a > b else b, lst)"
  },
  {
    "task": "Even or Odd",
    "input": "Integer x",
    "output": "\u201cEven\u201d or \u201cOdd\u201d",
    "function_name": "even_or_odd",
    "code_1": "def even_or_odd(x):\n    if x % 2 == 0:\n        return \"Even\"\n    else:\n        return \"Odd\"",
    "code_2": "def even_or_odd(x):\n    return ('Even', 'Odd')[x & 1]"
  },
  {
    "task": "LCM",
    "input": "Integers a and b",
    "output": "Least common multiple of a and b",
    "function_name": "lcm",
    "code_1": "def lcm(a, b):\n    # Return the least common multiple of a and b\n    # If either is zero, the LCM is defined as 0\n    if a == 0 or b == 0:\n        return 0\n    def gcd(x, y):\n        x, y = abs(x), abs(y)\n        while y:\n            x, y = y, x % y\n        return x\n    return abs(a * b) // gcd(a, b)",
    "code_2": "import math\n\ndef lcm(a, b):\n    # Return the least common multiple of a and b\n    # If either input is zero, the LCM is defined as 0\n    if not a or not b:\n        return 0\n    # Compute LCM via built-in gcd for efficiency\n    return abs(a // math.gcd(a, b) * b)\n"
  },
  {
    "task": "Convert Celsius to Fahrenheit",
    "input": "Float c",
    "output": "Fahrenheit equivalent of c",
    "function_name": "celsius_to_fahrenheit",
    "code_1": "def celsius_to_fahrenheit(c):\n    return c * 9/5 + 32",
    "code_2": "def celsius_to_fahrenheit(c):\n    # apply scale and offset using functional style\n    pairs = [(c, 9/5), (32, 1)]\n    return sum(map(lambda p: p[0] * p[1], pairs))"
  },
  {
    "task": "Count Words",
    "input": "String s",
    "output": "Number of words in s",
    "function_name": "count_words",
    "code_1": "def count_words(s):\n    \"\"\"Return the number of words in the input string s.\"\"\"\n    # Split the string on whitespace and count the resulting parts\n    return len(s.split())",
    "code_2": "def count_words(s):\n    \"\"\"Return the number of words in the input string s using a manual parse.\"\"\"\n    count = 0\n    in_word = False\n    for ch in s:\n        if not ch.isspace():\n            if not in_word:\n                count += 1\n                in_word = True\n        else:\n            in_word = False\n    return count"
  },
  {
    "task": "Power Function",
    "input": "Integers base and exponent",
    "output": "base raised to the exponent",
    "function_name": "power",
    "code_1": "def power(base, exponent):\n    \"\"\"Return base raised to the power of exponent.\"\"\"\n    return base ** exponent",
    "code_2": "def power(base, exponent):\n    # Fast exponentiation by squaring, handles negative exponents\n    result = 1\n    exp = exponent\n    if exp < 0:\n        base = 1 / base\n        exp = -exp\n    while exp > 0:\n        if exp & 1:\n            result *= base\n        base *= base\n        exp >>= 1\n    return result"
  },
  {
    "task": "Check Anagram",
    "input": "Strings a and b",
    "output": "Boolean indicating if a and b are anagrams",
    "function_name": "is_anagram",
    "code_1": "def is_anagram(a, b):\n    from collections import Counter\n    return Counter(a) == Counter(b)",
    "code_2": "def is_anagram(a, b):\n    # Quick length check\n    if len(a) != len(b):\n        return False\n    # Compare sorted character lists\n    return sorted(a) == sorted(b)"
  },
  {
    "task": "Find Second Largest",
    "input": "List of integers",
    "output": "Second largest number",
    "function_name": "find_second_largest",
    "code_1": "def find_second_largest(nums):\n    \"\"\"Return the second largest distinct number in the list.\"\"\"\n    unique_nums = set(nums)\n    if len(unique_nums) < 2:\n        raise ValueError(\"At least two unique numbers required\")\n    sorted_nums = sorted(unique_nums)\n    return sorted_nums[-2]",
    "code_2": "import heapq\n\ndef find_second_largest(nums):\n    '''Return the second largest distinct number in the list.'''\n    unique = set(nums)\n    top_two = heapq.nlargest(2, unique)\n    if len(top_two) < 2:\n        raise ValueError(\"At least two unique numbers required\")\n    return top_two[1]"
  },
  {
    "task": "Count Frequency",
    "input": "List of elements",
    "output": "Dictionary with frequency of each element",
    "function_name": "count_frequency",
    "code_1": "def count_frequency(lst):\n    freq = {}\n    for item in lst:\n        freq[item] = freq.get(item, 0) + 1\n    return freq",
    "code_2": "def count_frequency(lst):\n    from collections import Counter\n    return dict(Counter(lst))"
  },
  {
    "task": "Sum of List",
    "input": "List of integers",
    "output": "Total sum of the list",
    "function_name": "sum_list",
    "code_1": "def sum_list(numbers):\n    \"\"\"Return the total sum of a list of integers.\"\"\"\n    return sum(numbers)",
    "code_2": "import functools\n\ndef sum_list(numbers):\n    \"\"\"Return the total sum of a list of integers using reduce.\"\"\"\n    return functools.reduce(lambda a, b: a + b, numbers, 0)"
  },
  {
    "task": "String to Uppercase",
    "input": "String s",
    "output": "s in uppercase",
    "function_name": "to_uppercase",
    "code_1": "def to_uppercase(s):\n    return s.upper()",
    "code_2": "def to_uppercase(s):\n    table = str.maketrans('abcdefghijklmnopqrstuvwxyz', 'ABCDEFGHIJKLMNOPQRSTUVWXYZ')\n    return s.translate(table)"
  },
  {
    "task": "Remove Punctuation",
    "input": "String s",
    "output": "String without punctuation",
    "function_name": "remove_punctuation",
    "code_1": "def remove_punctuation(s):\n    import string\n    return ''.join(ch for ch in s if ch not in string.punctuation)",
    "code_2": "def remove_punctuation(s):\n    punctuation = \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\"\n    table = str.maketrans(\"\", \"\", punctuation)\n    return s.translate(table)"
  },
  {
    "task": "Character Frequency",
    "input": "String s",
    "output": "Dictionary of character frequencies",
    "function_name": "char_frequency",
    "code_1": "def char_frequency(s):\n    \"\"\"Return a dictionary mapping each character in s to its frequency.\"\"\"\n    freq = {}\n    for char in s:\n        freq[char] = freq.get(char, 0) + 1\n    return freq",
    "code_2": "def char_frequency(s):\n    from collections import Counter\n    return dict(Counter(s))"
  },
  {
    "task": "Sort List",
    "input": "List of integers",
    "output": "Sorted list",
    "function_name": "sort_list",
    "code_1": "def sort_list(lst):\n    \"\"\"Return a new list containing the sorted integers from the input list.\"\"\"\n    return sorted(lst)",
    "code_2": "def sort_list(lst):\n    # Merge sort implementation\n    if len(lst) < 2:\n        return lst[:]\n    mid = len(lst) // 2\n    left = sort_list(lst[:mid])\n    right = sort_list(lst[mid:])\n    merged = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            merged.append(left[i])\n            i += 1\n        else:\n            merged.append(right[j])\n            j += 1\n    merged.extend(left[i:])\n    merged.extend(right[j:])\n    return merged"
  },
  {
    "task": "Find Common Elements",
    "input": "Two lists",
    "output": "List of common elements",
    "function_name": "find_common_elements",
    "code_1": "def find_common_elements(list1, list2):\n    '''Return a list of common elements between two lists.'''\n    return list(set(list1) & set(list2))",
    "code_2": "def find_common_elements(list1, list2):\n    '''Return a list of common elements between two lists.'''\n    result = []\n    for item in list1:\n        if item in list2 and item not in result:\n            result.append(item)\n    return result"
  },
  {
    "task": "Filter Even Numbers",
    "input": "List of integers",
    "output": "List of integers containing only the even numbers from the input",
    "function_name": "filter_even_numbers",
    "code_1": "def filter_even_numbers(numbers):\n    \"\"\"Return a list containing only the even numbers from the input list.\"\"\"\n    return [num for num in numbers if num % 2 == 0]",
    "code_2": "def filter_even_numbers(numbers):\n    \"\"\"Return a list containing only the even numbers from the input list.\"\"\"\n    return list(filter(lambda n: n % 2 == 0, numbers))"
  },
  {
    "task": "Multiplication Table",
    "input": "Integer n",
    "output": "List of lists containing multiplication table for n from 1 to 10",
    "function_name": "multiplication_table",
    "code_1": "def multiplication_table(n):\n    \"\"\"Return the multiplication table for n from 1 to 10 as a list of [i, n*i].\"\"\"\n    return [[i, i * n] for i in range(1, 11)]",
    "code_2": "def multiplication_table(n):\n    \"\"\"Return the multiplication table for n from 1 to 10 using map and lambda.\"\"\"\n    return list(map(lambda i: [i, i * n], range(1, 11)))"
  },
  {
    "task": "Convert Decimal to Binary",
    "input": "Integer",
    "output": "String representing the binary form of the input integer",
    "function_name": "decimal_to_binary",
    "code_1": "def decimal_to_binary(n):\n    if n == 0:\n        return '0'\n    sign = '' if n >= 0 else '-'\n    n = abs(n)\n    bits = []\n    while n > 0:\n        bits.append(str(n % 2))\n        n //= 2\n    return sign + ''.join(reversed(bits))",
    "code_2": "def decimal_to_binary(n):\n    # handle negative values\n    if n < 0:\n        return '-' + decimal_to_binary(-n)\n    # base case: 0 or 1\n    if n < 2:\n        return str(n)\n    # recursive build: divide by two and append remainder\n    return decimal_to_binary(n >> 1) + str(n & 1)"
  },
  {
    "task": "Convert Binary to Decimal",
    "input": "String of '0' and '1' characters",
    "output": "Integer representing the decimal value of the binary input",
    "function_name": "binary_to_decimal",
    "code_1": "def binary_to_decimal(binary_str):\n    \"\"\"Convert a binary string to its decimal integer value.\"\"\"\n    # Validate input\n    if not all(c in '01' for c in binary_str):\n        raise ValueError(\"Input string must contain only '0' and '1' characters.\")\n    # Use built-in conversion\n    return int(binary_str, 2)",
    "code_2": "from functools import reduce\n\ndef binary_to_decimal(binary_str):\n    \"\"\"Convert a binary string to its decimal integer value using a reducer.\"\"\"\n    # Validate input\n    if not set(binary_str) <= {'0', '1'}:\n        raise ValueError(\"Input string must contain only '0' and '1' characters.\")\n    # Accumulate decimal value\n    return reduce(lambda acc, bit: acc * 2 + int(bit), binary_str, 0)\n"
  },
  {
    "task": "Find Median",
    "input": "List of numbers",
    "output": "Float or integer representing the median value of the list",
    "function_name": "find_median",
    "code_1": "def find_median(nums):\n    \"\"\"Return the median of a list of numbers.\"\"\"\n    if not nums:\n        raise ValueError(\"Cannot compute median of an empty list\")\n    nums = sorted(nums)\n    n = len(nums)\n    mid = n // 2\n    if n % 2 == 1:\n        return nums[mid]\n    else:\n        return (nums[mid - 1] + nums[mid]) / 2",
    "code_2": "def find_median(nums):\n    import heapq\n    # Compute median without fully sorting\n    if not nums:\n        raise ValueError(\"Cannot compute median of an empty list\")\n    n = len(nums)\n    mid = n // 2\n    # Get the smallest mid+1 elements\n    smallest = heapq.nsmallest(mid + 1, nums)\n    if n % 2:\n        # Odd count: median is the last of these\n        return smallest[-1]\n    else:\n        # Even count: average the two middle values\n        return (smallest[-1] + smallest[-2]) / 2\n"
  },
  {
    "task": "Transpose Matrix",
    "input": "Two-dimensional list (matrix)",
    "output": "Two-dimensional list representing the transposed matrix",
    "function_name": "transpose_matrix",
    "code_1": "def transpose_matrix(matrix):\n    \"\"\"\n    Transpose a two-dimensional list (matrix).\n    Args:\n        matrix (list of lists): The input matrix to transpose.\n    Returns:\n        list of lists: The transposed matrix.\n    \"\"\"\n    if not matrix:\n        return []\n    # Use zip to aggregate elements column-wise and convert tuples back to lists\n    return [list(row) for row in zip(*matrix)]",
    "code_2": "def transpose_matrix(matrix):\n    \"\"\"\n    Transpose a two-dimensional list (matrix) without using zip.\n    Args:\n        matrix (list of lists): The input matrix to transpose.\n    Returns:\n        list of lists: The transposed matrix.\n    \"\"\"\n    if not matrix:\n        return []\n    rows = len(matrix)\n    cols = len(matrix[0])\n    transposed = []\n    for c in range(cols):\n        new_row = []\n        for r in range(rows):\n            new_row.append(matrix[r][c])\n        transposed.append(new_row)\n    return transposed"
  },
  {
    "task": "Flatten Nested List",
    "input": "List of lists (of any depth 1)",
    "output": "Single list containing all elements from the nested lists",
    "function_name": "flatten_list",
    "code_1": "def flatten_list(nested_list):\n    \"\"\"Flatten a nested list of any depth into a single list.\"\"\"\n    result = []\n    for element in nested_list:\n        if isinstance(element, list):\n            result.extend(flatten_list(element))\n        else:\n            result.append(element)\n    return result",
    "code_2": "def flatten_list(nested):\n    \"\"\"Flatten a nested list of any depth into a single list using an explicit stack.\"\"\"\n    stack = nested[::-1]\n    flat = []\n    while stack:\n        item = stack.pop()\n        if isinstance(item, list):\n            # push sublist items onto stack in reverse to maintain order\n            stack.extend(item[::-1])\n        else:\n            flat.append(item)\n    return flat"
  },
  {
    "task": "Count Lowercase Letters",
    "input": "String",
    "output": "Integer count of all lowercase alphabetic characters in the string",
    "function_name": "count_lowercase_letters",
    "code_1": "def count_lowercase_letters(s):\n    count = 0\n    for char in s:\n        if 'a' <= char <= 'z':\n            count += 1\n    return count",
    "code_2": "def count_lowercase_letters(s):\n    import re\n    return len(re.findall(r'[a-z]', s))"
  },
  {
    "task": "Caesar Cipher",
    "input": "String (plaintext) and integer shift",
    "output": "String containing the shifted (encrypted) text",
    "function_name": "caesar_cipher",
    "code_1": "def caesar_cipher(text, shift):\n    \"\"\"\n    Encrypts the input text using a Caesar cipher with the given shift.\n    Non-alphabetic characters are not modified.\n    \"\"\"\n    result = []\n    for char in text:\n        if char.isalpha():\n            base = ord('A') if char.isupper() else ord('a')\n            # shift character and wrap around the alphabet\n            offset = (ord(char) - base + shift) % 26\n            result.append(chr(base + offset))\n        else:\n            # leave non-alphabet characters unchanged\n            result.append(char)\n    return ''.join(result)",
    "code_2": "import string\n\ndef caesar_cipher(text, shift):\n    # Normalize shift to range [0, 25]\n    shift %= 26\n    # Prepare translation tables for lowercase and uppercase\n    lower = string.ascii_lowercase\n    upper = string.ascii_uppercase\n    trans_table = str.maketrans(\n        lower + upper,\n        lower[shift:] + lower[:shift] + upper[shift:] + upper[:shift]\n    )\n    # Apply translation to the entire text\n    return text.translate(trans_table)"
  },
  {
    "task": "Armstrong Number Check",
    "input": "A positive integer",
    "output": "True if the number is an Armstrong number, else False",
    "function_name": "is_armstrong_number",
    "code_1": "def is_armstrong_number(n):\n    \"\"\"\n    Check if a positive integer n is an Armstrong number.\n    An Armstrong number is equal to the sum of its own digits each raised\n    to the power of the number of digits.\n    \"\"\"\n    digits = str(n)\n    power = len(digits)\n    total = sum(int(d) ** power for d in digits)\n    return total == n",
    "code_2": "def is_armstrong_number(n):\n    import math\n    # Determine the number of digits using logarithm\n    power = int(math.log10(n)) + 1 if n > 0 else 1\n    total = 0\n    temp = n\n    # Sum each digit raised to the determined power\n    while temp > 0:\n        temp, digit = divmod(temp, 10)\n        total += digit ** power\n    return total == n"
  },
  {
    "task": "Primes in Range",
    "input": "Two integers start and end",
    "output": "A list of all prime numbers between start and end (inclusive)",
    "function_name": "primes_in_range",
    "code_1": "def primes_in_range(start, end):\n    \"\"\"\n    Return a list of prime numbers between start and end (inclusive).\n    \"\"\"\n    primes = []\n    # Ensure we start at least from 2\n    for n in range(max(2, start), end + 1):\n        is_prime = True\n        # Check divisibility up to sqrt(n)\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(n)\n    return primes",
    "code_2": "def primes_in_range(start, end):\n    # Use a sieve to find all primes up to end, then filter for start\n    if end < 2:\n        return []\n    m = end + 1\n    sieve = [True] * m\n    sieve[0:2] = [False, False]\n    limit = int(end**0.5) + 1\n    for p in range(2, limit):\n        if sieve[p]:\n            sieve[p*p:m:p] = [False] * (((m - 1 - p*p)//p) + 1)\n    return [i for i in range(max(start, 2), m) if sieve[i]]"
  },
  {
    "task": "Find Mode",
    "input": "List of numbers",
    "output": "Number that appears most frequently in the list",
    "function_name": "find_mode",
    "code_1": "def find_mode(numbers):\n    from collections import Counter\n    if not numbers:\n        return None\n    counter = Counter(numbers)\n    mode, _ = counter.most_common(1)[0]\n    return mode",
    "code_2": "def find_mode(numbers):\n    if not numbers:\n        return None\n    freq = {}\n    for n in numbers:\n        freq[n] = freq.get(n, 0) + 1\n    return max(freq, key=freq.get)"
  },
  {
    "task": "List Rotation",
    "input": "A list and an integer k",
    "output": "The list rotated to the right by k positions",
    "function_name": "rotate_list",
    "code_1": "def rotate_list(lst, k):\n    \"\"\"Rotate the list lst to the right by k positions.\"\"\"\n    if not lst:\n        return lst\n    k %= len(lst)\n    return lst[-k:] + lst[:-k]",
    "code_2": "from collections import deque\n\ndef rotate_list(lst, k):\n    \"\"\"Rotate the list lst to the right by k positions using deque.\"\"\"\n    d = deque(lst)\n    d.rotate(k)\n    return list(d)"
  },
  {
    "task": "Missing Number Finder",
    "input": "A list of unique integers from 1 to n with one missing",
    "output": "The missing integer in the sequence",
    "function_name": "find_missing_number",
    "code_1": "def find_missing_number(nums):\n    # nums is a list of unique integers from 1 to n with one missing\n    n = len(nums) + 1\n    # The sum of numbers from 1 to n\n    total = n * (n + 1) // 2\n    # The missing number is the difference between the expected sum and the actual sum\n    return total - sum(nums)",
    "code_2": "def find_missing_number(nums):\n    n = len(nums) + 1\n    xor_all = 0\n    for i in range(1, n + 1):\n        xor_all ^= i\n    xor_nums = 0\n    for num in nums:\n        xor_nums ^= num\n    return xor_all ^ xor_nums"
  },
  {
    "task": "Stop Words Removal",
    "input": "A string sentence and a list of stop words",
    "output": "The sentence string with all occurrences of the stop words removed",
    "function_name": "remove_stop_words",
    "code_1": "def remove_stop_words(sentence, stop_words):\n    '''Remove stop words from a sentence.'''\n    stop_set = set(word.lower() for word in stop_words)\n    words = sentence.split()\n    filtered = [word for word in words if word.lower() not in stop_set]\n    return ' '.join(filtered)",
    "code_2": "def remove_stop_words(sentence, stop_words):\n    import re\n    # If no stop words provided, return original sentence\n    if not stop_words:\n        return sentence\n    # Build a regex pattern to match any stop word as a whole word, case-insensitive\n    escaped = (re.escape(w) for w in stop_words)\n    pattern = r\"\\b(?:\" + \"|\".join(escaped) + r\")\\b\"\n    # Remove matched stop words\n    cleaned = re.sub(pattern, '', sentence, flags=re.IGNORECASE)\n    # Normalize whitespace left by removals\n    return ' '.join(cleaned.split())"
  },
  {
    "task": "Merge Sorted Lists",
    "input": "Two sorted lists of integers",
    "output": "A single sorted list containing all elements from both input lists",
    "function_name": "merge_sorted_lists",
    "code_1": "def merge_sorted_lists(list1, list2):\n    \"\"\"\n    Merge two sorted lists of integers into a single sorted list.\n    :param list1: First sorted list of integers.\n    :param list2: Second sorted list of integers.\n    :return: A new sorted list containing all elements from both inputs.\n    \"\"\"\n    merged = []\n    i, j = 0, 0\n    # Traverse both lists and append the smaller element\n    while i < len(list1) and j < len(list2):\n        if list1[i] < list2[j]:\n            merged.append(list1[i])\n            i += 1\n        else:\n            merged.append(list2[j])\n            j += 1\n    # Append any remaining elements from list1 or list2\n    if i < len(list1):\n        merged.extend(list1[i:])\n    if j < len(list2):\n        merged.extend(list2[j:])\n    return merged",
    "code_2": "import heapq\n\ndef merge_sorted_lists(list1, list2):\n    \"\"\"\n    Merge two sorted lists of integers into a single sorted list using heapq.merge.\n    :param list1: First sorted list of integers.\n    :param list2: Second sorted list of integers.\n    :return: A new sorted list containing all elements from both inputs.\n    \"\"\"\n    return list(heapq.merge(list1, list2))"
  },
  {
    "task": "Unique Random Numbers",
    "input": "Two integers n and range_end",
    "output": "A list of n unique random integers between 1 and range_end inclusive",
    "function_name": "unique_random_numbers",
    "code_1": "def unique_random_numbers(n, range_end):\n    \"\"\"Return a list of n unique random integers between 1 and range_end inclusive.\"\"\"\n    from random import sample\n    if n > range_end:\n        raise ValueError(\"n cannot exceed range_end\")\n    return sample(range(1, range_end + 1), n)",
    "code_2": "def unique_random_numbers(n, range_end):\n    \"\"\"Return a list of n unique random integers between 1 and range_end inclusive using reservoir sampling.\"\"\"\n    import random\n    if n > range_end:\n        raise ValueError(\"n cannot exceed range_end\")\n    # Initialize reservoir with the first n numbers\n    reservoir = list(range(1, n + 1))\n    # Replace elements with decreasing probability\n    for i in range(n + 1, range_end + 1):\n        j = random.randrange(0, i)\n        if j < n:\n            reservoir[j] = i\n    return reservoir"
  },
  {
    "task": "Pair Sum Finder",
    "input": "A list of integers and a target integer sum",
    "output": "A tuple of two integers from the list that add up to the target, or None if no such pair exists",
    "function_name": "find_pair_sum",
    "code_1": "def find_pair_sum(nums, target):\n    seen = set()\n    for num in nums:\n        complement = target - num\n        if complement in seen:\n            return (complement, num)\n        seen.add(num)\n    return None",
    "code_2": "def find_pair_sum(nums, target):\n    nums_sorted = sorted(nums)\n    left, right = 0, len(nums_sorted) - 1\n    while left < right:\n        current_sum = nums_sorted[left] + nums_sorted[right]\n        if current_sum == target:\n            return (nums_sorted[left], nums_sorted[right])\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return None"
  },
  {
    "task": "Compound Interest Calculator",
    "input": "Principal (float), annual rate as a percentage (float), times compounded per year (int), years (int)",
    "output": "The accumulated amount as a float",
    "function_name": "calculate_compound_interest",
    "code_1": "def calculate_compound_interest(principal, rate, times_per_year, years):\n    # principal: initial amount (float)\n    # rate: annual interest rate in percentage (float)\n    # times_per_year: number of times interest is compounded per year (int)\n    # years: total number of years (int)\n    amount = principal * (1 + rate/(100 * times_per_year)) ** (times_per_year * years)\n    return amount",
    "code_2": "def calculate_compound_interest(principal, rate, times_per_year, years):\n    \"\"\"Calculate the accumulated amount by applying interest iteratively each period.\"\"\"\n    balance = principal\n    # Convert the annual percentage rate to a per-period multiplier\n    periodic_multiplier = 1 + (rate / 100.0) / times_per_year\n    # Apply the multiplier for each compounding period\n    for _ in range(times_per_year * years):\n        balance *= periodic_multiplier\n    return balance"
  },
  {
    "task": "Parentheses Balance Check",
    "input": "A string containing the characters () [] {}",
    "output": "True if all types of parentheses are balanced and properly nested, else False",
    "function_name": "are_parentheses_balanced",
    "code_1": "def are_parentheses_balanced(s):\n    stack = []\n    pairs = {')': '(', ']': '[', '}': '{'}\n    for char in s:\n        if char in '([{':\n            stack.append(char)\n        elif char in ')]}':\n            if not stack or stack[-1] != pairs[char]:\n                return False\n            stack.pop()\n    return not stack",
    "code_2": "def are_parentheses_balanced(s):\n    # iteratively remove matching pairs until no more can be removed\n    prev = None\n    while prev != s:\n        prev = s\n        s = s.replace('()', '').replace('[]', '').replace('{}', '')\n    return s == ''"
  },
  {
    "task": "List Average",
    "input": "A list of numbers (ints or floats)",
    "output": "A float representing the average of the list",
    "function_name": "list_average",
    "code_1": "def list_average(numbers):\n    \"\"\"Return the average of a list of numbers. Returns 0.0 for an empty list.\"\"\"\n    if not numbers:\n        return 0.0\n    return float(sum(numbers)) / len(numbers)",
    "code_2": "def list_average(numbers):\n    total = 0.0\n    count = 0\n    for num in numbers:\n        total += num\n        count += 1\n    if count == 0:\n        return 0.0\n    return total / count\n"
  },
  {
    "task": "Hypotenuse Calculator",
    "input": "Two positive numbers (int or float) representing the lengths of the triangle\u2019s legs",
    "output": "A float representing the length of the hypotenuse",
    "function_name": "calculate_hypotenuse",
    "code_1": "def calculate_hypotenuse(a, b):\n    \"\"\"\n    Calculate the length of the hypotenuse of a right triangle given legs a and b.\n    :param a: length of the first leg (int or float)\n    :param b: length of the second leg (int or float)\n    :return: length of the hypotenuse (float)\n    \"\"\"\n    return (a * a + b * b) ** 0.5",
    "code_2": "def calculate_hypotenuse(a, b):\n    \"\"\"\n    Calculate the length of the hypotenuse using complex number magnitude.\n    :param a: length of the first leg (int or float)\n    :param b: length of the second leg (int or float)\n    :return: length of the hypotenuse (float)\n    \"\"\"\n    return abs(complex(a, b))"
  },
  {
    "task": "Pangram Check",
    "input": "A string of text",
    "output": "A boolean indicating whether the string contains every letter of the English alphabet at least once",
    "function_name": "is_pangram",
    "code_1": "def is_pangram(text):\n    \"\"\"\n    Check if the input text contains every letter of the English alphabet at least once.\n    :param text: Input string to check\n    :return: True if pangram, False otherwise\n    \"\"\"\n    # Create a set of all lowercase alphabet letters\n    alphabet = set('abcdefghijklmnopqrstuvwxyz')\n    # Filter the text to include only alphabetic characters, convert to lowercase, and form a set\n    letters_in_text = set(ch.lower() for ch in text if ch.isalpha())\n    # Check if all alphabet letters are present in the text\n    return alphabet.issubset(letters_in_text)",
    "code_2": "def is_pangram(text):\n    \"\"\"\n    Check if the input text contains every letter of the English alphabet at least once using bitmasking.\n    :param text: Input string to check\n    :return: True if pangram, False otherwise\n    \"\"\"\n    bitmask = 0\n    full_mask = (1 << 26) - 1\n    for ch in text:\n        # Map letters to bit positions 0-25\n        if 'A' <= ch <= 'Z' or 'a' <= ch <= 'z':\n            idx = ord(ch.lower()) - ord('a')\n            bitmask |= 1 << idx\n            # early exit if all bits set\n            if bitmask == full_mask:\n                return True\n    return bitmask == full_mask\n"
  },
  {
    "task": "Leap Year Check",
    "input": "An integer representing a year",
    "output": "A boolean indicating whether the year is a leap year",
    "function_name": "is_leap_year",
    "code_1": "def is_leap_year(year):\n    \"\"\"Return True if year is a leap year, False otherwise.\"\"\"\n    return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)",
    "code_2": "import calendar\n\ndef is_leap_year(year):\n    \"\"\"Return True if year is a leap year, False otherwise.\"\"\"\n    return calendar.isleap(year)"
  },
  {
    "task": "Extract Digits",
    "input": "A string containing alphanumeric characters",
    "output": "A string of all digit characters extracted from the input, in order",
    "function_name": "extract_digits",
    "code_1": "def extract_digits(input_str):\n    \"\"\"Return all digit characters from input_str in order.\"\"\"\n    return ''.join(ch for ch in input_str if ch.isdigit())",
    "code_2": "def extract_digits(input_str):\n    import re\n    # Remove all non-digit characters\n    return re.sub(r'\\D', '', input_str)"
  },
  {
    "task": "Cumulative Sum List",
    "input": "A list of numbers",
    "output": "A list where each element is the cumulative sum up to that index",
    "function_name": "cumulative_sum_list",
    "code_1": "def cumulative_sum_list(nums):\n    result = []\n    total = 0\n    for num in nums:\n        total += num\n        result.append(total)\n    return result",
    "code_2": "from itertools import accumulate\n\ndef cumulative_sum_list(nums):\n    return list(accumulate(nums))"
  },
  {
    "task": "Isogram Check",
    "input": "A string of alphabetical characters",
    "output": "A boolean indicating whether no letter repeats in the string",
    "function_name": "is_isogram",
    "code_1": "def is_isogram(s):\n    \"\"\"Check if the input string is an isogram (no repeating letters).\"\"\"\n    s = s.lower()\n    return len(set(s)) == len(s)",
    "code_2": "def is_isogram(s):\n    \"\"\"Check if the input string is an isogram (no repeating letters).\"\"\"\n    s_lower = s.lower()\n    # Sort the characters and look for any adjacent duplicates\n    sorted_chars = sorted(s_lower)\n    return all(a != b for a, b in zip(sorted_chars, sorted_chars[1:]))"
  },
  {
    "task": "Sort Dictionary by Value",
    "input": "A dictionary with comparable keys and numeric values",
    "output": "A list of tuples (key, value) sorted by value in ascending order",
    "function_name": "sort_dict_by_value",
    "code_1": "def sort_dict_by_value(d):\n    \"\"\"Sorts a dictionary by value in ascending order and returns a list of (key, value) tuples.\"\"\"\n    return sorted(d.items(), key=lambda item: item[1])",
    "code_2": "def sort_dict_by_value(d):\n    \"\"\"Sorts a dictionary by its values in ascending order and returns a list of (key, value) tuples.\"\"\"\n    # Sort the keys based on their corresponding values and rebuild the tuples\n    return [(key, d[key]) for key in sorted(d, key=d.get)]"
  },
  {
    "task": "Perfect Number Check",
    "input": "An integer greater than 1",
    "output": "A boolean indicating whether the number is perfect (sum of its proper divisors equals the number)",
    "function_name": "is_perfect_number",
    "code_1": "def is_perfect_number(n):\n    import math\n    if n <= 1:\n        return False\n    total = 1\n    sqrt_n = int(math.sqrt(n))\n    for i in range(2, sqrt_n + 1):\n        if n % i == 0:\n            total += i\n            other = n // i\n            if other != i:\n                total += other\n    return total == n",
    "code_2": "def is_perfect_number(n):\n    if n <= 1:\n        return False\n    # Sum all proper divisors by checking every number up to n-1\n    return sum(i for i in range(1, n) if n % i == 0) == n"
  },
  {
    "task": "Running Maximum",
    "input": "List of numbers",
    "output": "List of running maximums at each position",
    "function_name": "running_max",
    "code_1": "def running_max(nums):\n    \"\"\"Return list of running maximums for the input list nums.\"\"\"\n    max_so_far = float('-inf')\n    result = []\n    for num in nums:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    return result",
    "code_2": "from itertools import accumulate\n\ndef running_max(nums):\n    \"\"\"Return list of running maximums for the input list nums.\"\"\"\n    return list(accumulate(nums, max))"
  },
  {
    "task": "String Rotation",
    "input": "A string and an integer n",
    "output": "A string rotated to the left by n characters",
    "function_name": "rotate_left",
    "code_1": "def rotate_left(s, n):\n    if not s:\n        return s\n    n = n % len(s)\n    return s[n:] + s[:n]",
    "code_2": "def rotate_left(s, n):\n    from collections import deque\n    if not s:\n        return s\n    d = deque(s)\n    d.rotate(-(n % len(s)))\n    return ''.join(d)"
  },
  {
    "task": "Remove Element",
    "input": "List and a value to remove",
    "output": "New list with all occurrences of the value removed",
    "function_name": "remove_element",
    "code_1": "def remove_element(lst, val):\n    \"\"\"\n    Remove all occurrences of val from lst and return a new list.\n    \"\"\"\n    return [x for x in lst if x != val]",
    "code_2": "def remove_element(lst, val):\n    \"\"\"\n    Remove all occurrences of val from lst and return a new list.\n    \"\"\"\n    return list(filter(lambda x, v=val: x != v, lst))"
  },
  {
    "task": "Longest Word Finder",
    "input": "String (sentence)",
    "output": "The longest word in the sentence",
    "function_name": "longest_word",
    "code_1": "def longest_word(sentence):\n    \"\"\"Return the longest word in the given sentence. If the sentence is empty, returns an empty string.\"\"\"\n    words = sentence.split()\n    if not words:\n        return ''\n    # Find and return the word with maximum length\n    return max(words, key=len)",
    "code_2": "def longest_word(sentence):\n    \"\"\"Return the longest word in the given sentence. If the sentence is empty, returns an empty string.\"\"\"\n    longest = ''\n    current = ''\n    for ch in sentence:\n        if not ch.isspace():\n            current += ch\n        else:\n            if len(current) > len(longest):\n                longest = current\n            current = ''\n    # Check the last word after the loop\n    if len(current) > len(longest):\n        longest = current\n    return longest"
  },
  {
    "task": "Unique Characters",
    "input": "String",
    "output": "String of unique characters in the order they first appear",
    "function_name": "unique_characters",
    "code_1": "def unique_characters(s):\n    \"\"\"Return a string of unique characters in the order they first appear.\"\"\"\n    seen = set()\n    result = []\n    for char in s:\n        if char not in seen:\n            seen.add(char)\n            result.append(char)\n    return ''.join(result)",
    "code_2": "def unique_characters(s):\n    \"\"\"Return a string of unique characters in the order they first appear.\"\"\"\n    # Utilize dict.fromkeys to preserve order of first occurrence\n    return ''.join(dict.fromkeys(s))"
  },
  {
    "task": "Validate IPv4 Address",
    "input": "String",
    "output": "Boolean indicating whether the string is a valid IPv4 address",
    "function_name": "is_valid_ipv4_address",
    "code_1": "def is_valid_ipv4_address(ip):\n    parts = ip.split('.')\n    if len(parts) != 4:\n        return False\n    for part in parts:\n        if not part.isdigit():\n            return False\n        if len(part) > 1 and part[0] == '0':\n            return False\n        num = int(part)\n        if num < 0 or num > 255:\n            return False\n    return True",
    "code_2": "import re\n\n_ipv4_regex = re.compile(\n    r'^(?:25[0-5]|2[0-4]\\d|1\\d{2}|[1-9]?\\d)'\n    r'(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d{2}|[1-9]?\\d)){3}$'\n)\n\ndef is_valid_ipv4_address(ip):\n    return bool(_ipv4_regex.fullmatch(ip))"
  },
  {
    "task": "Generate Power Set",
    "input": "List of elements",
    "output": "List of lists representing all possible subsets",
    "function_name": "generate_power_set",
    "code_1": "def generate_power_set(lst):\n    result = [[]]\n    for elem in lst:\n        result += [curr + [elem] for curr in result]\n    return result",
    "code_2": "import itertools\n\ndef generate_power_set(lst):\n    return [list(subset) for r in range(len(lst) + 1) for subset in itertools.combinations(lst, r)]"
  },
  {
    "task": "Matrix Diagonal Sum",
    "input": "Square matrix (list of lists)",
    "output": "Sum of the primary diagonal elements",
    "function_name": "matrix_diagonal_sum",
    "code_1": "def matrix_diagonal_sum(matrix):\n    total = 0\n    for i in range(len(matrix)):\n        total += matrix[i][i]\n    return total",
    "code_2": "def matrix_diagonal_sum(matrix):\n    # sum primary diagonal using enumerate and a generator expression\n    return sum(row[i] for i, row in enumerate(matrix))"
  },
  {
    "task": "Count Set Bits",
    "input": "Integer",
    "output": "Number of 1 bits in its binary representation",
    "function_name": "count_set_bits",
    "code_1": "def count_set_bits(n):\n    \"\"\"Return the number of 1 bits in the binary representation of n.\"\"\"\n    return bin(n).count('1')",
    "code_2": "def count_set_bits(n):\n    count = 0\n    while n:\n        n &= n - 1  # clear the lowest set bit\n        count += 1\n    return count"
  },
  {
    "task": "Sliding Window Sum",
    "input": "List of numbers and window size (integer)",
    "output": "List of sums for each consecutive window of the given size",
    "function_name": "sliding_window_sum",
    "code_1": "def sliding_window_sum(nums, k):\n    \"\"\"\n    Calculate the sum of each consecutive window of size k in the list nums.\n    Returns a list of sums.\n    \"\"\"\n    # Edge cases\n    if k <= 0 or k > len(nums):\n        return []\n\n    # Compute the sum of the first window\n    window_sum = sum(nums[:k])\n    result = [window_sum]\n\n    # Slide the window: subtract the element exiting and add the new element\n    for i in range(k, len(nums)):\n        window_sum += nums[i] - nums[i - k]\n        result.append(window_sum)\n\n    return result",
    "code_2": "def sliding_window_sum(nums, k):\n    \"\"\"\n    Calculate the sum of each consecutive window of size k using prefix sums.\n    Returns a list of sums.\n    \"\"\"\n    # Handle invalid window sizes\n    if k <= 0 or k > len(nums):\n        return []\n\n    from itertools import accumulate\n    # Build prefix sums, prepending 0 for easier calculations\n    prefix_sums = [0] + list(accumulate(nums))\n\n    # Each window sum is the difference of two prefix sums\n    return [prefix_sums[i + k] - prefix_sums[i] for i in range(len(nums) - k + 1)]"
  },
  {
    "task": "Digital Root",
    "input": "integer n",
    "output": "integer representing the digital root of n",
    "function_name": "digital_root",
    "code_1": "def digital_root(n):\n    \"\"\"\n    Compute the digital root of a non-negative integer n.\n    The digital root is obtained by iteratively summing the digits until a single-digit number is obtained.\n    \"\"\"\n    n = abs(n)\n    while n >= 10:\n        s = 0\n        while n > 0:\n            s += n % 10\n            n //= 10\n        n = s\n    return n",
    "code_2": "def digital_root(n):\n    \"\"\"\n    Compute the digital root of a non-negative integer n using modular arithmetic.\n    \"\"\"\n    n = abs(n)\n    if n == 0:\n        return 0\n    return 9 if n % 9 == 0 else n % 9"
  },
  {
    "task": "Simple CSV Parser",
    "input": "CSV-formatted string",
    "output": "List of rows, each row as a list of values",
    "function_name": "simple_csv_parser",
    "code_1": "def simple_csv_parser(csv_string):\n    \"\"\"\n    Parse a CSV-formatted string into a list of rows, each row as a list of values.\n    Handles quoted fields with escaped quotes.\n    \"\"\"\n    rows = []\n    row = []\n    field = ''\n    in_quotes = False\n    i = 0\n    length = len(csv_string)\n    while i < length:\n        char = csv_string[i]\n        if in_quotes:\n            if char == '\"':\n                # Possible escaped quote\n                if i + 1 < length and csv_string[i + 1] == '\"':\n                    field += '\"'\n                    i += 1\n                else:\n                    in_quotes = False\n            else:\n                field += char\n        else:\n            if char == '\"':\n                in_quotes = True\n            elif char == ',':\n                row.append(field)\n                field = ''\n            elif char == '\\r':\n                # Handle CRLF or lone CR\n                if i + 1 < length and csv_string[i + 1] == '\\n':\n                    i += 1\n                row.append(field)\n                rows.append(row)\n                row = []\n                field = ''\n            elif char == '\\n':\n                row.append(field)\n                rows.append(row)\n                row = []\n                field = ''\n            else:\n                field += char\n        i += 1\n    # Append the last field and row\n    row.append(field)\n    rows.append(row)\n    return rows",
    "code_2": "import csv\nfrom io import StringIO\n\ndef simple_csv_parser(csv_string):\n    f = StringIO(csv_string)\n    return list(csv.reader(f))\n"
  },
  {
    "task": "Equilibrium Index Finder",
    "input": "list of integers",
    "output": "integer index where left and right sums are equal or -1",
    "function_name": "find_equilibrium_index",
    "code_1": "def find_equilibrium_index(arr):\n    total = sum(arr)\n    left_sum = 0\n    for i, num in enumerate(arr):\n        total -= num\n        if left_sum == total:\n            return i\n        left_sum += num\n    return -1",
    "code_2": "def find_equilibrium_index(arr):\n    # look for an index where the sum of elements before it equals the sum after it\n    return next((i for i in range(len(arr)) if sum(arr[:i]) == sum(arr[i+1:])), -1)"
  },
  {
    "task": "Merge Dictionaries",
    "input": "two dictionaries with string keys and integer values",
    "output": "single dictionary with keys merged and values summed",
    "function_name": "merge_dictionaries",
    "code_1": "def merge_dictionaries(dict1, dict2):\n    \"\"\"\n    Merge two dictionaries with string keys and integer values.\n    If a key appears in both, their values are summed.\n    \"\"\"\n    merged = dict1.copy()\n    for key, value in dict2.items():\n        merged[key] = merged.get(key, 0) + value\n    return merged",
    "code_2": "from collections import Counter\n\ndef merge_dictionaries(dict1, dict2):\n    \"\"\"\n    Merge two dictionaries with string keys and integer values.\n    If a key appears in both, their values are summed.\n    \"\"\"\n    # Use Counter to sum values of matching keys\n    return dict(Counter(dict1) + Counter(dict2))"
  },
  {
    "task": "Circle Area Calculator",
    "input": "float radius",
    "output": "float area of the circle",
    "function_name": "calculate_circle_area",
    "code_1": "def calculate_circle_area(radius):\n    import math\n    \"\"\"Return the area of a circle given its radius.\"\"\"\n    return math.pi * radius ** 2",
    "code_2": "def calculate_circle_area(radius):\n    from math import acos, pow\n    '''Compute the area of a circle by deriving \u03c0 via arccos(-1).'''\n    pi = acos(-1)\n    return pi * pow(radius, 2)"
  },
  {
    "task": "Date Difference",
    "input": "two date strings in \"YYYY-MM-DD\" format",
    "output": "integer number of days between the two dates",
    "function_name": "date_diff",
    "code_1": "def date_diff(date1: str, date2: str) -> int:\n    from datetime import datetime\n    d1 = datetime.strptime(date1, \"%Y-%m-%d\").date()\n    d2 = datetime.strptime(date2, \"%Y-%m-%d\").date()\n    return abs((d2 - d1).days)",
    "code_2": "def date_diff(date1: str, date2: str) -> int:\n    # Convert a Gregorian date to Julian Day Number\n    def to_jdn(year: int, month: int, day: int) -> int:\n        a = (14 - month) // 12\n        y = year + 4800 - a\n        m = month + 12 * a - 3\n        return day + (153 * m + 2) // 5 + 365 * y + y // 4 - y // 100 + y // 400 - 32045\n\n    # Parse the input strings\n    y1, m1, d1 = map(int, date1.split('-'))\n    y2, m2, d2 = map(int, date2.split('-'))\n\n    # Compute JDN for both dates and return absolute difference\n    return abs(to_jdn(y1, m1, d1) - to_jdn(y2, m2, d2))"
  },
  {
    "task": "Quadratic Equation Solver",
    "input": "three floats a, b, c",
    "output": "tuple of two roots (real or complex) of ax\u00b2 + bx + c = 0",
    "function_name": "solve_quadratic",
    "code_1": "def solve_quadratic(a, b, c):\n    import cmath\n    # Calculate the discriminant\n    disc = b * b - 4 * a * c\n    # Compute two roots using cmath to handle complex results\n    root_disc = cmath.sqrt(disc)\n    root1 = (-b + root_disc) / (2 * a)\n    root2 = (-b - root_disc) / (2 * a)\n    return (root1, root2)",
    "code_2": "def solve_quadratic(a, b, c):\n    import math\n    # Compute discriminant\n    disc = b*b - 4*a*c\n    # If double root\n    if disc == 0:\n        root = -b / (2*a)\n        return (root, root)\n    # Compute square root of discriminant, handling complex\n    sqrt_disc = math.sqrt(disc) if disc > 0 else math.sqrt(-disc) * 1j\n    # Use a more stable form for calculation\n    if b > 0:\n        q = -0.5 * (b + sqrt_disc)\n    else:\n        q = -0.5 * (b - sqrt_disc)\n    root1 = q / a\n    root2 = c / q\n    return (root1, root2)"
  },
  {
    "task": "Random Password Generator",
    "input": "integer length",
    "output": "string password containing letters, digits, and symbols",
    "function_name": "generate_password",
    "code_1": "import random\nimport string\n\ndef generate_password(length):\n    \"\"\"Generate a random password of given length including letters, digits, and symbols.\"\"\"\n    if not isinstance(length, int) or length < 1:\n        raise ValueError(\"Length must be a positive integer\")\n    characters = string.ascii_letters + string.digits + string.punctuation\n    return ''.join(random.choice(characters) for _ in range(length))",
    "code_2": "import os\nimport string\n\ndef generate_password(length):\n    \"\"\"Generate a random password of given length using os.urandom.\"\"\"\n    if not isinstance(length, int) or length < 1:\n        raise ValueError(\"Length must be a positive integer\")\n    alphabet = string.ascii_letters + string.digits + string.punctuation\n    random_bytes = os.urandom(length)\n    return ''.join(alphabet[b % len(alphabet)] for b in random_bytes)"
  },
  {
    "task": "Title Case Conversion",
    "input": "string sentence",
    "output": "string with each word capitalized",
    "function_name": "title_case",
    "code_1": "def title_case(sentence):\n    return ' '.join(word.capitalize() for word in sentence.split())",
    "code_2": "def title_case(sentence):\n    return \" \".join(map(lambda w: (w[:1].upper() + w[1:].lower()) if w else \"\", sentence.split()))"
  },
  {
    "task": "Weighted Average",
    "input": "list of tuples (value: float, weight: float)",
    "output": "float weighted average",
    "function_name": "weighted_average",
    "code_1": "def weighted_average(data):\n    \"\"\"\n    Calculate the weighted average of a list of (value, weight) tuples.\n    Raises ValueError if the total weight is zero.\n    \"\"\"\n    total_weight = sum(weight for value, weight in data)\n    if total_weight == 0:\n        raise ValueError(\"Sum of weights must not be zero\")\n    return sum(value * weight for value, weight in data) / total_weight",
    "code_2": "def weighted_average(data):\n    \"\"\"\n    Compute weighted average; raises ValueError if sum of weights is zero.\n    \"\"\"\n    total_val = 0.0\n    total_wt = 0.0\n    for val, wt in data:\n        total_val += val * wt\n        total_wt += wt\n    try:\n        return total_val / total_wt\n    except ZeroDivisionError:\n        raise ValueError(\"Sum of weights must not be zero\")"
  },
  {
    "task": "Remove Consecutive Duplicates",
    "input": "list of items",
    "output": "list of items with consecutive duplicates removed",
    "function_name": "remove_consecutive_duplicates",
    "code_1": "def remove_consecutive_duplicates(items):\n    if not items:\n        return []\n    result = [items[0]]\n    for item in items[1:]:\n        if item != result[-1]:\n            result.append(item)\n    return result",
    "code_2": "def remove_consecutive_duplicates(items):\n    from itertools import groupby\n    return [key for key, _ in groupby(items)]"
  },
  {
    "task": "Prime Factorization",
    "input": "integer",
    "output": "list of prime factors in ascending order",
    "function_name": "prime_factors",
    "code_1": "def prime_factors(n):\n    factors = []\n    i = 2\n    while i * i <= n:\n        while n % i == 0:\n            factors.append(i)\n            n //= i\n        i += 1\n    if n > 1:\n        factors.append(n)\n    return factors",
    "code_2": "def prime_factors(n):\n    def helper(x):\n        if x <= 1:\n            return []\n        # find smallest divisor\n        for d in range(2, int(x**0.5) + 1):\n            if x % d == 0:\n                return [d] + helper(x // d)\n        # x is prime\n        return [x]\n    return helper(n)"
  },
  {
    "task": "Group Anagrams",
    "input": "list of strings",
    "output": "list of lists, where each sublist contains anagram strings",
    "function_name": "group_anagrams",
    "code_1": "def group_anagrams(strs):\n    \"\"\"\n    Groups a list of strings into anagrams.\n    :param strs: List[str]\n    :return: List[List[str]] where each sublist contains anagram strings.\n    \"\"\"\n    anagram_map = {}\n    for s in strs:\n        # Use the sorted tuple of characters as the key\n        key = tuple(sorted(s))\n        if key not in anagram_map:\n            anagram_map[key] = []\n        anagram_map[key].append(s)\n    # Return the grouped anagrams as a list of lists\n    return list(anagram_map.values())",
    "code_2": "def group_anagrams(strs):\n    from collections import defaultdict\n    # Use character count signature instead of sorting\n    buckets = defaultdict(list)\n    for word in strs:\n        # Build a 26-length count tuple for each word\n        counts = [0] * 26\n        for ch in word:\n            counts[ord(ch) - ord('a')] += 1\n        buckets[tuple(counts)].append(word)\n    return list(buckets.values())"
  },
  {
    "task": "Max Product Pair",
    "input": "list of integers",
    "output": "tuple of two integers whose product is maximum",
    "function_name": "max_product_pair",
    "code_1": "def max_product_pair(nums):\n    if len(nums) < 2:\n        raise ValueError(\"At least two numbers are required\")\n    max1 = max2 = float('-inf')\n    min1 = min2 = float('inf')\n    for x in nums:\n        if x > max1:\n            max2 = max1\n            max1 = x\n        elif x > max2:\n            max2 = x\n        if x < min1:\n            min2 = min1\n            min1 = x\n        elif x < min2:\n            min2 = x\n    if max1 * max2 >= min1 * min2:\n        return (max1, max2)\n    else:\n        return (min1, min2)",
    "code_2": "def max_product_pair(nums):\n    if len(nums) < 2:\n        raise ValueError('At least two numbers are required')\n    import heapq\n    small = heapq.nsmallest(2, nums)\n    big = heapq.nlargest(2, nums)\n    if small[0] * small[1] > big[0] * big[1]:\n        return tuple(small)\n    else:\n        return tuple(big)"
  },
  {
    "task": "Roman to Integer",
    "input": "string representing a Roman numeral",
    "output": "integer value of the Roman numeral",
    "function_name": "roman_to_int",
    "code_1": "def roman_to_int(s):\n    \"\"\"\n    Convert a Roman numeral string to its integer value.\n    :param s: A string representing the Roman numeral (e.g., \"MCMXCIV\").\n    :return: The integer value of the Roman numeral.\n    \"\"\"\n    # Mapping of single Roman numerals to their integer values\n    roman_map = {\n        'I': 1,\n        'V': 5,\n        'X': 10,\n        'L': 50,\n        'C': 100,\n        'D': 500,\n        'M': 1000\n    }\n    total = 0\n    prev_value = 0\n    # Process symbols from right to left\n    for char in reversed(s):\n        value = roman_map.get(char, 0)\n        if value < prev_value:\n            total -= value\n        else:\n            total += value\n            prev_value = value\n    return total",
    "code_2": "def roman_to_int(s):\n    mapping = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n    total = sum(mapping[ch] for ch in s)\n    # Adjust for subtractive notation\n    for small, large in [('I','V'), ('I','X'), ('X','L'), ('X','C'), ('C','D'), ('C','M')]:\n        total -= 2 * mapping[small] * s.count(small + large)\n    return total"
  },
  {
    "task": "Count Special Characters",
    "input": "string",
    "output": "integer count of non-alphanumeric characters",
    "function_name": "count_special_chars",
    "code_1": "def count_special_chars(s):\n    \"\"\"Return the count of non-alphanumeric characters in the input string s.\"\"\"\n    count = 0\n    for c in s:\n        if not c.isalnum():\n            count += 1\n    return count",
    "code_2": "def count_special_chars(s):\n    import re\n    # Find all characters that are not letters or digits\n    return len(re.findall(r'[^A-Za-z0-9]', s))"
  },
  {
    "task": "Generate Identity Matrix",
    "input": "integer n",
    "output": "n\u00d7n list of lists representing an identity matrix",
    "function_name": "generate_identity_matrix",
    "code_1": "def generate_identity_matrix(n):\n    \"\"\"\n    Generate an n x n identity matrix.\n    :param n: size of the identity matrix\n    :return: a list of lists representing the identity matrix\n    \"\"\"\n    matrix = []\n    for i in range(n):\n        row = []\n        for j in range(n):\n            row.append(1 if i == j else 0)\n        matrix.append(row)\n    return matrix",
    "code_2": "def generate_identity_matrix(n):\n    \"\"\"\n    Generate an n x n identity matrix.\n    :param n: size of the identity matrix\n    :return: a list of lists representing the identity matrix\n    \"\"\"\n    # Initialize all zeros\n    matrix = [[0] * n for _ in range(n)]\n    # Set the diagonal to 1\n    for i, row in enumerate(matrix):\n        row[i] = 1\n    return matrix"
  },
  {
    "task": "Top Three Largest",
    "input": "list of numbers",
    "output": "list of the three largest unique numbers in descending order",
    "function_name": "top_three_largest",
    "code_1": "def top_three_largest(numbers):\n    # Create a set to ensure uniqueness\n    unique_nums = set(numbers)\n    # Sort in descending order\n    sorted_nums = sorted(unique_nums, reverse=True)\n    # Return the top three\n    return sorted_nums[:3]",
    "code_2": "import heapq\n\ndef top_three_largest(numbers):\n    # Use a heap to fetch the top three unique elements efficiently\n    unique_numbers = set(numbers)\n    return heapq.nlargest(3, unique_numbers)"
  },
  {
    "task": "Time Difference in Minutes",
    "input": "two strings in \"HH:MM\" 24-hour format",
    "output": "integer difference between times in minutes",
    "function_name": "time_difference_minutes",
    "code_1": "def time_difference_minutes(time1, time2):\n    \"\"\"\n    Calculate the absolute difference between two 24-hour times in minutes.\n    :param time1: string in \"HH:MM\" format\n    :param time2: string in \"HH:MM\" format\n    :return: integer difference in minutes\n    \"\"\"\n    # Parse hours and minutes\n    h1, m1 = map(int, time1.split(':'))\n    h2, m2 = map(int, time2.split(':'))\n\n    # Convert to total minutes\n    total1 = h1 * 60 + m1\n    total2 = h2 * 60 + m2\n\n    # Return absolute difference\n    return abs(total1 - total2)",
    "code_2": "def time_difference_minutes(time1, time2):\n    from datetime import datetime\n    # parse both times into datetime objects on an arbitrary same date\n    fmt = \"%H:%M\"\n    t1 = datetime.strptime(time1, fmt)\n    t2 = datetime.strptime(time2, fmt)\n    # compute absolute difference in seconds and convert to minutes\n    diff_secs = abs((t2 - t1).total_seconds())\n    return int(diff_secs // 60)"
  },
  {
    "task": "Longest Common Prefix",
    "input": "list of strings",
    "output": "longest common prefix string",
    "function_name": "longest_common_prefix",
    "code_1": "def longest_common_prefix(strs):\n    if not strs:\n        return \"\"\n    prefix = strs[0]\n    for s in strs[1:]:\n        while not s.startswith(prefix):\n            prefix = prefix[:-1]\n            if not prefix:\n                return \"\"\n    return prefix",
    "code_2": "def longest_common_prefix(strs):\n    if not strs:\n        return \"\"\n    prefix_chars = []\n    for chars in zip(*strs):\n        if all(c == chars[0] for c in chars):\n            prefix_chars.append(chars[0])\n        else:\n            break\n    return ''.join(prefix_chars)"
  },
  {
    "task": "Sort Strings by Length",
    "input": "list of strings",
    "output": "list of strings sorted by length in ascending order",
    "function_name": "sort_strings_by_length",
    "code_1": "def sort_strings_by_length(strings):\n    \"\"\"\n    Sort a list of strings by their length in ascending order.\n    :param strings: List of strings to sort\n    :return: New list of strings sorted by length\n    \"\"\"\n    return sorted(strings, key=len)",
    "code_2": "def sort_strings_by_length(strings):\n    \"\"\"\n    Sort a list of strings by their length in ascending order using bucket sort.\n    :param strings: List of strings to sort\n    :return: New list of strings sorted by length\n    \"\"\"\n    if not strings:\n        return []\n    # Group strings by their length\n    buckets = {}\n    for s in strings:\n        buckets.setdefault(len(s), []).append(s)\n    # Build the sorted list by iterating lengths in order\n    result = []\n    for length in range(min(buckets), max(buckets) + 1):\n        result.extend(buckets.get(length, []))\n    return result"
  },
  {
    "task": "Triangular Number",
    "input": "A single integer n",
    "output": "The nth triangular number (sum of integers from 1 to n)",
    "function_name": "triangular_number",
    "code_1": "def triangular_number(n):\n    \"\"\"Return the nth triangular number: the sum of integers from 1 to n.\"\"\"\n    return n * (n + 1) // 2",
    "code_2": "def triangular_number(n):\n    # Return the nth triangular number by summing the sequence\n    return sum(range(1, n+1))"
  },
  {
    "task": "Automorphic Number Check",
    "input": "A single integer",
    "output": "True if the square of the number ends with the number itself, otherwise False",
    "function_name": "is_automorphic",
    "code_1": "def is_automorphic(n):\n    \"\"\"Return True if n is an automorphic number (its square ends with n).\"\"\"\n    mod = 10 ** len(str(n))\n    return (n * n) % mod == n",
    "code_2": "def is_automorphic(n):\n    s = str(n)\n    sq = str(n * n)\n    return sq.endswith(s)"
  },
  {
    "task": "Degrees to Radians Conversion",
    "input": "A single float representing degrees",
    "output": "The equivalent angle in radians as a float",
    "function_name": "degrees_to_radians",
    "code_1": "import math\n\ndef degrees_to_radians(degrees):\n    \"\"\"Convert an angle from degrees to radians.\"\"\"\n    return degrees * math.pi / 180.0",
    "code_2": "import math\n\ndef degrees_to_radians(degrees):\n    \"\"\"Convert an angle from degrees to radians using math.radians.\"\"\"\n    return math.radians(degrees)\n"
  },
  {
    "task": "Perfect Square Check",
    "input": "A single integer",
    "output": "True if the number is a perfect square, otherwise False",
    "function_name": "is_perfect_square",
    "code_1": "def is_perfect_square(n):\n    import math\n    if n < 0:\n        return False\n    r = math.isqrt(n)\n    return r * r == n",
    "code_2": "def is_perfect_square(n):\n    if not isinstance(n, int) or n < 0:\n        return False\n    low, high = 0, n\n    while low <= high:\n        mid = (low + high) // 2\n        sq = mid * mid\n        if sq == n:\n            return True\n        elif sq < n:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return False"
  },
  {
    "task": "Swap Case String",
    "input": "A single string",
    "output": "The string with uppercase letters converted to lowercase and vice versa",
    "function_name": "swap_case_string",
    "code_1": "def swap_case_string(s):\n    \"\"\"Return a new string with uppercase letters converted to lowercase and vice versa.\"\"\"\n    return s.swapcase()",
    "code_2": "def swap_case_string(s):\n    # Manually swap each character's case\n    result_chars = []\n    for ch in s:\n        if ch.isupper():\n            result_chars.append(ch.lower())\n        elif ch.islower():\n            result_chars.append(ch.upper())\n        else:\n            result_chars.append(ch)\n    return ''.join(result_chars)\n"
  },
  {
    "task": "Dot Product of Vectors",
    "input": "Two lists of numbers of equal length",
    "output": "The dot product as a number",
    "function_name": "dot_product",
    "code_1": "def dot_product(a, b):\n    \"\"\"Return the dot product of two equal-length vectors a and b.\"\"\"\n    if len(a) != len(b):\n        raise ValueError(\"Vectors must be of equal length\")\n    return sum(x * y for x, y in zip(a, b))",
    "code_2": "from functools import reduce\nfrom operator import mul, add\n\ndef dot_product(a, b):\n    \"\"\"Return the dot product of two equal-length vectors a and b.\"\"\"\n    if len(a) != len(b):\n        raise ValueError(\"Vectors must be of equal length\")\n    return reduce(add, map(mul, a, b), 0)"
  },
  {
    "task": "Second Smallest in List",
    "input": "A list of integers with at least two distinct values",
    "output": "The second smallest integer in the list",
    "function_name": "second_smallest",
    "code_1": "def second_smallest(lst):\n    unique = set(lst)\n    if len(unique) < 2:\n        raise ValueError(\"List must contain at least two distinct values\")\n    sorted_vals = sorted(unique)\n    return sorted_vals[1]",
    "code_2": "def second_smallest(lst):\n    min1 = min2 = float('inf')\n    for num in lst:\n        if num < min1:\n            if num != min1:\n                min2 = min1\n            min1 = num\n        elif min1 < num < min2:\n            min2 = num\n    if min2 == float('inf'):\n        raise ValueError(\"List must contain at least two distinct values\")\n    return min2"
  },
  {
    "task": "Alternate Merge Strings",
    "input": "Two strings",
    "output": "A new string formed by alternating characters from both inputs; append leftover characters at the end",
    "function_name": "alternate_merge",
    "code_1": "def alternate_merge(s1, s2):\n    result = []\n    min_len = min(len(s1), len(s2))\n    for i in range(min_len):\n        result.append(s1[i])\n        result.append(s2[i])\n    result.append(s1[min_len:])\n    result.append(s2[min_len:])\n    return ''.join(result)",
    "code_2": "def alternate_merge(s1, s2):\n    from itertools import zip_longest\n    # Pair up characters, fill with empty string when one runs out\n    return ''.join(a + b for a, b in zip_longest(s1, s2, fillvalue=''))"
  },
  {
    "task": "Check Sorted List",
    "input": "A list of comparable elements",
    "output": "True if the list is sorted in non-decreasing order, otherwise False",
    "function_name": "is_sorted",
    "code_1": "def is_sorted(lst):\n    \"\"\"Return True if lst is sorted in non-decreasing order, else False.\"\"\"\n    for i in range(len(lst) - 1):\n        if lst[i] > lst[i + 1]:\n            return False\n    return True",
    "code_2": "def is_sorted(lst: list) -> bool:\n    \"\"\"Return True if lst is sorted in non-decreasing order.\"\"\"\n    return all(prev <= curr for prev, curr in zip(lst, lst[1:]))"
  },
  {
    "task": "Reverse List in Chunks",
    "input": "A list and an integer k",
    "output": "A new list where elements are reversed in sublists of size k; leftover elements remain in original order if fewer than k",
    "function_name": "reverse_list_in_chunks",
    "code_1": "def reverse_list_in_chunks(lst, k):\n    result = []\n    for i in range(0, len(lst), k):\n        chunk = lst[i:i+k]\n        if len(chunk) == k:\n            result.extend(chunk[::-1])\n        else:\n            result.extend(chunk)\n    return result",
    "code_2": "def reverse_list_in_chunks(lst, k):\n    # Recursive approach: reverse the first k elements, then recurse\n    if len(lst) < k:\n        return lst[:]\n    head, tail = lst[:k], lst[k:]\n    return head[::-1] + reverse_list_in_chunks(tail, k)\n"
  },
  {
    "task": "Time Format Conversion",
    "input": "string in format \"hh:mm:ssAM\" or \"hh:mm:ssPM\"",
    "output": "string in 24-hour format \"HH:MM:SS\"",
    "function_name": "convert_time_format",
    "code_1": "def convert_time_format(time_str):\n    \"\"\"\n    Convert 12-hour time format (hh:mm:ssAM or hh:mm:ssPM) to 24-hour format HH:MM:SS.\n    \"\"\"\n    period = time_str[-2:]\n    hh, mm, ss = time_str[:-2].split(':')\n    hh, mm, ss = int(hh), int(mm), int(ss)\n\n    if period == 'AM':\n        hh = 0 if hh == 12 else hh\n    else:  # PM\n        hh = hh if hh == 12 else hh + 12\n\n    return f\"{hh:02d}:{mm:02d}:{ss:02d}\"",
    "code_2": "import datetime\n\ndef convert_time_format(time_str):\n    \"\"\"\n    Convert 12-hour time format (hh:mm:ssAM or hh:mm:ssPM) to 24-hour format HH:MM:SS using datetime.\n    \"\"\"\n    return datetime.datetime.strptime(time_str, \"%I:%M:%S%p\").strftime(\"%H:%M:%S\")"
  },
  {
    "task": "Multiply Matrices",
    "input": "two 2D lists of numbers where the first is m\u00d7n and the second is n\u00d7p",
    "output": "2D list representing the m\u00d7p product matrix",
    "function_name": "matrix_multiply",
    "code_1": "def matrix_multiply(A, B):\n    \"\"\"Multiply two matrices A (m x n) and B (n x p) and return the product (m x p).\"\"\"\n    # Get dimensions\n    m = len(A)\n    if m == 0:\n        return []  # Empty A yields empty result\n    n = len(A[0])\n    if len(B) != n:\n        raise ValueError(\"Number of columns in A must equal number of rows in B\")\n    p = len(B[0]) if B and B[0] else 0\n    # Initialize result matrix with zeros\n    result = [[0 for _ in range(p)] for _ in range(m)]\n    # Compute product\n    for i in range(m):\n        for j in range(p):\n            sum_val = 0\n            for k in range(n):\n                sum_val += A[i][k] * B[k][j]\n            result[i][j] = sum_val\n    return result",
    "code_2": "def matrix_multiply(A, B):\n    if not A:\n        return []\n    cols_A = len(A[0])\n    if len(B) != cols_A:\n        raise ValueError('Number of columns in A must equal number of rows in B')\n    # Transpose B to iterate over its columns\n    B_t = list(zip(*B))\n    # Compute product using list comprehensions\n    return [[sum(a * b for a, b in zip(row, col)) for col in B_t] for row in A]"
  },
  {
    "task": "Validate Sudoku Row",
    "input": "list of 9 integers",
    "output": "boolean indicating if the row contains all digits from 1 to 9 exactly once",
    "function_name": "validate_sudoku_row",
    "code_1": "def validate_sudoku_row(row):\n    # Check that row is a list of length 9\n    if not isinstance(row, list) or len(row) != 9:\n        return False\n    seen = set()\n    # Validate each number\n    for num in row:\n        if not isinstance(num, int) or num < 1 or num > 9 or num in seen:\n            return False\n        seen.add(num)\n    # If we've seen exactly 9 distinct numbers from 1 to 9, it's valid\n    return True",
    "code_2": "def validate_sudoku_row(row):\n    # Must be a list of length 9 with integers 1\u20139\n    if not isinstance(row, list) or len(row) != 9:\n        return False\n    # Ensure all elements are ints in the required range\n    if not all(isinstance(x, int) and 1 <= x <= 9 for x in row):\n        return False\n    # Check for uniqueness and correct total sum\n    return len(set(row)) == 9 and sum(row) == 45"
  },
  {
    "task": "Binomial Coefficient",
    "input": "two non-negative integers n and k",
    "output": "integer equal to the binomial coefficient C(n, k)",
    "function_name": "binomial_coefficient",
    "code_1": "def binomial_coefficient(n, k):\n    \"\"\"\n    Compute the binomial coefficient C(n, k) = n! / (k! * (n-k)!)\n    for non-negative integers n and k.\n    Returns 0 if k > n.\n    \"\"\"\n    # Handle edge cases\n    if k < 0 or k > n:\n        return 0\n    # Use symmetry property\n    k = min(k, n - k)\n    result = 1\n    for i in range(1, k + 1):\n        result = result * (n - k + i) // i\n    return result",
    "code_2": "def binomial_coefficient(n, k):\n    \"\"\"\n    Compute the binomial coefficient C(n, k) using a dynamic programming approach.\n    Returns 0 if k > n.\n    \"\"\"\n    if k < 0 or k > n:\n        return 0\n    # exploit symmetry to reduce work\n    k = min(k, n - k)\n    # initialize a list to hold current row values up to k\n    row = [0] * (k + 1)\n    row[0] = 1\n    # build Pascal's triangle one row at a time\n    for i in range(1, n + 1):\n        # update entries in reverse to not overwrite needed values\n        for j in range(min(i, k), 0, -1):\n            row[j] += row[j - 1]\n    return row[k]\n"
  },
  {
    "task": "Right Triangle Check",
    "input": "three positive numbers",
    "output": "boolean indicating if they can form a right-angled triangle",
    "function_name": "is_right_triangle",
    "code_1": "def is_right_triangle(a, b, c):\n    '''Return True if a, b, c can form a right-angled triangle'''\n    sides = sorted([a, b, c])\n    # Check for positive side lengths\n    if sides[0] <= 0:\n        return False\n    # Check Pythagorean theorem with a tolerance for floats\n    return abs(sides[0]**2 + sides[1]**2 - sides[2]**2) < 1e-9",
    "code_2": "import math\n\ndef is_right_triangle(a, b, c):\n    # All sides must be positive\n    sides = (a, b, c)\n    if not all(side > 0 for side in sides):\n        return False\n    # Hypotenuse is the longest side\n    hyp = max(sides)\n    # Compare sum of squares of the other two sides to hypotenuse squared\n    total_sq = sum(x*x for x in sides)\n    return math.isclose(total_sq - hyp*hyp, hyp*hyp, rel_tol=1e-9, abs_tol=1e-9)\n"
  },
  {
    "task": "Pascal's Triangle Row",
    "input": "non-negative integer n",
    "output": "list of integers representing the nth (0-indexed) row of Pascal\u2019s triangle",
    "function_name": "get_pascals_triangle_row",
    "code_1": "def get_pascals_triangle_row(n):\n    row = [1]\n    for i in range(1, n+1):\n        row = [1] + [row[j] + row[j+1] for j in range(len(row)-1)] + [1]\n    return row",
    "code_2": "def get_pascals_triangle_row(n):\n    from math import comb\n    return [comb(n, k) for k in range(n + 1)]"
  },
  {
    "task": "URL Encode_1 Spaces",
    "input": "string",
    "output": "string where all space characters are replaced by \"%20\"",
    "function_name": "url_encode_1_spaces",
    "code_1": "def url_encode_1_spaces(s):\n    return s.replace(\" \", \"%20\")",
    "code_2": "def url_encode_1_spaces(s):\n    return ''.join('%20' if c == ' ' else c for c in s)"
  },
  {
    "task": "Zip Lists to Dictionary",
    "input": "two lists of equal length (keys and values)",
    "output": "dictionary mapping each key to its corresponding value",
    "function_name": "zip_lists_to_dict",
    "code_1": "def zip_lists_to_dict(keys, values):\n    \"\"\"\n    Zip two lists into a dictionary mapping each key to its corresponding value.\n\n    Args:\n        keys (list): List of keys.\n        values (list): List of values.\n\n    Returns:\n        dict: Dictionary mapping each key to its corresponding value.\n\n    Raises:\n        ValueError: If the two lists are not of equal length.\n    \"\"\"\n    if len(keys) != len(values):\n        raise ValueError(\"Both lists must have the same length.\")\n    return dict(zip(keys, values))",
    "code_2": "def zip_lists_to_dict(keys, values):\n    \"\"\"\n    Zip two lists into a dictionary mapping each key to its corresponding value.\n\n    Args:\n        keys (list): List of keys.\n        values (list): List of values.\n\n    Returns:\n        dict: Dictionary mapping each key to its corresponding value.\n\n    Raises:\n        ValueError: If the two lists are not of equal length.\n    \"\"\"\n    if len(keys) != len(values):\n        raise ValueError(\"Both lists must have the same length.\")\n    result = {}\n    for idx, key in enumerate(keys):\n        result[key] = values[idx]\n    return result"
  },
  {
    "task": "Rock-Paper-Scissors Winner",
    "input": "two strings each \"rock\", \"paper\", or \"scissors\"",
    "output": "string \"Player 1\", \"Player 2\", or \"Draw\"",
    "function_name": "determine_winner",
    "code_1": "def determine_winner(player1, player2):\n    if player1 == player2:\n        return \"Draw\"\n    wins = {\"rock\": \"scissors\", \"scissors\": \"paper\", \"paper\": \"rock\"}\n    if wins.get(player1) == player2:\n        return \"Player 1\"\n    else:\n        return \"Player 2\"",
    "code_2": "def determine_winner(player1, player2):\n    # Map choices to positions in a cyclic list\n    choices = ['rock', 'paper', 'scissors']\n    # Find each player's index\n    i1 = choices.index(player1)\n    i2 = choices.index(player2)\n    # Compute relative difference modulo 3\n    diff = (i1 - i2) % 3\n    if diff == 0:\n        return 'Draw'\n    # A difference of 1 means player1 beats player2\n    return 'Player 1' if diff == 1 else 'Player 2'"
  },
  {
    "task": "Snake to Camel Case",
    "input": "A snake_case string",
    "output": "The string converted to camelCase",
    "function_name": "snake_to_camel",
    "code_1": "def snake_to_camel(s):\n    parts = s.split('_')\n    if not parts:\n        return ''\n    first = parts[0].lower()\n    rest = ''.join(word.capitalize() for word in parts[1:])\n    return first + rest",
    "code_2": "import re\n\ndef snake_to_camel(s):\n    # Lowercase input then convert underscores + letter to uppercase letter\n    return re.sub(r'_(.)', lambda m: m.group(1).upper(), s.lower())"
  },
  {
    "task": "Camel to Snake Case",
    "input": "A camelCase string",
    "output": "The string converted to snake_case",
    "function_name": "camel_to_snake",
    "code_1": "def camel_to_snake(s):\n    import re\n    # Insert underscore before each uppercase letter (except at start), then lowercase the string\n    return re.sub(r'(?<!^)(?=[A-Z])', '_', s).lower()",
    "code_2": "def camel_to_snake(s):\n    result = []\n    for ch in s:\n        if ch.isupper():\n            if result:\n                result.append('_')\n            result.append(ch.lower())\n        else:\n            result.append(ch)\n    return ''.join(result)"
  },
  {
    "task": "Evaluate Postfix Expression",
    "input": "string of space-separated tokens (integers and the operators +, -, *, /)",
    "output": "integer result of evaluating the postfix expression",
    "function_name": "evaluate_postfix",
    "code_1": "def evaluate_postfix(expr):\n    tokens = expr.split()\n    stack = []\n    for token in tokens:\n        if token in '+-*/':\n            b = stack.pop()\n            a = stack.pop()\n            if token == '+':\n                stack.append(a + b)\n            elif token == '-':\n                stack.append(a - b)\n            elif token == '*':\n                stack.append(a * b)\n            elif token == '/':\n                # integer division truncating toward zero\n                stack.append(int(a / b))\n        else:\n            stack.append(int(token))\n    return stack[0]",
    "code_2": "def evaluate_postfix(expr):\n    from functools import reduce\n    import operator\n\n    ops = {\n        '+': operator.add,\n        '-': operator.sub,\n        '*': operator.mul,\n        '/': lambda a, b: int(a / b)  # truncate toward zero\n    }\n\n    def step(stack, token):\n        if token in ops:\n            a, b = stack[-2], stack[-1]\n            return stack[:-2] + [ops[token](a, b)]\n        else:\n            return stack + [int(token)]\n\n    # reduce over tokens, building a new stack at each step\n    result_stack = reduce(step, expr.split(), [])\n    return result_stack[0]"
  },
  {
    "task": "Run-Length Encoding",
    "input": "A string",
    "output": "A run-length encode_1d string where consecutive characters are represented as character followed by count",
    "function_name": "run_length_encode_1",
    "code_1": "def run_length_encode_1(s):\n    if not s:\n        return \"\"\n    result = []\n    prev = s[0]\n    count = 1\n    for c in s[1:]:\n        if c == prev:\n            count += 1\n        else:\n            result.append(prev + str(count))\n            prev = c\n            count = 1\n    result.append(prev + str(count))\n    return ''.join(result)",
    "code_2": "def run_length_encode_1(s):\n    from itertools import groupby\n    # Group consecutive identical characters and count their lengths\n    return ''.join(f\"{char}{sum(1 for _ in group)}\" for char, group in groupby(s))"
  },
  {
    "task": "Jaccard Similarity",
    "input": "Two lists of hashable items",
    "output": "A float representing the Jaccard similarity coefficient",
    "function_name": "jaccard_similarity",
    "code_1": "def jaccard_similarity(list1, list2):\n    \"\"\"\n    Calculate the Jaccard similarity coefficient between two lists of hashable items.\n\n    Parameters:\n    list1 (iterable): First list of hashable items.\n    list2 (iterable): Second list of hashable items.\n\n    Returns:\n    float: Jaccard similarity coefficient (between 0 and 1). Returns 1.0 if both inputs are empty.\n    \"\"\"\n    # Convert lists to sets to remove duplicates and allow set operations\n    set1 = set(list1)\n    set2 = set(list2)\n\n    # Compute intersection and union\n    intersection = set1.intersection(set2)\n    union = set1.union(set2)\n\n    # If both sets are empty, define similarity as 1.0\n    if not union:\n        return 1.0\n\n    # Compute and return Jaccard similarity\n    return len(intersection) / len(union)",
    "code_2": "def jaccard_similarity(list1, list2):\n    '''\n    Calculate the Jaccard similarity coefficient between two lists of hashable items.\n    Uses a sorting-based merge approach to compute intersection and union sizes.\n    '''\n    # Remove duplicates and sort\n    a = sorted(set(list1))\n    b = sorted(set(list2))\n    i = j = inter = union = 0\n    # Traverse both sorted lists\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            inter += 1\n            union += 1\n            i += 1\n            j += 1\n        elif a[i] < b[j]:\n            union += 1\n            i += 1\n        else:\n            union += 1\n            j += 1\n    # Add remaining unique elements\n    union += (len(a) - i) + (len(b) - j)\n    # Handle case of two empty inputs\n    if union == 0:\n        return 1.0\n    return inter / union"
  },
  {
    "task": "Symmetric Difference",
    "input": "Two lists",
    "output": "A list of elements present in one list or the other but not both",
    "function_name": "symmetric_difference",
    "code_1": "def symmetric_difference(list1, list2):\n    \"\"\"Return a list of elements present in one list or the other but not both.\"\"\"\n    set1 = set(list1)\n    set2 = set(list2)\n    return list(set1.symmetric_difference(set2))",
    "code_2": "def symmetric_difference(list1, list2):\n    \"\"\"Return a list of elements present in one list or the other but not both.\"\"\"\n    # consider each unique element from both lists\n    unique_all = set(list1 + list2)\n    # select those that appear in exactly one list using XOR\n    return [item for item in unique_all if (item in list1) ^ (item in list2)]\n"
  },
  {
    "task": "Rolling Average",
    "input": "A list of numbers and an integer window size",
    "output": "A list of floating-point moving averages for each window",
    "function_name": "rolling_average",
    "code_1": "def rolling_average(nums, window):\n    if window <= 0:\n        raise ValueError(\"Window size must be positive\")\n    n = len(nums)\n    if window > n:\n        return []\n    result = []\n    window_sum = sum(nums[:window])\n    result.append(window_sum / window)\n    for i in range(window, n):\n        window_sum += nums[i] - nums[i-window]\n        result.append(window_sum / window)\n    return result",
    "code_2": "import itertools\n\ndef rolling_average(nums, window):\n    if window <= 0:\n        raise ValueError('Window size must be positive')\n    n = len(nums)\n    if window > n:\n        return []\n    # build prefix sums then compute each window average\n    prefix = [0] + list(itertools.accumulate(nums))\n    return [(prefix[i+window] - prefix[i]) / window for i in range(n - window + 1)]"
  },
  {
    "task": "Is Matrix Symmetric",
    "input": "A square 2D list of numbers",
    "output": "A boolean indicating if the matrix equals its transpose",
    "function_name": "is_matrix_symmetric",
    "code_1": "def is_matrix_symmetric(matrix):\n    n = len(matrix)\n    # Ensure it's square\n    for row in matrix:\n        if len(row) != n:\n            return False\n    # Compare elements with their transpose positions\n    for i in range(n):\n        for j in range(i+1, n):\n            if matrix[i][j] != matrix[j][i]:\n                return False\n    return True",
    "code_2": "def is_matrix_symmetric(matrix):\n    # Quick square check\n    if any(len(row) != len(matrix) for row in matrix):\n        return False\n    # Build transpose and compare\n    transpose = [list(col) for col in zip(*matrix)]\n    return matrix == transpose\n"
  },
  {
    "task": "Maximum Subarray Sum",
    "input": "A list of integers",
    "output": "An integer representing the largest sum of any contiguous subarray",
    "function_name": "max_subarray_sum",
    "code_1": "def max_subarray_sum(nums):\n    if not nums:\n        return 0\n    max_current = max_global = nums[0]\n    for num in nums[1:]:\n        max_current = max(num, max_current + num)\n        max_global = max(max_global, max_current)\n    return max_global",
    "code_2": "def max_subarray_sum(nums):\n    if not nums:\n        return 0\n    min_prefix = 0\n    max_sum = nums[0]\n    current_prefix = 0\n    for num in nums:\n        current_prefix += num\n        # potential max ending here is total so far minus smallest prefix before\n        candidate = current_prefix - min_prefix\n        if candidate > max_sum:\n            max_sum = candidate\n        # update smallest prefix seen\n        if current_prefix < min_prefix:\n            min_prefix = current_prefix\n    return max_sum"
  },
  {
    "task": "Palindrome Binary Check",
    "input": "An integer",
    "output": "A boolean indicating if its binary representation reads the same forwards and backwards",
    "function_name": "is_binary_palindrome",
    "code_1": "def is_binary_palindrome(n):\n    if not isinstance(n, int):\n        raise ValueError(\"Input must be an integer\")\n    if n < 0:\n        return False\n    b = bin(n)[2:]\n    return b == b[::-1]",
    "code_2": "def is_binary_palindrome(n):\n    if not isinstance(n, int):\n        raise ValueError(\"Input must be an integer\")\n    if n < 0:\n        return False\n    length = n.bit_length()\n    for i in range(length // 2):\n        if ((n >> i) & 1) != ((n >> (length - 1 - i)) & 1):\n            return False\n    return True"
  },
  {
    "task": "Rotate String by N Characters",
    "input": "a string and an integer N",
    "output": "string rotated right by N characters",
    "function_name": "rotate_string",
    "code_1": "def rotate_string(s, n):\n    \"\"\"\n    Rotate the input string s to the right by n characters.\n    If n is larger than the length of s, it wraps around using modulo.\n    \"\"\"\n    length = len(s)\n    if length == 0:\n        return s\n    n = n % length\n    return s[-n:] + s[:-n]",
    "code_2": "def rotate_string(s, n):\n    from collections import deque\n    d = deque(s)\n    d.rotate(n)\n    return ''.join(d)"
  },
  {
    "task": "Swap First and Last Elements",
    "input": "list of elements",
    "output": "list with first and last elements swapped",
    "function_name": "swap_first_last",
    "code_1": "def swap_first_last(lst):\n    \"\"\"Swap the first and last elements of the list.\"\"\"\n    if len(lst) < 2:\n        return lst\n    lst[0], lst[-1] = lst[-1], lst[0]\n    return lst",
    "code_2": "def swap_first_last(lst):\n    \"\"\"Return a new list with the first and last elements swapped.\"\"\"\n    # For lists shorter than 2, nothing to swap\n    if len(lst) < 2:\n        return lst\n    # Construct a new list: last element, middle slice, first element\n    return [lst[-1]] + lst[1:-1] + [lst[0]]"
  },
  {
    "task": "Merge Overlapping Intervals",
    "input": "A list of intervals (each interval is a two-element list [start, end])",
    "output": "A list of merged non-overlapping intervals",
    "function_name": "merge_overlapping_intervals",
    "code_1": "def merge_overlapping_intervals(intervals):\n    # Return empty list if no intervals provided\n    if not intervals:\n        return []\n    # Sort intervals by their start time\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for current in intervals[1:]:\n        prev = merged[-1]\n        # If the current interval overlaps with the previous, merge them\n        if current[0] <= prev[1]:\n            prev[1] = max(prev[1], current[1])\n        else:\n            # No overlap, add the current interval\n            merged.append(current)\n    return merged",
    "code_2": "from functools import reduce\n\ndef merge_overlapping_intervals(intervals):\n    # Sort intervals by their start boundary\n    sorted_ints = sorted(intervals, key=lambda x: x[0])\n\n    # Reducer to merge as we accumulate\n    def merge_acc(acc, curr):\n        if not acc or acc[-1][1] < curr[0]:\n            # No overlap: append a new interval copy\n            acc.append(curr.copy())\n        else:\n            # Overlap: extend the end as needed\n            acc[-1][1] = max(acc[-1][1], curr[1])\n        return acc\n\n    # Run the reduction, initial accumulator is empty list\n    return reduce(merge_acc, sorted_ints, [])"
  },
  {
    "task": "Count Trailing Zeros in Factorial",
    "input": "non-negative integer",
    "output": "integer count of trailing zeros in its factorial",
    "function_name": "count_trailing_zeros",
    "code_1": "def count_trailing_zeros(n):\n    \"\"\"Return the number of trailing zeros in n!\"\"\"\n    count = 0\n    divisor = 5\n    while n >= divisor:\n        count += n // divisor\n        divisor *= 5\n    return count",
    "code_2": "def count_trailing_zeros(n):\n    \"\"\"Return the number of trailing zeros in n! using iterative division.\"\"\"\n    total = 0\n    while n > 0:\n        n //= 5\n        total += n\n    return total"
  },
  {
    "task": "Find Majority Element",
    "input": "list of elements",
    "output": "element appearing more than half the time or None",
    "function_name": "find_majority_element",
    "code_1": "def find_majority_element(nums):\n    # Boyer-Moore Voting Algorithm to find candidate\n    candidate = None\n    count = 0\n    for num in nums:\n        if count == 0:\n            candidate = num\n            count = 1\n        elif num == candidate:\n            count += 1\n        else:\n            count -= 1\n    # Verify candidate\n    if candidate is not None and nums.count(candidate) > len(nums) // 2:\n        return candidate\n    return None",
    "code_2": "def find_majority_element(nums):\n    from collections import Counter\n    counts = Counter(nums)\n    if not counts:\n        return None\n    element, freq = counts.most_common(1)[0]\n    return element if freq > len(nums) // 2 else None"
  },
  {
    "task": "Shuffle List",
    "input": "list of elements",
    "output": "list with elements in random order",
    "function_name": "shuffle_list",
    "code_1": "def shuffle_list(lst):\n    \"\"\"Return a new list with elements of lst in random order.\"\"\"\n    import random\n    return random.sample(lst, len(lst))",
    "code_2": "def shuffle_list(lst):\n    \"\"\"Return a new list with elements of lst in random order using Fisher\u2013Yates shuffle.\"\"\"\n    import random\n    arr = list(lst)\n    for i in range(len(arr) - 1, 0, -1):\n        j = random.randrange(i + 1)\n        arr[i], arr[j] = arr[j], arr[i]\n    return arr"
  },
  {
    "task": "Snake to Kebab Case",
    "input": "string in snake_case",
    "output": "string converted to kebab-case",
    "function_name": "snake_to_kebab_case",
    "code_1": "def snake_to_kebab_case(s):\n    \"\"\"\n    Convert a snake_case string to kebab-case.\n    \"\"\"\n    return s.replace('_', '-')",
    "code_2": "def snake_to_kebab_case(s):\n    '''Convert a snake_case string to kebab-case using split and join.'''\n    parts = s.split('_')\n    return '-'.join(parts)"
  },
  {
    "task": "Sum at Even Indices",
    "input": "list of numbers",
    "output": "sum of elements at even indices (0-based)",
    "function_name": "sum_even_indices",
    "code_1": "def sum_even_indices(nums):\n    \"\"\"Return the sum of elements at even indices in the list.\"\"\"\n    return sum(nums[i] for i in range(0, len(nums), 2))",
    "code_2": "def sum_even_indices(nums):\n    \"\"\"Return the sum of elements at even indices in the list.\"\"\"\n    # Use slicing to pick out even-indexed elements\n    return sum(nums[::2])"
  },
  {
    "task": "Longest Increasing Run",
    "input": "list of integers",
    "output": "length of the longest strictly increasing contiguous subsequence",
    "function_name": "longest_increasing_run",
    "code_1": "def longest_increasing_run(nums):\n    # Return 0 for empty list\n    if not nums:\n        return 0\n    max_len = 1\n    current_len = 1\n    # Iterate through the list starting from the second element\n    for i in range(1, len(nums)):\n        if nums[i] > nums[i-1]:\n            # Continue the increasing run\n            current_len += 1\n            if current_len > max_len:\n                max_len = current_len\n        else:\n            # Reset for a new run\n            current_len = 1\n    return max_len",
    "code_2": "def longest_increasing_run(nums):\n    \"\"\"Return the length of the longest strictly increasing contiguous subsequence.\"\"\"\n    n = len(nums)\n    if n == 0:\n        return 0\n    max_len = 1\n    i = 0\n    while i < n:\n        j = i + 1\n        # extend the run while strictly increasing\n        while j < n and nums[j] > nums[j-1]:\n            j += 1\n        run_len = j - i\n        if run_len > max_len:\n            max_len = run_len\n        i = j\n    return max_len"
  },
  {
    "task": "First Non-Repeated Character",
    "input": "a string",
    "output": "the first character that does not repeat, or an empty string if none",
    "function_name": "first_non_repeated_char",
    "code_1": "def first_non_repeated_char(s):\n    from collections import Counter\n    counts = Counter(s)\n    for char in s:\n        if counts[char] == 1:\n            return char\n    return \"\"",
    "code_2": "def first_non_repeated_char(s):\n    return next((c for c in s if s.count(c) == 1), \"\")"
  },
  {
    "task": "List Difference",
    "input": "two lists of integers",
    "output": "a list of elements in the first list but not in the second, in original order",
    "function_name": "list_difference",
    "code_1": "def list_difference(list1, list2):\n    \"\"\"\n    Return a list of elements in list1 that are not in list2, preserving order.\n    \"\"\"\n    set2 = set(list2)\n    return [x for x in list1 if x not in set2]",
    "code_2": "from itertools import filterfalse\n\ndef list_difference(list1, list2):\n    \"\"\"\n    Return a list of elements in list1 that are not in list2, preserving order.\n    \"\"\"\n    # filterfalse yields items for which list2.__contains__ is False\n    return list(filterfalse(list2.__contains__, list1))"
  },
  {
    "task": "Group Strings by Length",
    "input": "a list of strings",
    "output": "a dictionary mapping each string length to the list of strings of that length",
    "function_name": "group_strings_by_length",
    "code_1": "def group_strings_by_length(strings):\n    result = {}\n    for s in strings:\n        length = len(s)\n        result.setdefault(length, []).append(s)\n    return result",
    "code_2": "def group_strings_by_length(strings):\n    # Collect unique lengths\n    lengths = set(map(len, strings))\n    # Build dictionary with a comprehension grouping by each length\n    return {length: [s for s in strings if len(s) == length] for length in lengths}"
  },
  {
    "task": "Count Consonants",
    "input": "a string",
    "output": "integer count of consonant letters in the string",
    "function_name": "count_consonants",
    "code_1": "def count_consonants(s):\n    \"\"\"\n    Count the number of consonant letters in the input string s.\n    Consonants are defined as alphabetic characters excluding vowels a, e, i, o, u.\n    \"\"\"\n    consonants = set('bcdfghjklmnpqrstvwxyz')\n    return sum(1 for char in s.lower() if char in consonants)",
    "code_2": "import re\n\ndef count_consonants(s):\n    '''Count consonant letters in the input string using regex.'''\n    # Find all consonant letters (case-insensitive) and return their count\n    return len(re.findall(r'[b-df-hj-np-tv-z]', s, flags=re.IGNORECASE))"
  },
  {
    "task": "Count Distinct Prime Factors",
    "input": "positive integer",
    "output": "integer count of distinct prime factors",
    "function_name": "count_distinct_prime_factors",
    "code_1": "def count_distinct_prime_factors(n):\n    count = 0\n    # handle factor 2\n    if n % 2 == 0:\n        count += 1\n        while n % 2 == 0:\n            n //= 2\n    # handle odd factors\n    i = 3\n    while i * i <= n:\n        if n % i == 0:\n            count += 1\n            while n % i == 0:\n                n //= i\n        i += 2\n    # if remaining n is a prime > 2\n    if n > 1:\n        count += 1\n    return count",
    "code_2": "def count_distinct_prime_factors(n):\n    def gen_factors(k):\n        # factor out 2s\n        while k % 2 == 0:\n            yield 2\n            k //= 2\n        # factor out odd primes\n        import math\n        f = 3\n        limit = math.isqrt(k)\n        while f <= limit:\n            while k % f == 0:\n                yield f\n                k //= f\n                limit = math.isqrt(k)\n            f += 2\n        # if remainder is prime\n        if k > 1:\n            yield k\n    return len(set(gen_factors(n)))"
  },
  {
    "task": "Remove HTML Tags",
    "input": "a string containing simple HTML tags",
    "output": "the string with all tags (enclosed in < >) removed",
    "function_name": "remove_html_tags",
    "code_1": "def remove_html_tags(text):\n    import re\n    # Remove HTML tags\n    return re.sub(r'<[^>]+>', '', text)",
    "code_2": "def remove_html_tags(text):\n    result = []\n    in_tag = False\n    for ch in text:\n        if ch == '<':\n            in_tag = True\n        elif ch == '>' and in_tag:\n            in_tag = False\n        elif not in_tag:\n            result.append(ch)\n    return ''.join(result)"
  },
  {
    "task": "All Substrings of Length K",
    "input": "a string and an integer K",
    "output": "a list of all substrings of the string that are exactly length K",
    "function_name": "substrings_of_length_k",
    "code_1": "def substrings_of_length_k(s, k):\n    \"\"\"\n    Return all substrings of the input string s that are exactly length k.\n    \"\"\"\n    # If k is non-positive or greater than the string length, return an empty list\n    if k <= 0 or k > len(s):\n        return []\n    # Use list comprehension to collect all substrings of length k\n    return [s[i:i+k] for i in range(len(s) - k + 1)]",
    "code_2": "def substrings_of_length_k(s, k):\n    \"\"\"\n    Return all substrings of the input string s that are exactly length k.\n    This implementation uses a sliding window via zip over shifted slices.\n    \"\"\"\n    if k <= 0 or k > len(s):\n        return []\n    # Create k slices of s, each offset by i, then zip to form windows\n    slices = (s[i:] for i in range(k))\n    return [''.join(chunk) for chunk in zip(*slices)]"
  },
  {
    "task": "Largest Difference",
    "input": "a list of integers",
    "output": "the difference between the maximum and minimum elements",
    "function_name": "largest_difference",
    "code_1": "def largest_difference(nums):\n    \"\"\"\n    Return the difference between the maximum and minimum elements of the list.\n    Raises ValueError if the list is empty.\n    \"\"\"\n    if not nums:\n        raise ValueError(\"Input list must not be empty\")\n    return max(nums) - min(nums)",
    "code_2": "def largest_difference(nums):\n    try:\n        it = iter(nums)\n        min_val = max_val = next(it)\n    except StopIteration:\n        raise ValueError(\"Input list must not be empty\")\n    for n in it:\n        if n < min_val:\n            min_val = n\n        elif n > max_val:\n            max_val = n\n    return max_val - min_val"
  },
  {
    "task": "Longest Common Suffix",
    "input": "a list of strings",
    "output": "the longest suffix shared by all strings, or an empty string if none",
    "function_name": "longest_common_suffix",
    "code_1": "def longest_common_suffix(strs):\n    if not strs:\n        return \"\"\n    # Reverse all strings to compare prefixes\n    revs = [s[::-1] for s in strs]\n    common = []\n    for chars in zip(*revs):\n        # If all characters in this position match, add to common\n        if all(c == chars[0] for c in chars):\n            common.append(chars[0])\n        else:\n            break\n    # Reverse the collected prefix to get the suffix\n    return ''.join(common)[::-1]",
    "code_2": "def longest_common_suffix(strs):\n    if not strs:\n        return \"\"\n    # Start with the shortest string as the initial suffix candidate\n    suffix = min(strs, key=len)\n    for s in strs:\n        # Trim the leftmost character until s ends with the current suffix\n        while suffix and not s.endswith(suffix):\n            suffix = suffix[1:]\n        if not suffix:\n            return \"\"\n    return suffix"
  },
  {
    "task": "Check Interval Overlap",
    "input": "two intervals as two-element tuples (start, end)",
    "output": "True if the intervals overlap, otherwise False",
    "function_name": "check_interval_overlap",
    "code_1": "def check_interval_overlap(interval1, interval2):\n    start1, end1 = interval1\n    start2, end2 = interval2\n    # Two intervals overlap if the later start is not after the earlier end\n    return max(start1, start2) <= min(end1, end2)",
    "code_2": "def check_interval_overlap(interval1, interval2):\n    s1, e1 = interval1\n    s2, e2 = interval2\n    # intervals overlap unless one ends strictly before the other starts\n    return not (e1 < s2 or e2 < s1)"
  },
  {
    "task": "Interleave Two Lists",
    "input": "two lists",
    "output": "a single list with elements alternately taken from each, appending any leftovers at the end",
    "function_name": "interleave_lists",
    "code_1": "def interleave_lists(list1, list2):\n    result = []\n    for a, b in zip(list1, list2):\n        result.append(a)\n        result.append(b)\n    if len(list1) > len(list2):\n        result.extend(list1[len(list2):])\n    else:\n        result.extend(list2[len(list1):])\n    return result",
    "code_2": "import itertools\n\ndef interleave_lists(list1, list2):\n    sentinel = object()\n    # Pair elements with a unique sentinel, then flatten and skip sentinels\n    return [x for a, b in itertools.zip_longest(list1, list2, fillvalue=sentinel)\n            for x in (a, b) if x is not sentinel]\n"
  },
  {
    "task": "Count Bigrams",
    "input": "a string",
    "output": "a dictionary where keys are two-character sequences and values are their counts in the string",
    "function_name": "count_bigrams",
    "code_1": "def count_bigrams(s):\n    d = {}\n    for i in range(len(s) - 1):\n        bigram = s[i:i+2]\n        d[bigram] = d.get(bigram, 0) + 1\n    return d",
    "code_2": "def count_bigrams(s):\n    from collections import Counter\n    # build bigrams by zipping adjacent characters and count them\n    return dict(Counter(a + b for a, b in zip(s, s[1:])))"
  },
  {
    "task": "Element-wise List Multiplication",
    "input": "two lists of numbers of equal length",
    "output": "a list where each element is the product of the corresponding elements from the input lists",
    "function_name": "elementwise_multiply",
    "code_1": "def elementwise_multiply(list1, list2):\n    return [a * b for a, b in zip(list1, list2)]",
    "code_2": "def elementwise_multiply(list1, list2):\n    from itertools import starmap\n    from operator import mul\n    # Multiply corresponding elements using starmap and operator.mul\n    return list(starmap(mul, zip(list1, list2)))"
  },
  {
    "task": "Sum of Odd Numbers",
    "input": "a list of integers",
    "output": "the sum of all odd integers in the list",
    "function_name": "sum_odd_numbers",
    "code_1": "def sum_odd_numbers(numbers):\n    return sum(n for n in numbers if n % 2 != 0)",
    "code_2": "def sum_odd_numbers(numbers):\n    total = 0\n    i = 0\n    length = len(numbers)\n    while i < length:\n        num = numbers[i]\n        if num % 2 != 0:\n            total += num\n        i += 1\n    return total"
  },
  {
    "task": "Hamming Distance",
    "input": "two strings of equal length",
    "output": "the number of positions at which the corresponding characters are different",
    "function_name": "hamming_distance",
    "code_1": "def hamming_distance(s1, s2):\n    if len(s1) != len(s2):\n        raise ValueError(\"Sequences must be of equal length\")\n    return sum(ch1 != ch2 for ch1, ch2 in zip(s1, s2))",
    "code_2": "def hamming_distance(s1, s2):\n    if len(s1) != len(s2):\n        raise ValueError(\"Sequences must be of equal length\")\n    dist = 0\n    for i in range(len(s1)):\n        if s1[i] != s2[i]:\n            dist += 1\n    return dist"
  },
  {
    "task": "List Palindrome Check",
    "input": "a list of elements",
    "output": "True if the list reads the same forwards and backwards, otherwise False",
    "function_name": "is_palindrome_list",
    "code_1": "def is_palindrome_list(lst):\n    \"\"\"Return True if the list reads the same forwards and backwards.\"\"\"\n    return lst == lst[::-1]",
    "code_2": "def is_palindrome_list(lst):\n    \"\"\"Return True if the list reads the same forwards and backwards.\"\"\"\n    left, right = 0, len(lst) - 1\n    while left < right:\n        if lst[left] != lst[right]:\n            return False\n        left += 1\n        right -= 1\n    return True"
  },
  {
    "task": "Missing Alphabets in Sentence",
    "input": "a string",
    "output": "a list of lowercase alphabet letters not present in the string",
    "function_name": "missing_alphabets",
    "code_1": "def missing_alphabets(s):\n    import string\n    # Define the set of all lowercase letters\n    all_letters = set(string.ascii_lowercase)\n    # Extract lowercase letters from the input string\n    present = set(s.lower()) & all_letters\n    # Determine which letters are missing\n    missing = sorted(all_letters - present)\n    return missing",
    "code_2": "def missing_alphabets(s):\n    # Gather all lowercase letters found in the input\n    present = {ch for ch in s.lower() if 'a' <= ch <= 'z'}\n    # Return those letters from 'a' to 'z' that aren't in present\n    return [chr(i) for i in range(ord('a'), ord('z')+1) if chr(i) not in present]"
  },
  {
    "task": "Sum of Primes in List",
    "input": "a list of integers",
    "output": "the sum of all prime numbers in the list",
    "function_name": "sum_primes_in_list",
    "code_1": "def sum_primes_in_list(numbers):\n    \"\"\"\n    Return the sum of all prime numbers in the input list.\n    \"\"\"\n    def is_prime(n):\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    return sum(n for n in numbers if is_prime(n))",
    "code_2": "def sum_primes_in_list(numbers):\n    # Use Sieve of Eratosthenes to find all primes up to the maximum\n    max_n = max(numbers, default=1)\n    if max_n < 2:\n        return 0\n    sieve = [True] * (max_n + 1)\n    sieve[0:2] = [False, False]\n    for i in range(2, int(max_n**0.5) + 1):\n        if sieve[i]:\n            for j in range(i * i, max_n + 1, i):\n                sieve[j] = False\n    # Sum only those numbers that are marked prime in the sieve\n    return sum(n for n in numbers if n >= 2 and sieve[n])\n"
  },
  {
    "task": "Local Maxima Count in List",
    "input": "a list of numbers",
    "output": "the count of elements that are strictly greater than their immediate neighbors",
    "function_name": "count_local_maxima",
    "code_1": "def count_local_maxima(lst):\n    \"\"\"\n    Count elements in the list that are strictly greater than their immediate neighbors.\n    Returns 0 for lists shorter than 3.\n    \"\"\"\n    count = 0\n    # Iterate over each element except the first and last\n    for i in range(1, len(lst) - 1):\n        if lst[i] > lst[i - 1] and lst[i] > lst[i + 1]:\n            count += 1\n    return count",
    "code_2": "def count_local_maxima(lst):\n    \"\"\"Count elements strictly greater than their immediate neighbors.\"\"\"\n    return sum(\n        1\n        for prev, curr, nxt in zip(lst, lst[1:], lst[2:])\n        if curr > prev and curr > nxt\n    )"
  },
  {
    "task": "Sentence Case Conversion",
    "input": "a string containing sentences separated by periods",
    "output": "a string with the first letter of each sentence capitalized and the rest lowercase",
    "function_name": "sentence_case",
    "code_1": "def sentence_case(text):\n    parts = text.split('.')\n    new_parts = []\n    for part in parts:\n        part = part.strip()\n        if not part:\n            continue\n        s = part.lower()\n        s = s[0].upper() + s[1:] if s else ''\n        new_parts.append(s)\n    result = '. '.join(new_parts)\n    if text.endswith('.'):\n        result += '.'\n    return result",
    "code_2": "def sentence_case(text):\n    sentences = []\n    i, n = 0, len(text)\n    while i < n:\n        # Find the next period\n        dot = text.find('.', i)\n        if dot == -1:\n            fragment = text[i:]\n            i = n\n        else:\n            fragment = text[i:dot]\n            i = dot + 1\n        # Trim and lowercase\n        frag = fragment.strip().lower()\n        if frag:\n            sentences.append(frag[0].upper() + frag[1:])\n        # Skip any whitespace after a period\n        while i < n and text[i].isspace():\n            i += 1\n    result = '. '.join(sentences)\n    # Preserve a trailing period if it was in the original\n    if text.endswith('.'):\n        result += '.'\n    return result"
  },
  {
    "task": "Happy Number Check",
    "input": "integer",
    "output": "boolean",
    "function_name": "is_happy_number",
    "code_1": "def is_happy_number(n):\n    visited = set()\n    while n != 1 and n not in visited:\n        visited.add(n)\n        n = sum(int(d)**2 for d in str(n))\n    return n == 1",
    "code_2": "def is_happy_number(n):\n    def next_num(x):\n        tot = 0\n        while x > 0:\n            digit = x % 10\n            tot += digit * digit\n            x //= 10\n        return tot\n\n    # Use Floyd's cycle detection to find a loop\n    slow = next_num(n)\n    fast = next_num(next_num(n))\n    while slow != fast:\n        slow = next_num(slow)\n        fast = next_num(next_num(fast))\n    return slow == 1"
  },
  {
    "task": "Generate Combinations of Size K",
    "input": "a list and an integer k",
    "output": "a list of all unique combinations (as lists) of length k from the input list",
    "function_name": "generate_combinations",
    "code_1": "def generate_combinations(lst, k):\n    \"\"\"\n    Return all unique combinations of length k from the input list.\n    \"\"\"\n    result = []\n    def backtrack(start, path):\n        if len(path) == k:\n            result.append(path.copy())\n            return\n        for i in range(start, len(lst)):\n            path.append(lst[i])\n            backtrack(i + 1, path)\n            path.pop()\n    backtrack(0, [])\n    return result",
    "code_2": "import itertools\n\ndef generate_combinations(lst, k):\n    \"\"\"\n    Return all unique combinations of length k from the input list using itertools.\n    \"\"\"\n    return [list(c) for c in itertools.combinations(lst, k)]"
  },
  {
    "task": "Normalize List",
    "input": "list of numbers",
    "output": "list of floats",
    "function_name": "normalize_list",
    "code_1": "def normalize_list(nums):\n    \"\"\"\n    Normalize a list of numbers to the range [0, 1].\n    If the list is empty, returns an empty list.\n    If all values are the same, returns a list of 0.0s.\n    \"\"\"\n    # Handle empty list\n    if not nums:\n        return []\n    min_val = min(nums)\n    max_val = max(nums)\n    range_val = max_val - min_val\n    # Avoid division by zero if all values are identical\n    if range_val == 0:\n        return [0.0 for _ in nums]\n    # Perform min-max normalization\n    return [(x - min_val) / range_val for x in nums]",
    "code_2": "from functools import reduce\n\ndef normalize_list(nums):\n    # Handle empty list\n    if not nums:\n        return []\n    # Find min and max in one pass\n    min_val, max_val = reduce(\n        lambda acc, x: (min(acc[0], x), max(acc[1], x)),\n        nums,\n        (nums[0], nums[0])\n    )\n    # If all values identical\n    if min_val == max_val:\n        return [0.0] * len(nums)\n    # Normalize\n    diff = max_val - min_val\n    return list(map(lambda x: (x - min_val) / diff, nums))"
  },
  {
    "task": "Standard Deviation",
    "input": "list of numbers",
    "output": "float",
    "function_name": "standard_deviation",
    "code_1": "def standard_deviation(numbers):\n    \"\"\"Calculate the standard deviation of a list of numbers.\"\"\"\n    n = len(numbers)\n    if n == 0:\n        return 0.0\n    mean = sum(numbers) / n\n    variance = sum((x - mean) ** 2 for x in numbers) / n\n    return variance ** 0.5",
    "code_2": "def standard_deviation(numbers):\n    from math import sqrt\n    count = 0\n    mean = 0.0\n    M2 = 0.0\n    for x in numbers:\n        count += 1\n        delta = x - mean\n        mean += delta / count\n        M2 += delta * (x - mean)\n    if count == 0:\n        return 0.0\n    variance = M2 / count\n    return sqrt(variance)"
  },
  {
    "task": "Extract File Extension",
    "input": "a filename string",
    "output": "the file extension as a string, or an empty string if there is none",
    "function_name": "extract_file_extension",
    "code_1": "def extract_file_extension(filename):\n    import os\n    # Use os.path.splitext to separate the extension (includes the dot)\n    ext = os.path.splitext(filename)[1]\n    # Remove the leading dot if present\n    if ext.startswith('.'):\n        return ext[1:]\n    return ''",
    "code_2": "def extract_file_extension(filename):\n    # Split on the last dot; ensure there's text before the dot\n    head, sep, tail = filename.rpartition('.')\n    # If a dot was found and it's not the first character, return the part after it\n    return tail if sep and head else ''"
  },
  {
    "task": "Euclidean Norm",
    "input": "list of numbers",
    "output": "float",
    "function_name": "euclidean_norm",
    "code_1": "def euclidean_norm(numbers):\n    '''Compute the Euclidean norm (L2 norm) of a list of numbers.'''\n    return sum(x*x for x in numbers) ** 0.5",
    "code_2": "import math\n\ndef euclidean_norm(numbers):\n    \"\"\"Compute the Euclidean norm (L2 norm) of a list of numbers using math.hypot.\"\"\"\n    # math.hypot accepts multiple args and returns sqrt(x1*x1 + x2*x2 + ...)\n    return math.hypot(*numbers)\n"
  },
  {
    "task": "Email Validation",
    "input": "string",
    "output": "boolean",
    "function_name": "is_valid_email",
    "code_1": "def is_valid_email(email):\n    import re\n    pattern = r\"[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}\"\n    return bool(re.fullmatch(pattern, email))",
    "code_2": "def is_valid_email(email):\n    import string\n    parts = email.split('@')\n    if len(parts) != 2:\n        return False\n    local, domain = parts\n    if not local or not domain:\n        return False\n    # Local part checks\n    if local[0] == '.' or local[-1] == '.':\n        return False\n    if '..' in local:\n        return False\n    allowed = set(string.ascii_letters + string.digits + '._%+-')\n    for ch in local:\n        if ch not in allowed:\n            return False\n    # Domain checks\n    labels = domain.split('.')\n    if len(labels) < 2:\n        return False\n    for label in labels:\n        if not label:\n            return False\n        if label[0] == '-' or label[-1] == '-':\n            return False\n        for ch in label:\n            if not (ch.isalnum() or ch == '-'):\n                return False\n    tld = labels[-1]\n    if len(tld) < 2 or not tld.isalpha():\n        return False\n    return True"
  },
  {
    "task": "Count Overlapping Substrings",
    "input": "string, substring",
    "output": "integer",
    "function_name": "count_overlapping_substrings",
    "code_1": "def count_overlapping_substrings(s, substring):\n    count = 0\n    for i in range(len(s) - len(substring) + 1):\n        if s[i:i+len(substring)] == substring:\n            count += 1\n    return count",
    "code_2": "def count_overlapping_substrings(s, substring):\n    import re\n    # An empty substring occurs at every position, including the end\n    if substring == '':\n        return len(s) + 1\n    # Use a lookahead to find overlapping matches\n    pattern = '(?=' + re.escape(substring) + ')'\n    return len(re.findall(pattern, s))"
  },
  {
    "task": "Convert 12-Hour to 24-Hour Time",
    "input": "string (e.g. \"02:30 PM\")",
    "output": "string (e.g. \"14:30\")",
    "function_name": "convert_12_to_24",
    "code_1": "def convert_12_to_24(time_str):\n    time_str = time_str.strip()\n    parts = time_str.split()\n    if len(parts) != 2:\n        raise ValueError('Invalid time format')\n    time_part, period = parts\n    period = period.upper()\n    if period not in ('AM', 'PM'):\n        raise ValueError('Invalid period, must be AM or PM')\n    hour_part, minute_part = time_part.split(':')\n    hour = int(hour_part)\n    minute = int(minute_part)\n    if hour < 1 or hour > 12 or minute < 0 or minute > 59:\n        raise ValueError('Invalid time value')\n    if period == 'AM':\n        if hour == 12:\n            hour = 0\n    else:\n        if hour != 12:\n            hour += 12\n    return f'{hour:02d}:{minute:02d}'",
    "code_2": "import datetime\n\ndef convert_12_to_24(time_str):\n    try:\n        dt = datetime.datetime.strptime(time_str.strip(), '%I:%M %p')\n    except ValueError:\n        raise ValueError('Invalid time format')\n    return dt.strftime('%H:%M')"
  },
  {
    "task": "Random Float Generator",
    "input": "integer n, float a, float b",
    "output": "list of n floats",
    "function_name": "generate_random_floats",
    "code_1": "def generate_random_floats(n, a, b):\n    import random\n    \"\"\"\n    Generate and return a list of n random floats between a and b.\n    \"\"\"\n    return [random.uniform(a, b) for _ in range(n)]",
    "code_2": "def generate_random_floats(n, a, b):\n    import random\n    # scale random.random() values to the interval [a, b]\n    delta = b - a\n    return list(map(lambda _: a + random.random() * delta, range(n)))"
  },
  {
    "task": "Running Product List",
    "input": "A list of numbers",
    "output": "A list of numbers where each element is the cumulative product up to that index",
    "function_name": "running_product",
    "code_1": "def running_product(nums):\n    \"\"\"Return a list where each element is the cumulative product up to that index.\"\"\"\n    result = []\n    prod = 1\n    for num in nums:\n        prod *= num\n        result.append(prod)\n    return result",
    "code_2": "def running_product(nums):\n    from itertools import accumulate\n    import operator\n    return list(accumulate(nums, operator.mul))"
  },
  {
    "task": "Extract Hashtags",
    "input": "string",
    "output": "list of strings",
    "function_name": "extract_hashtags",
    "code_1": "def extract_hashtags(text):\n    \"\"\"\n    Extracts all hashtags from the given text and returns them as a list of strings.\n    A hashtag is defined as a '#' followed by one or more word characters (letters, digits, underscore).\n    \"\"\"\n    import re\n    # Find all occurrences of hashtags using a regular expression\n    return re.findall(r'#\\w+', text)",
    "code_2": "def extract_hashtags(text):\n    '''Extracts all hashtags from text without using regular expressions.'''\n    results = []\n    length = len(text)\n    i = 0\n    while i < length:\n        if text[i] == '#':\n            j = i + 1\n            if j < length and (text[j].isalnum() or text[j] == '_'):\n                start = i\n                j += 1\n                while j < length and (text[j].isalnum() or text[j] == '_'):\n                    j += 1\n                results.append(text[start:j])\n                i = j\n                continue\n        i += 1\n    return results"
  },
  {
    "task": "Count Prime Digits",
    "input": "An integer",
    "output": "An integer representing the count of digits in the input that are prime (2, 3, 5, 7)",
    "function_name": "count_prime_digits",
    "code_1": "def count_prime_digits(n):\n    # Convert to positive and iterate over digits\n    count = 0\n    for digit in str(abs(n)):\n        if digit in ('2','3','5','7'):\n            count += 1\n    return count",
    "code_2": "def count_prime_digits(n):\n    n = abs(n)\n    primes = {2, 3, 5, 7}\n    count = 0\n    while n:\n        if n % 10 in primes:\n            count += 1\n        n //= 10\n    return count"
  },
  {
    "task": "Count Uppercase Words",
    "input": "string",
    "output": "integer",
    "function_name": "count_uppercase_words",
    "code_1": "def count_uppercase_words(s):\n    import re\n    # Extract sequences of letters\n    words = re.findall(r\"[A-Za-z]+\", s)\n    # Count those that are fully uppercase\n    return sum(1 for w in words if w.isupper())",
    "code_2": "def count_uppercase_words(s):\n    # replace non-letters with spaces\n    sanitized = ''.join(ch if ch.isalpha() else ' ' for ch in s)\n    # split into words and count those fully uppercase\n    return sum(word == word.upper() for word in sanitized.split())"
  },
  {
    "task": "Binary Search",
    "input": "A sorted list of numbers and a target number",
    "output": "The index of the target in the list or -1 if not found",
    "function_name": "binary_search",
    "code_1": "def binary_search(nums, target):\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1",
    "code_2": "import bisect\n\ndef binary_search(nums, target):\n    idx = bisect.bisect_left(nums, target)\n    return idx if idx < len(nums) and nums[idx] == target else -1"
  },
  {
    "task": "List Symmetrization",
    "input": "A list of elements",
    "output": "A new list formed by appending the reverse of the input list to itself",
    "function_name": "list_symmetrization",
    "code_1": "def list_symmetrization(lst):\n    \"\"\"Return a new list formed by appending the reverse of the input list to itself.\"\"\"\n    return lst + lst[::-1]",
    "code_2": "def list_symmetrization(lst):\n    \"\"\"Return a new list formed by appending the reverse of the input list to itself.\"\"\"\n    return [*lst, *reversed(lst)]"
  },
  {
    "task": "Rotate Matrix 90 Degrees",
    "input": "A square matrix (list of lists)",
    "output": "The matrix rotated 90 degrees clockwise",
    "function_name": "rotate_matrix",
    "code_1": "def rotate_matrix(matrix):\n    \"\"\"\n    Rotate a square matrix 90 degrees clockwise.\n    :param matrix: List of lists representing the matrix\n    :return: Rotated matrix\n    \"\"\"\n    # Transpose and then reverse each row\n    return [list(reversed(col)) for col in zip(*matrix)]",
    "code_2": "def rotate_matrix(matrix):\n    \"\"\"\n    Rotate a square matrix 90 degrees clockwise using index mapping.\n    :param matrix: List of lists representing the matrix\n    :return: Rotated matrix\n    \"\"\"\n    n = len(matrix)\n    # Prepare an empty n x n matrix\n    rotated = [[None] * n for _ in range(n)]\n    # Map each element to its new position\n    for i in range(n):\n        for j in range(n):\n            rotated[i][j] = matrix[n - 1 - j][i]\n    return rotated"
  },
  {
    "task": "Longest Common Substring",
    "input": "Two strings",
    "output": "The longest common substring shared by both strings",
    "function_name": "longest_common_substring",
    "code_1": "def longest_common_substring(s1, s2):\n    # Handle empty input\n    if not s1 or not s2:\n        return \"\"\n    n, m = len(s1), len(s2)\n    # prev[j] will be the length of LCS ending at s1[i-1], s2[j-1] for previous i\n    prev = [0] * (m + 1)\n    max_len = 0\n    end_pos = 0\n    for i in range(1, n + 1):\n        curr = [0] * (m + 1)\n        for j in range(1, m + 1):\n            if s1[i-1] == s2[j-1]:\n                curr[j] = prev[j-1] + 1\n                if curr[j] > max_len:\n                    max_len = curr[j]\n                    end_pos = i\n        prev = curr\n    # Extract the longest common substring\n    return s1[end_pos - max_len:end_pos]",
    "code_2": "import difflib\n\ndef longest_common_substring(s1, s2):\n    if not s1 or not s2:\n        return \"\"\n    matcher = difflib.SequenceMatcher(None, s1, s2)\n    match = matcher.find_longest_match(0, len(s1), 0, len(s2))\n    return s1[match.a:match.a + match.size]"
  },
  {
    "task": "Zip and Sum Lists",
    "input": "Two lists of numbers of equal length",
    "output": "A list where each element is the sum of elements at the corresponding positions in the input lists",
    "function_name": "zip_sum_lists",
    "code_1": "def zip_sum_lists(list1, list2):\n    \"\"\"\n    Given two lists of numbers of equal length, return a new list where each element is the sum of\n    the elements at the corresponding positions in the input lists.\n    \"\"\"\n    return [a + b for a, b in zip(list1, list2)]",
    "code_2": "def zip_sum_lists(list1, list2):\n    \"\"\"Given two lists of numbers of equal length, return a new list where each element is the sum of the elements at the corresponding positions in the input lists.\"\"\"\n    # Use map with a lambda to pairwise add elements\n    return list(map(lambda x, y: x + y, list1, list2))"
  },
  {
    "task": "Cumulative XOR List",
    "input": "A list of integers",
    "output": "A list where each element is the XOR of all input elements up to that index",
    "function_name": "cumulative_xor",
    "code_1": "def cumulative_xor(nums):\n    \"\"\"\n    Given a list of integers, return a list where each element is the XOR of all input elements up to that index.\n    \"\"\"\n    result = []\n    current = 0\n    for num in nums:\n        current ^= num\n        result.append(current)\n    return result",
    "code_2": "from itertools import accumulate\nimport operator\n\ndef cumulative_xor(nums):\n    '''Return a list where each element is the XOR of all input elements up to that index.'''\n    # Use itertools.accumulate with the XOR operator for a concise prefix computation\n    return list(accumulate(nums, operator.xor))\n"
  },
  {
    "task": "Filter Strings by Prefix",
    "input": "a list of strings and a prefix string",
    "output": "a list of strings from the input list that start with the given prefix",
    "function_name": "filter_strings_by_prefix",
    "code_1": "def filter_strings_by_prefix(strings, prefix):\n    \"\"\"\n    Return a list of strings from the input list that start with the given prefix.\n    \"\"\"\n    return [s for s in strings if s.startswith(prefix)]",
    "code_2": "import re\n\ndef filter_strings_by_prefix(strings, prefix):\n    \"\"\"Return a list of strings from the input list that start with the given prefix using regex.\"\"\"\n    pattern = re.compile(r'^' + re.escape(prefix))\n    return list(filter(pattern.match, strings))"
  },
  {
    "task": "Sliding Window Maximum",
    "input": "A list of numbers and an integer k (window size)",
    "output": "A list of the maximum values in each sliding window of size k",
    "function_name": "sliding_window_maximum",
    "code_1": "def sliding_window_maximum(nums, k):\n    from collections import deque\n    # Edge cases\n    if not nums or k <= 0:\n        return []\n    result = []\n    dq = deque()  # stores indices of potential max elements\n    for i, num in enumerate(nums):\n        # Remove indices whose corresponding values are less than current num\n        while dq and nums[dq[-1]] < num:\n            dq.pop()\n        dq.append(i)\n        # Remove the index at the front if it's outside the current window\n        if dq[0] <= i - k:\n            dq.popleft()\n        # Once we've processed k elements, record the max for the window\n        if i >= k - 1:\n            result.append(nums[dq[0]])\n    return result",
    "code_2": "def sliding_window_maximum(nums, k):\n    # Using preprocessing with block-wise prefix/suffix maxima\n    n = len(nums)\n    if not nums or k <= 0 or k > n:\n        return []\n    # Build left max array: max from block start to i\n    left = [0] * n\n    for i in range(n):\n        if i % k == 0:\n            left[i] = nums[i]\n        else:\n            left[i] = max(left[i-1], nums[i])\n    # Build right max array: max from i to block end\n    right = [0] * n\n    for j in range(n-1, -1, -1):\n        if j == n-1 or (j+1) % k == 0:\n            right[j] = nums[j]\n        else:\n            right[j] = max(right[j+1], nums[j])\n    # Compute sliding window maxima\n    output = []\n    for i in range(n - k + 1):\n        output.append(max(right[i], left[i + k - 1]))\n    return output"
  },
  {
    "task": "Swap Dictionary Keys and Values",
    "input": "a dictionary with unique values",
    "output": "a new dictionary where original values are keys and original keys are values",
    "function_name": "swap_dict",
    "code_1": "def swap_dict(input_dict):\n    \"\"\"Return a new dictionary with keys and values swapped.\"\"\"\n    return {value: key for key, value in input_dict.items()}",
    "code_2": "def swap_dict(input_dict):\n    \"\"\"Return a new dictionary with keys and values swapped using zip.\"\"\"\n    return dict(zip(input_dict.values(), input_dict.keys()))"
  },
  {
    "task": "Count Prime Indices",
    "input": "a list of integers",
    "output": "the count of elements located at prime-numbered indices (0-based)",
    "function_name": "count_prime_indices",
    "code_1": "def count_prime_indices(nums):\n    # Count elements located at prime-numbered indices (0-based)\n    n = len(nums)\n    if n < 3:\n        return 0\n    # Sieve of Eratosthenes to find primes < n\n    sieve = [True] * n\n    sieve[0] = sieve[1] = False\n    p = 2\n    while p * p < n:\n        if sieve[p]:\n            for i in range(p*p, n, p):\n                sieve[i] = False\n        p += 1\n    # Count elements at prime indices\n    count = 0\n    for i in range(n):\n        if sieve[i]:\n            count += 1\n    return count",
    "code_2": "def count_prime_indices(nums):\n    def is_prime(k):\n        if k < 2:\n            return False\n        if k == 2:\n            return True\n        if k % 2 == 0:\n            return False\n        r = int(k ** 0.5)\n        for d in range(3, r + 1, 2):\n            if k % d == 0:\n                return False\n        return True\n    return sum(1 for i, _ in enumerate(nums) if is_prime(i))"
  },
  {
    "task": "Character Frequency Sort",
    "input": "A string",
    "output": "A string with characters sorted by descending frequency",
    "function_name": "char_frequency_sort",
    "code_1": "def char_frequency_sort(s):\n    from collections import Counter\n    counts = Counter(s)\n    sorted_items = sorted(counts.items(), key=lambda item: (-item[1], item[0]))\n    return ''.join([char * count for char, count in sorted_items])",
    "code_2": "def char_frequency_sort(s):\n    from itertools import groupby\n    # Sort characters to group identical ones\n    sorted_chars = sorted(s)\n    # Count frequencies by grouping\n    freq_list = [(char, sum(1 for _ in group)) for char, group in groupby(sorted_chars)]\n    # Sort by descending frequency, then lexicographically\n    freq_list.sort(key=lambda x: (-x[1], x[0]))\n    # Build and return the result\n    return ''.join(char * count for char, count in freq_list)"
  },
  {
    "task": "Dictionary Key Intersection",
    "input": "two dictionaries",
    "output": "a list of keys that appear in both dictionaries",
    "function_name": "get_common_keys",
    "code_1": "def get_common_keys(dict1, dict2):\n    return list(dict1.keys() & dict2.keys())",
    "code_2": "def get_common_keys(dict1, dict2):\n    # Use list comprehension to collect keys present in both\n    return [key for key in dict1 if key in dict2]"
  },
  {
    "task": "Every Nth Element",
    "input": "a list and an integer n",
    "output": "a list containing every n\u1d57\u02b0 element from the original list, starting with the first element",
    "function_name": "every_nth_element",
    "code_1": "def every_nth_element(lst, n):\n    \"\"\"Return a list containing every n\u1d57\u02b0 element from the original list, starting with the first element.\"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    return lst[::n]",
    "code_2": "def every_nth_element(lst, n):\n    \"\"\"Return a list containing every n\u1d57\u02b0 element from the original list, starting with the first element.\"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    result = []\n    for index, element in enumerate(lst):\n        if index % n == 0:\n            result.append(element)\n    return result\n"
  },
  {
    "task": "Pig Latin Converter",
    "input": "a single lowercase word",
    "output": "the word converted into Pig Latin (move first letter to end and add \"ay\")",
    "function_name": "pig_latin",
    "code_1": "def pig_latin(word):\n    return word[1:] + word[0] + \"ay\"",
    "code_2": "def pig_latin(word):\n    from collections import deque\n    # rotate characters so the first letter moves to the end\n    letters = deque(word)\n    letters.rotate(-1)\n    # reconstruct string and append 'ay'\n    return ''.join(letters) + 'ay'"
  },
  {
    "task": "Group Numbers by Parity",
    "input": "a list of integers",
    "output": "a dictionary with two keys \"even\" and \"odd\" mapping to lists of the even and odd numbers respectively",
    "function_name": "group_numbers_by_parity",
    "code_1": "def group_numbers_by_parity(numbers):\n    result = {\"even\": [], \"odd\": []}\n    for n in numbers:\n        if n % 2 == 0:\n            result[\"even\"].append(n)\n        else:\n            result[\"odd\"].append(n)\n    return result",
    "code_2": "def group_numbers_by_parity(numbers):\n    return {\n        'even': [n for n in numbers if n % 2 == 0],\n        'odd':  [n for n in numbers if n % 2 != 0]\n    }"
  },
  {
    "task": "Sum of Unique Digits",
    "input": "integer number",
    "output": "integer sum of digits that appear only once in the number",
    "function_name": "sum_unique_digits",
    "code_1": "def sum_unique_digits(n):\n    # Convert number to string without sign\n    s = str(abs(n))\n    # Count occurrences of each digit\n    counts = {}\n    for ch in s:\n        counts[ch] = counts.get(ch, 0) + 1\n    # Sum digits that appear only once\n    total = 0\n    for ch, cnt in counts.items():\n        if cnt == 1:\n            total += int(ch)\n    return total",
    "code_2": "def sum_unique_digits(n):\n    ds = list(map(int, str(abs(n))))\n    return sum(d for d in set(ds) if ds.count(d) == 1)"
  },
  {
    "task": "Check All Elements Identical",
    "input": "list of elements",
    "output": "boolean indicating if all elements in the list are identical",
    "function_name": "are_all_elements_identical",
    "code_1": "def are_all_elements_identical(lst):\n    if not lst:\n        return True\n    return all(x == lst[0] for x in lst)",
    "code_2": "def are_all_elements_identical(lst):\n    # Empty list is considered uniform\n    if not lst:\n        return True\n    # Count occurrences of the first element and compare to list length\n    return lst.count(lst[0]) == len(lst)"
  },
  {
    "task": "Find Nearest Number",
    "input": "a list of numbers and a target number",
    "output": "the number from the list closest to the target (if tie, return any)",
    "function_name": "find_nearest",
    "code_1": "def find_nearest(nums, target):\n    if not nums:\n        return None\n    closest = nums[0]\n    min_diff = abs(nums[0] - target)\n    for num in nums[1:]:\n        diff = abs(num - target)\n        if diff < min_diff:\n            min_diff = diff\n            closest = num\n    return closest",
    "code_2": "def find_nearest(nums, target):\n    if not nums:\n        return None\n    # Use Python's built-in min with a custom key for distance\n    return min(nums, key=lambda x: abs(x - target))\n"
  },
  {
    "task": "Swap Adjacent Elements",
    "input": "list of elements",
    "output": "list where each pair of adjacent elements is swapped",
    "function_name": "swap_adjacent",
    "code_1": "def swap_adjacent(lst):\n    result = []\n    for i in range(0, len(lst), 2):\n        if i + 1 < len(lst):\n            result.extend([lst[i+1], lst[i]])\n        else:\n            result.append(lst[i])\n    return result",
    "code_2": "def swap_adjacent(lst):\n    from itertools import chain\n    pairs = zip(lst[::2], lst[1::2])\n    swapped = list(chain.from_iterable((b, a) for a, b in pairs))\n    if len(lst) % 2:\n        swapped.append(lst[-1])\n    return swapped"
  },
  {
    "task": "Matrix Border Sum",
    "input": "a 2D list of numbers (matrix)",
    "output": "the sum of the elements on the border of the matrix",
    "function_name": "sum_matrix_border",
    "code_1": "def sum_matrix_border(matrix):\n    # Return 0 for empty matrix or rows\n    if not matrix or not matrix[0]:\n        return 0\n    rows = len(matrix)\n    cols = len(matrix[0])\n    # Sum top row\n    total = sum(matrix[0])\n    # Sum bottom row if distinct\n    if rows > 1:\n        total += sum(matrix[-1])\n    # Sum first and last elements of middle rows\n    for i in range(1, rows - 1):\n        total += matrix[i][0]\n        if cols > 1:\n            total += matrix[i][-1]\n    return total",
    "code_2": "def sum_matrix_border(matrix):\n    if not matrix or not matrix[0]:\n        return 0\n    rows, cols = len(matrix), len(matrix[0])\n    return sum(\n        val\n        for i, row in enumerate(matrix)\n        for j, val in enumerate(row)\n        if i in (0, rows - 1) or j in (0, cols - 1)\n    )"
  },
  {
    "task": "Binary String Addition",
    "input": "two strings representing binary numbers",
    "output": "a string representing their sum in binary",
    "function_name": "add_binary_strings",
    "code_1": "def add_binary_strings(a, b):\n    \"\"\"Add two binary strings and return their sum as a binary string.\"\"\"\n    i, j = len(a) - 1, len(b) - 1\n    carry = 0\n    result = []\n    # Process both strings from right to left\n    while i >= 0 or j >= 0 or carry:\n        total = carry\n        if i >= 0:\n            total += int(a[i])\n            i -= 1\n        if j >= 0:\n            total += int(b[j])\n            j -= 1\n        # Append current bit (0 or 1)\n        result.append(str(total % 2))\n        # Compute carry for next iteration\n        carry = total // 2\n    # The result is built in reverse order\n    return ''.join(reversed(result))",
    "code_2": "def add_binary_strings(a, b):\n    \"\"\"Add two binary strings by converting to integers and back.\"\"\"\n    # Convert inputs to integers, sum them, then format as binary\n    total = int(a, 2) + int(b, 2)\n    return bin(total)[2:]"
  },
  {
    "task": "Sum of Factorial Digits",
    "input": "non-negative integer",
    "output": "integer sum of the factorials of each digit",
    "function_name": "sum_of_factorial_digits",
    "code_1": "def sum_of_factorial_digits(n):\n    import math\n    \"\"\"\n    Calculate the sum of the factorial of each digit in the non-negative integer n.\n    \"\"\"\n    return sum(math.factorial(int(d)) for d in str(n))",
    "code_2": "def sum_of_factorial_digits(n):\n    # Precompute factorials for digits 0 through 9\n    fac = [1]\n    for i in range(1, 10):\n        fac.append(fac[-1] * i)\n    # Handle the special case where n is 0\n    if n == 0:\n        return fac[0]\n    total = 0\n    # Sum factorials of each digit\n    while n:\n        total += fac[n % 10]\n        n //= 10\n    return total"
  },
  {
    "task": "Extract File Name",
    "input": "string file path",
    "output": "string file name without directory path",
    "function_name": "extract_file_name",
    "code_1": "import os\n\ndef extract_file_name(file_path):\n    \"\"\"Extract the file name from a full file path.\"\"\"\n    return os.path.basename(file_path)",
    "code_2": "def extract_file_name(file_path):\n    # Locate the last directory separator (Unix or Windows)\n    last_sep = max(file_path.rfind('/'), file_path.rfind('\\\\'))\n    # Return everything after the last separator (or the whole string if none)\n    return file_path[last_sep + 1:]\n"
  },
  {
    "task": "Vowel Percentage",
    "input": "string",
    "output": "float percentage of characters that are vowels (a, e, i, o, u)",
    "function_name": "calculate_vowel_percentage",
    "code_1": "def calculate_vowel_percentage(input_string):\n    \"\"\"\n    Calculate the percentage of characters in the input string that are vowels (a, e, i, o, u).\n    Returns 0.0 for an empty string.\n    \"\"\"\n    if not input_string:\n        return 0.0\n    vowels = set('aeiouAEIOU')\n    count = sum(1 for c in input_string if c in vowels)\n    return (count / len(input_string)) * 100.0",
    "code_2": "import re\n\ndef calculate_vowel_percentage(input_string):\n    if not input_string:\n        return 0.0\n    # find all vowel occurrences using regex\n    matches = re.findall(r'[aeiou]', input_string, flags=re.IGNORECASE)\n    # compute percentage\n    return len(matches) * 100.0 / len(input_string)"
  },
  {
    "task": "Middle Character Extraction",
    "input": "non-empty string",
    "output": "string middle character (or two middle characters if length is even)",
    "function_name": "get_middle_character",
    "code_1": "def get_middle_character(s):\n    \"\"\"Return the middle character(s) of a non-empty string s.\"\"\"\n    n = len(s)\n    mid = n // 2\n    if n % 2 == 1:\n        return s[mid]\n    else:\n        return s[mid-1:mid+1]",
    "code_2": "def get_middle_character(s):\n    # Use divmod to determine even/odd and slice accordingly\n    half, rem = divmod(len(s), 2)\n    # rem == 1 -> odd length, pick single char; rem == 0 -> even, pick two chars\n    slc = (slice(half-1, half+1), slice(half, half+1))[rem]\n    return s[slc]"
  },
  {
    "task": "Adjacent Pair Sums",
    "input": "list of numbers",
    "output": "list of sums of each pair of adjacent elements",
    "function_name": "adjacent_pair_sums",
    "code_1": "def adjacent_pair_sums(nums):\n    \"\"\"Return a list of sums of each pair of adjacent elements in nums.\"\"\"\n    return [nums[i] + nums[i+1] for i in range(len(nums) - 1)]",
    "code_2": "def adjacent_pair_sums(nums):\n    \"\"\"Return sums of each pair of adjacent elements in nums.\"\"\"\n    return list(map(lambda a, b: a + b, nums, nums[1:]))"
  },
  {
    "task": "Count Primes in List",
    "input": "list of integers",
    "output": "integer count of prime numbers in the list",
    "function_name": "count_primes",
    "code_1": "def count_primes(numbers):\n    \"\"\"Return the count of prime numbers in the input list.\"\"\"\n    def is_prime(n):\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    count = 0\n    for num in numbers:\n        if is_prime(num):\n            count += 1\n    return count",
    "code_2": "def count_primes(numbers):\n    \"\"\"Return the count of prime numbers in the input list using a sieve approach.\"\"\"\n    if not numbers:\n        return 0\n    max_val = max(numbers)\n    if max_val < 2:\n        return 0\n    # Build sieve up to the maximum value in the list\n    sieve = [True] * (max_val + 1)\n    sieve[0:2] = [False, False]\n    limit = int(max_val**0.5) + 1\n    for i in range(2, limit):\n        if sieve[i]:\n            for multiple in range(i * i, max_val + 1, i):\n                sieve[multiple] = False\n    # Count primes in the original list\n    return sum(1 for n in numbers if 0 <= n <= max_val and sieve[n])"
  },
  {
    "task": "Count Palindromic Words",
    "input": "string (sentence)",
    "output": "integer (number of words that are palindromes)",
    "function_name": "count_palindromic_words",
    "code_1": "def count_palindromic_words(sentence):\n    import re\n    # Extract alphanumeric words\n    words = re.findall(r\"[A-Za-z0-9]+\", sentence)\n    # Count words that read the same forwards and backwards (case-insensitive)\n    count = 0\n    for w in words:\n        wl = w.lower()\n        if wl == wl[::-1]:\n            count += 1\n    return count",
    "code_2": "def count_palindromic_words(sentence):\n    count = 0\n    for token in sentence.split():\n        # Keep only alphanumeric characters, in lowercase\n        cleaned = ''.join(ch.lower() for ch in token if ch.isalnum())\n        # Check non-empty and palindrome\n        if cleaned and cleaned == cleaned[::-1]:\n            count += 1\n    return count"
  },
  {
    "task": "Word Length Histogram",
    "input": "list of strings",
    "output": "dictionary mapping word lengths (int) to their frequency (int)",
    "function_name": "word_length_histogram",
    "code_1": "def word_length_histogram(words):\n    \"\"\"\n    Takes a list of strings and returns a dictionary mapping word lengths to their frequency.\n    \"\"\"\n    hist = {}\n    for word in words:\n        length = len(word)\n        hist[length] = hist.get(length, 0) + 1\n    return hist",
    "code_2": "def word_length_histogram(words):\n    from collections import Counter\n    # Count the occurrences of each word length\n    length_counts = Counter(map(len, words))\n    # Convert Counter to a regular dict\n    return dict(length_counts)"
  },
  {
    "task": "Generate Pascal's Triangle",
    "input": "integer n (number of rows)",
    "output": "list of lists, each inner list is a row of Pascal's triangle",
    "function_name": "generate_pascals_triangle",
    "code_1": "def generate_pascals_triangle(n):\n    \"\"\"Generate the first n rows of Pascal's Triangle.\"\"\"\n    triangle = []\n    for i in range(n):\n        # Each row has i+1 elements\n        row = [1] * (i + 1)\n        # Compute internal values if i >= 2\n        for j in range(1, i):\n            row[j] = triangle[i-1][j-1] + triangle[i-1][j]\n        triangle.append(row)\n    return triangle",
    "code_2": "def generate_pascals_triangle(n):\n    \"\"\"Generate the first n rows of Pascal's Triangle using pairwise sums.\"\"\"\n    triangle = []\n    for _ in range(n):\n        if not triangle:\n            triangle.append([1])\n        else:\n            prev = triangle[-1]\n            # pad the previous row with zeros and sum pairwise\n            row = [a + b for a, b in zip([0] + prev, prev + [0])]\n            triangle.append(row)\n    return triangle\n"
  },
  {
    "task": "Extract Numbers From String",
    "input": "string containing digits and non-digit characters",
    "output": "list of integers extracted in order of appearance",
    "function_name": "extract_numbers_from_string",
    "code_1": "def extract_numbers_from_string(s):\n    import re\n    # Find all sequences of digits and convert them to integers\n    return [int(num) for num in re.findall(r'\\d+', s)]",
    "code_2": "def extract_numbers_from_string(s):\n    from itertools import groupby\n    # Group characters by whether they are digits, then join and convert\n    return [int(''.join(group)) for is_digit, group in groupby(s, key=str.isdigit) if is_digit]"
  },
  {
    "task": "Matrix Addition",
    "input": "two lists of lists of numbers (same dimensions)",
    "output": "list of lists representing element-wise sum",
    "function_name": "add_matrices",
    "code_1": "def add_matrices(matrix1, matrix2):\n    # Ensure both matrices have the same dimensions\n    if len(matrix1) != len(matrix2) or any(len(r1) != len(r2) for r1, r2 in zip(matrix1, matrix2)):\n        raise ValueError(\"Matrices must have the same dimensions\")\n    # Compute element-wise sum\n    return [[c1 + c2 for c1, c2 in zip(r1, r2)] for r1, r2 in zip(matrix1, matrix2)]",
    "code_2": "import operator\n\ndef add_matrices(matrix1, matrix2):\n    # Ensure both matrices have the same number of rows\n    if len(matrix1) != len(matrix2):\n        raise ValueError(\"Matrices must have the same dimensions\")\n    result = []\n    for row1, row2 in zip(matrix1, matrix2):\n        # Ensure each corresponding row has the same length\n        if len(row1) != len(row2):\n            raise ValueError(\"Matrices must have the same dimensions\")\n        # Use map with operator.add for element-wise addition\n        result.append(list(map(operator.add, row1, row2)))\n    return result"
  },
  {
    "task": "Integer to Roman Numeral",
    "input": "integer (1 to 3999)",
    "output": "string (Roman numeral representation)",
    "function_name": "int_to_roman",
    "code_1": "def int_to_roman(num):\n    roman_map = [\n        (1000, \"M\"),\n        (900, \"CM\"),\n        (500, \"D\"),\n        (400, \"CD\"),\n        (100, \"C\"),\n        (90, \"XC\"),\n        (50, \"L\"),\n        (40, \"XL\"),\n        (10, \"X\"),\n        (9, \"IX\"),\n        (5, \"V\"),\n        (4, \"IV\"),\n        (1, \"I\")\n    ]\n    result = []\n    for value, symbol in roman_map:\n        count = num // value\n        result.append(symbol * count)\n        num -= value * count\n    return \"\".join(result)",
    "code_2": "def int_to_roman(num):\n    thousands = [\"\", \"M\", \"MM\", \"MMM\"]\n    hundreds = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"]\n    tens     = [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"]\n    ones     = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"]\n    t = num // 1000\n    h = (num % 1000) // 100\n    te = (num % 100) // 10\n    o = num % 10\n    return thousands[t] + hundreds[h] + tens[te] + ones[o]"
  },
  {
    "task": "Validate Hexadecimal Color code_1",
    "input": "string (e.g. \"#1A3F9C\")",
    "output": "boolean (True if valid hex color code_1, else False)",
    "function_name": "is_valid_hex_color",
    "code_1": "def is_valid_hex_color(s):\n    import re\n    pattern = r'^#(?:[0-9A-Fa-f]{3}|[0-9A-Fa-f]{6})$'\n    return bool(re.match(pattern, s))",
    "code_2": "def is_valid_hex_color(s):\n    # Check type and basic format\n    if not isinstance(s, str) or not s.startswith('#'):\n        return False\n    length = len(s)\n    if length not in (4, 7):  # #RGB or #RRGGBB\n        return False\n    # Validate each character\n    hex_chars = set('0123456789abcdefABCDEF')\n    return all(ch in hex_chars for ch in s[1:])"
  },
  {
    "task": "Split List into Chunks",
    "input": "list of elements and integer chunk size",
    "output": "list of lists, where each sublist has up to chunk size elements",
    "function_name": "split_list_into_chunks",
    "code_1": "def split_list_into_chunks(lst, chunk_size):\n    \"\"\"Split a list into chunks of up to chunk_size elements.\"\"\"\n    if chunk_size <= 0:\n        raise ValueError('chunk_size must be greater than 0')\n    return [lst[i:i + chunk_size] for i in range(0, len(lst), chunk_size)]",
    "code_2": "def split_list_into_chunks(lst, chunk_size):\n    \"\"\"Split a list into chunks using itertools.islice.\"\"\"\n    if chunk_size <= 0:\n        raise ValueError('chunk_size must be greater than 0')\n    from itertools import islice\n    it = iter(lst)\n    chunks = []\n    while True:\n        chunk = list(islice(it, chunk_size))\n        if not chunk:\n            break\n        chunks.append(chunk)\n    return chunks"
  },
  {
    "task": "Identify Even Digits in Number",
    "input": "integer",
    "output": "list of integers (even digits found in the input, in order)",
    "function_name": "get_even_digits",
    "code_1": "def get_even_digits(n):\n    \"\"\"Return a list of even digits in the integer n, in order.\"\"\"\n    evens = []\n    for ch in str(abs(n)):\n        d = int(ch)\n        if d % 2 == 0:\n            evens.append(d)\n    return evens",
    "code_2": "def get_even_digits(n):\n    \"\"\"Return a list of even digits in the integer n, in order, using arithmetic operations.\"\"\"\n    n = abs(n)\n    if n == 0:\n        return [0]\n    evens = []\n    while n:\n        n, digit = divmod(n, 10)\n        if digit % 2 == 0:\n            evens.append(digit)\n    return evens[::-1]"
  },
  {
    "task": "Time to Seconds",
    "input": "three integers hours, minutes, seconds",
    "output": "integer total seconds",
    "function_name": "time_to_seconds",
    "code_1": "def time_to_seconds(hours, minutes, seconds):\n    return hours * 3600 + minutes * 60 + seconds",
    "code_2": "def time_to_seconds(hours, minutes, seconds):\n    from datetime import timedelta\n    return int(timedelta(hours=hours, minutes=minutes, seconds=seconds).total_seconds())"
  },
  {
    "task": "Generate Squares Dictionary",
    "input": "integer n",
    "output": "dict mapping each integer from 1 to n to its square",
    "function_name": "generate_squares_dict",
    "code_1": "def generate_squares_dict(n):\n    \"\"\"Return a dictionary mapping each integer from 1 to n to its square.\"\"\"\n    return {i: i * i for i in range(1, n + 1)}",
    "code_2": "def generate_squares_dict(n):\n    nums = range(1, n + 1)\n    return dict(zip(nums, map(lambda x: x * x, nums)))"
  },
  {
    "task": "Numeric String Check",
    "input": "string s",
    "output": "boolean True if s consists only of digits, False otherwise",
    "function_name": "is_numeric_string",
    "code_1": "def is_numeric_string(s):\n    \"\"\"Return True if s consists only of digits, False otherwise.\"\"\"\n    return s.isdigit()",
    "code_2": "def is_numeric_string(s):\n    \"\"\"Return True if s consists only of digits, False otherwise.\"\"\"\n    digits = set('0123456789')\n    # Ensure string is non-empty and every character is a digit\n    return bool(s) and all(ch in digits for ch in s)"
  },
  {
    "task": "Arithmetic Series Sum",
    "input": "three integers: first term a, common difference d, number of terms n",
    "output": "integer (sum of the arithmetic series)",
    "function_name": "arithmetic_series_sum",
    "code_1": "def arithmetic_series_sum(a, d, n):\n    '''Return sum of arithmetic series given first term a, common difference d, and number of terms n.'''\n    return n * (2*a + (n-1)*d) // 2",
    "code_2": "def arithmetic_series_sum(a, d, n):\n    total = 0\n    term = a\n    for _ in range(n):\n        total += term\n        term += d\n    return total"
  },
  {
    "task": "Subset Check",
    "input": "two lists lst1, lst2",
    "output": "boolean True if every element in lst1 is present in lst2, False otherwise",
    "function_name": "is_subset",
    "code_1": "def is_subset(lst1, lst2):\n    \"\"\"Return True if every element in lst1 is present in lst2, False otherwise.\"\"\"\n    return all(item in lst2 for item in lst1)",
    "code_2": "def is_subset(lst1, lst2):\n    \"\"\"Return True if every element in lst1 is present in lst2 using a two-pointer sort approach.\"\"\"\n    a = sorted(lst1)\n    b = sorted(lst2)\n    i = j = 0\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            i += 1\n            j += 1\n        elif a[i] > b[j]:\n            j += 1\n        else:\n            return False\n    return i == len(a)"
  },
  {
    "task": "Count Unique Words",
    "input": "string text",
    "output": "integer count of unique words in text separated by whitespace",
    "function_name": "count_unique_words",
    "code_1": "def count_unique_words(text):\n    \"\"\"\n    Count the number of unique words in a string, where words are separated by whitespace.\n    \"\"\"\n    words = text.split()\n    unique_words = set(words)\n    return len(unique_words)",
    "code_2": "def count_unique_words(text):\n    # Use dict.fromkeys to filter out duplicate words while preserving order\n    unique_words = dict.fromkeys(text.split())\n    return len(unique_words)"
  },
  {
    "task": "Decimal to Hexadecimal",
    "input": "integer n",
    "output": "string hexadecimal representation of n without prefix",
    "function_name": "decimal_to_hex",
    "code_1": "def decimal_to_hex(n):\n    \"\"\"Convert an integer to its hexadecimal representation without '0x' prefix.\"\"\"\n    if n < 0:\n        return '-' + format(-n, 'x')\n    return format(n, 'x')",
    "code_2": "def decimal_to_hex(n):\n    hex_digits = '0123456789abcdef'\n    if n == 0:\n        return '0'\n    sign = '-' if n < 0 else ''\n    num = abs(n)\n    digits = []\n    while num:\n        num, rem = divmod(num, 16)\n        digits.append(hex_digits[rem])\n    return sign + ''.join(reversed(digits))"
  },
  {
    "task": "Sum of Even Digits",
    "input": "integer n",
    "output": "integer sum of all even digits in n",
    "function_name": "sum_even_digits",
    "code_1": "def sum_even_digits(n):\n    \"\"\"Return the sum of all even digits in the integer n.\"\"\"\n    total = 0\n    for ch in str(abs(n)):\n        digit = int(ch)\n        if digit % 2 == 0:\n            total += digit\n    return total",
    "code_2": "def sum_even_digits(n):\n    '''Return the sum of all even digits in the integer n.'''\n    n = abs(n)\n    total = 0\n    while n > 0:\n        n, digit = divmod(n, 10)\n        if digit % 2 == 0:\n            total += digit\n    return total"
  },
  {
    "task": "Running Difference List",
    "input": "list of numbers nums",
    "output": "list of differences between each pair of consecutive elements in nums",
    "function_name": "running_differences",
    "code_1": "def running_differences(nums):\n    \"\"\"Return a list of differences between consecutive elements in nums.\"\"\"\n    if len(nums) < 2:\n        return []\n    return [nums[i+1] - nums[i] for i in range(len(nums) - 1)]",
    "code_2": "def running_differences(nums):\n    \"\"\"Return a list of differences between consecutive elements in nums.\"\"\"\n    # Pair up each element with its successor and compute their difference\n    return [b - a for a, b in zip(nums, nums[1:])]\n"
  },
  {
    "task": "Sum of Matrix Elements",
    "input": "a 2D list of numbers",
    "output": "the sum of all elements in the matrix",
    "function_name": "sum_matrix_elements",
    "code_1": "def sum_matrix_elements(matrix):\n    \"\"\"\n    Calculate the sum of all elements in a 2D list (matrix).\n\n    Args:\n        matrix (list of list of numbers): The input 2D list.\n\n    Returns:\n        number: The sum of all elements in the matrix.\n    \"\"\"\n    return sum(sum(row) for row in matrix)",
    "code_2": "def sum_matrix_elements(matrix):\n    \"\"\"\n    Calculate the sum of all elements in a 2D list (matrix) using itertools to flatten.\n\n    Args:\n        matrix (list of list of numbers): The input 2D list.\n\n    Returns:\n        number: The sum of all elements in the matrix.\n    \"\"\"\n    from itertools import chain\n    return sum(chain.from_iterable(matrix))"
  },
  {
    "task": "Frequency of Word Lengths",
    "input": "a string containing a sentence",
    "output": "a dictionary mapping each word length (int) to its occurrence count",
    "function_name": "word_length_frequency",
    "code_1": "def word_length_frequency(sentence):\n    counts = {}\n    for word in sentence.split():\n        length = len(word)\n        counts[length] = counts.get(length, 0) + 1\n    return counts",
    "code_2": "def word_length_frequency(sentence):\n    from collections import Counter\n    # Count lengths of each word using Counter for concise aggregation\n    length_counts = Counter(map(len, sentence.split()))\n    return dict(length_counts)"
  },
  {
    "task": "Missing Letter Finder",
    "input": "a string of ascending letters with one missing",
    "output": "the missing letter as a character",
    "function_name": "find_missing_letter",
    "code_1": "def find_missing_letter(s):\n    \"\"\"\n    Given a string of ascending letters with one missing, return the missing letter.\n    Example: 'abcdf' -> 'e'\n    \"\"\"\n    for i in range(len(s) - 1):\n        if ord(s[i+1]) != ord(s[i]) + 1:\n            return chr(ord(s[i]) + 1)\n    return None",
    "code_2": "def find_missing_letter(s):\n    # Build the full range of character codes and compare to the input\n    full_range = set(range(ord(s[0]), ord(s[-1]) + 1))\n    present = {ord(ch) for ch in s}\n    missing = full_range - present\n    return chr(missing.pop()) if missing else None"
  },
  {
    "task": "Triangle Validity Check",
    "input": "three positive numbers representing side lengths",
    "output": "True if they can form any triangle, False otherwise",
    "function_name": "is_valid_triangle",
    "code_1": "def is_valid_triangle(a, b, c):\n    \"\"\"\n    Check if three positive numbers can form a triangle.\n    Returns True if they satisfy the triangle inequality, False otherwise.\n    \"\"\"\n    return a + b > c and a + c > b and b + c > a",
    "code_2": "def is_valid_triangle(a, b, c):\n    # Sort sides so the largest is last\n    sides = sorted((a, b, c))\n    # A valid triangle requires sum of two smaller sides > largest side\n    return sides[0] + sides[1] > sides[2]"
  },
  {
    "task": "Sort Tuples by Second Element",
    "input": "a list of 2-tuples",
    "output": "the list sorted in ascending order by each tuple\u2019s second element",
    "function_name": "sort_by_second",
    "code_1": "def sort_by_second(lst):\n    \"\"\"\n    Return a new list of 2-tuples sorted in ascending order by each tuple\u2019s second element.\n    :param lst: List of 2-tuples\n    :return: Sorted list of 2-tuples\n    \"\"\"\n    return sorted(lst, key=lambda x: x[1])",
    "code_2": "def sort_by_second(lst):\n    \"\"\"Return a new list of 2-tuples sorted in ascending order by each tuple\u2019s second element using merge sort.\"\"\"\n    def merge(left, right):\n        merged = []\n        i = j = 0\n        while i < len(left) and j < len(right):\n            if left[i][1] <= right[j][1]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                j += 1\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged\n\n    if len(lst) <= 1:\n        return lst[:]\n    mid = len(lst) // 2\n    left_sorted = sort_by_second(lst[:mid])\n    right_sorted = sort_by_second(lst[mid:])\n    return merge(left_sorted, right_sorted)"
  },
  {
    "task": "Perfect Cube Check",
    "input": "integer n",
    "output": "boolean True if n is a perfect cube, False otherwise",
    "function_name": "is_perfect_cube",
    "code_1": "def is_perfect_cube(n):\n    if n >= 0:\n        c = int(round(n ** (1.0/3)))\n    else:\n        c = -int(round((-n) ** (1.0/3)))\n    return c ** 3 == n",
    "code_2": "def is_perfect_cube(n):\n    # Use binary search on absolute value to find integer cube root\n    m = abs(n)\n    lo, hi = 0, m\n    while lo <= hi:\n        mid = (lo + hi) // 2\n        cube = mid * mid * mid\n        if cube == m:\n            # If original n was negative, the root is -mid, but cube match holds\n            return True\n        if cube < m:\n            lo = mid + 1\n        else:\n            hi = mid - 1\n    return False"
  },
  {
    "task": "Count Sublist Occurrences",
    "input": "a list and a sublist",
    "output": "the number of times the sublist appears consecutively in the list",
    "function_name": "count_sublist_occurrences",
    "code_1": "def count_sublist_occurrences(lst, sublist):\n    count = 0\n    n = len(sublist)\n    if n == 0:\n        return 0\n    for i in range(len(lst) - n + 1):\n        if lst[i:i+n] == sublist:\n            count += 1\n    return count",
    "code_2": "def count_sublist_occurrences(lst, sublist):\n    n = len(sublist)\n    if n == 0:\n        return 0\n    subtuple = tuple(sublist)\n    windows = zip(*(lst[i:] for i in range(n)))\n    return sum(1 for window in windows if window == subtuple)"
  },
  {
    "task": "Partition Evens and Odds",
    "input": "a list of integers",
    "output": "two lists: first with even numbers, second with odd numbers",
    "function_name": "partition_evens_and_odds",
    "code_1": "def partition_evens_and_odds(nums):\n    \"\"\"\n    Partition a list of integers into evens and odds.\n\n    Args:\n        nums (list of int): The input list of integers.\n\n    Returns:\n        tuple: Two lists, first containing even numbers, second containing odd numbers.\n    \"\"\"\n    evens = []\n    odds = []\n    for num in nums:\n        if num % 2 == 0:\n            evens.append(num)\n        else:\n            odds.append(num)\n    return evens, odds",
    "code_2": "def partition_evens_and_odds(nums):\n    evens = [n for n in nums if n % 2 == 0]\n    odds = [n for n in nums if n % 2 != 0]\n    return evens, odds"
  },
  {
    "task": "Run-Length Decoding",
    "input": "a run-length encode_1d string (e.g., \u201c2a3b\u201d)",
    "output": "the decode_1d string (e.g., \u201caabbb\u201d)",
    "function_name": "decode_1_run_length",
    "code_1": "def decode_1_run_length(s):\n    result = []\n    count = ''\n    for char in s:\n        if char.isdigit():\n            count += char\n        else:\n            num = int(count) if count else 1\n            result.append(char * num)\n            count = ''\n    return ''.join(result)",
    "code_2": "import re\n\ndef decode_1_run_length(s):\n    # use regex to find optional digits followed by a character\n    return ''.join(char * int(cnt or 1) for cnt, char in re.findall(r'(\\d*)(\\D)', s))"
  },
  {
    "task": "Convert Decimal to Base N",
    "input": "an integer and a base (2\u201336)",
    "output": "the string representation of the integer in the given base",
    "function_name": "decimal_to_base",
    "code_1": "def decimal_to_base(num, base):\n    if base < 2 or base > 36:\n        raise ValueError('Base must be between 2 and 36')\n    if num == 0:\n        return '0'\n    digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    neg = num < 0\n    num = abs(num)\n    result = ''\n    while num:\n        result = digits[num % base] + result\n        num //= base\n    if neg:\n        result = '-' + result\n    return result",
    "code_2": "def decimal_to_base(num, base):\n    if not (2 <= base <= 36):\n        raise ValueError('Base must be between 2 and 36')\n    if num == 0:\n        return '0'\n    digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    sign = '-' if num < 0 else ''\n    num = abs(num)\n    def recurse(n):\n        q, r = divmod(n, base)\n        return recurse(q) + digits[r] if q else digits[r]\n    return sign + recurse(num)"
  },
  {
    "task": "Polynomial Evaluation",
    "input": "List of coefficients (list of numbers) and a value x (number)",
    "output": "The result of the polynomial at x",
    "function_name": "evaluate_polynomial",
    "code_1": "def evaluate_polynomial(coefficients, x):\n    \"\"\"\n    Evaluate a polynomial at a given value x using Horner's method.\n    coefficients: list of numbers [a0, a1, ..., an] representing a0 + a1*x + ... + an*x^n\n    x: number at which to evaluate the polynomial\n    Returns the computed polynomial value.\n    \"\"\"\n    result = 0\n    for coeff in reversed(coefficients):\n        result = result * x + coeff\n    return result",
    "code_2": "def evaluate_polynomial(coefficients, x):\n    \"\"\"\n    Evaluate a polynomial at a given value x by summing coefficient* x**power terms.\n    coefficients: list of numbers [a0, a1, ..., an] representing a0 + a1*x + ... + an*x^n\n    x: number at which to evaluate the polynomial\n    Returns the computed polynomial value.\n    \"\"\"\n    total = 0\n    for power, coeff in enumerate(coefficients):\n        total += coeff * (x ** power)\n    return total"
  },
  {
    "task": "First N Primes",
    "input": "integer n",
    "output": "list of the first n prime numbers",
    "function_name": "first_n_primes",
    "code_1": "def first_n_primes(n):\n    if n <= 0:\n        return []\n    primes = []\n    candidate = 2\n    while len(primes) < n:\n        is_prime = True\n        for p in primes:\n            if p * p > candidate:\n                break\n            if candidate % p == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(candidate)\n        candidate += 1\n    return primes",
    "code_2": "def first_n_primes(n):\n    import math\n    if n <= 0:\n        return []\n    # Estimate an upper bound for the nth prime (valid for n >= 6)\n    if n < 6:\n        bound = 15\n    else:\n        bound = int(n * (math.log(n) + math.log(math.log(n)))) + 3\n    # Sieve of Eratosthenes up to the bound\n    sieve = [True] * (bound + 1)\n    sieve[0] = sieve[1] = False\n    for p in range(2, int(bound**0.5) + 1):\n        if sieve[p]:\n            sieve[p*p : bound+1 : p] = [False] * (((bound - p*p)//p) + 1)\n    primes = [i for i, is_prime in enumerate(sieve) if is_prime]\n    return primes[:n]"
  },
  {
    "task": "Currency Converter",
    "input": "Amount (float) and conversion rate (float)",
    "output": "Converted amount (float)",
    "function_name": "convert_currency",
    "code_1": "def convert_currency(amount, rate):\n    \"\"\"Convert the given amount using the specified conversion rate.\"\"\"\n    try:\n        return float(amount) * float(rate)\n    except (TypeError, ValueError):\n        raise ValueError(\"Both amount and rate must be numbers.\")\n",
    "code_2": "from decimal import Decimal, InvalidOperation\n\ndef convert_currency(amount, rate):\n    \"\"\"Convert the given amount using Decimal for improved precision.\"\"\"\n    try:\n        a = Decimal(str(amount))\n        r = Decimal(str(rate))\n    except (InvalidOperation, TypeError):\n        raise ValueError(\"Both amount and rate must be numbers.\")\n    return float(a * r)"
  },
  {
    "task": "Next Prime Finder",
    "input": "Integer n",
    "output": "The smallest prime number greater than n",
    "function_name": "next_prime",
    "code_1": "def next_prime(n):\n    def is_prime(x):\n        if x < 2:\n            return False\n        if x == 2:\n            return True\n        if x % 2 == 0:\n            return False\n        i = 3\n        while i * i <= x:\n            if x % i == 0:\n                return False\n            i += 2\n        return True\n    candidate = n + 1\n    while True:\n        if is_prime(candidate):\n            return candidate\n        candidate += 1",
    "code_2": "import itertools, math\n\ndef next_prime(n):\n    return next(\n        cand for cand in itertools.count(n + 1)\n        if cand > 1 and all(cand % d for d in range(2, int(math.sqrt(cand)) + 1))\n    )"
  },
  {
    "task": "Validate ISBN-10",
    "input": "A string representing an ISBN-10 code_1 (digits and optional hyphens)",
    "output": "Boolean indicating whether it is a valid ISBN-10",
    "function_name": "is_valid_isbn10",
    "code_1": "def is_valid_isbn10(isbn):\n    # Remove hyphens\n    s = isbn.replace('-', '')\n    # Must be 10 characters\n    if len(s) != 10:\n        return False\n    total = 0\n    for i, char in enumerate(s):\n        # Last character can be 'X' representing 10\n        if i == 9 and char.upper() == 'X':\n            val = 10\n        elif char.isdigit():\n            val = int(char)\n        else:\n            return False\n        weight = 10 - i\n        total += val * weight\n    # Valid if weighted sum is divisible by 11\n    return total % 11 == 0",
    "code_2": "import re\n\ndef is_valid_isbn10(isbn):\n    s = isbn.replace('-', '')\n    # Must match 9 digits followed by digit or X\n    if not re.fullmatch(r'\\d{9}[\\dXx]', s):\n        return False\n    # Compute weighted sum using weights 10 to 1\n    total = sum((10 if ch.upper() == 'X' else int(ch)) * w\n                for ch, w in zip(s, range(10, 0, -1)))\n    return total % 11 == 0"
  },
  {
    "task": "BMI Calculator",
    "input": "Weight in kilograms (float) and height in meters (float)",
    "output": "Body Mass Index value (float) and category (\u201cUnderweight\u201d, \u201cNormal\u201d, \u201cOverweight\u201d, \u201cObese\u201d)",
    "function_name": "calculate_bmi",
    "code_1": "def calculate_bmi(weight, height):\n    bmi = weight / (height ** 2)\n    if bmi < 18.5:\n        category = 'Underweight'\n    elif bmi < 25:\n        category = 'Normal'\n    elif bmi < 30:\n        category = 'Overweight'\n    else:\n        category = 'Obese'\n    return bmi, category",
    "code_2": "import bisect\n\ndef calculate_bmi(weight, height):\n    # Compute BMI value\n    bmi = weight / (height * height)\n    # Define cutoff thresholds and corresponding labels\n    thresholds = [18.5, 25, 30]\n    categories = ['Underweight', 'Normal', 'Overweight', 'Obese']\n    # Determine index via bisect_right to match the correct category\n    idx = bisect.bisect_right(thresholds, bmi)\n    return bmi, categories[idx]"
  },
  {
    "task": "Zodiac Sign Finder",
    "input": "Two integers representing day and month",
    "output": "The corresponding zodiac sign as a string",
    "function_name": "find_zodiac_sign",
    "code_1": "def find_zodiac_sign(day, month):\n    # Returns the zodiac sign for given day and month\n    if (month == 1 and day <= 19) or (month == 12 and day >= 22):\n        return \"Capricorn\"\n    elif (month == 1 and day >= 20) or (month == 2 and day <= 18):\n        return \"Aquarius\"\n    elif (month == 2 and day >= 19) or (month == 3 and day <= 20):\n        return \"Pisces\"\n    elif (month == 3 and day >= 21) or (month == 4 and day <= 19):\n        return \"Aries\"\n    elif (month == 4 and day >= 20) or (month == 5 and day <= 20):\n        return \"Taurus\"\n    elif (month == 5 and day >= 21) or (month == 6 and day <= 20):\n        return \"Gemini\"\n    elif (month == 6 and day >= 21) or (month == 7 and day <= 22):\n        return \"Cancer\"\n    elif (month == 7 and day >= 23) or (month == 8 and day <= 22):\n        return \"Leo\"\n    elif (month == 8 and day >= 23) or (month == 9 and day <= 22):\n        return \"Virgo\"\n    elif (month == 9 and day >= 23) or (month == 10 and day <= 22):\n        return \"Libra\"\n    elif (month == 10 and day >= 23) or (month == 11 and day <= 21):\n        return \"Scorpio\"\n    elif (month == 11 and day >= 22) or (month == 12 and day <= 21):\n        return \"Sagittarius\"",
    "code_2": "def find_zodiac_sign(day, month):\n    # Calculate the day of the year (non-leap year)\n    month_days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    day_of_year = sum(month_days[:month-1]) + day\n\n    # Thresholds for zodiac sign starts (day of year)\n    thresholds = [\n        (20, \"Aquarius\"),    # Jan 20\n        (50, \"Pisces\"),      # Feb 19\n        (80, \"Aries\"),       # Mar 21\n        (110, \"Taurus\"),     # Apr 20\n        (141, \"Gemini\"),     # May 21\n        (172, \"Cancer\"),     # Jun 21\n        (204, \"Leo\"),        # Jul 23\n        (235, \"Virgo\"),      # Aug 23\n        (266, \"Libra\"),      # Sep 23\n        (296, \"Scorpio\"),    # Oct 23\n        (326, \"Sagittarius\"),# Nov 22\n        (356, \"Capricorn\")   # Dec 22\n    ]\n\n    # Default before Jan 20 is Capricorn\n    prev_sign = \"Capricorn\"\n    for threshold, sign in thresholds:\n        if day_of_year < threshold:\n            return prev_sign\n        prev_sign = sign\n    # If past Dec 22, it's Capricorn\n    return prev_sign"
  },
  {
    "task": "Dice Roll Simulator",
    "input": "Number of dice (integer) and number of faces per die (integer)",
    "output": "List of integers representing the outcome of each die roll",
    "function_name": "roll_dice",
    "code_1": "def roll_dice(num_dice, num_faces):\n    if num_dice < 1 or num_faces < 1:\n        raise ValueError('Number of dice and faces must be at least 1')\n    import random\n    return [random.randint(1, num_faces) for _ in range(num_dice)]",
    "code_2": "def roll_dice(num_dice, num_faces):\n    import random\n    if num_dice < 1 or num_faces < 1:\n        raise ValueError('Number of dice and faces must be at least 1')\n    # Use random.choices to draw k samples with replacement from 1..num_faces\n    return random.choices(range(1, num_faces + 1), k=num_dice)"
  },
  {
    "task": "Amicable Pair Check",
    "input": "two integers",
    "output": "boolean (True if the numbers form an amicable pair)",
    "function_name": "are_amicable",
    "code_1": "def are_amicable(a, b):\n    \"\"\"Return True if a and b form an amicable pair.\"\"\"\n    def sum_proper_divisors(n):\n        # 1 is a proper divisor of all n > 1\n        total = 1 if n > 1 else 0\n        # check divisors up to sqrt(n)\n        i = 2\n        while i * i <= n:\n            if n % i == 0:\n                total += i\n                other = n // i\n                if other != i:\n                    total += other\n            i += 1\n        return total\n    return a != b and sum_proper_divisors(a) == b and sum_proper_divisors(b) == a",
    "code_2": "def are_amicable(a, b):\n    def sum_proper_divisors(n):\n        # collect all divisors via set comprehension\n        divs = {d for i in range(1, int(n**0.5) + 1) if n % i == 0 for d in (i, n//i)}\n        return sum(divs) - n\n    return a != b and sum_proper_divisors(a) == b and sum_proper_divisors(b) == a"
  },
  {
    "task": "Histogram Generator",
    "input": "List of nonnegative integers",
    "output": "Multiline string where each line has a number of asterisks equal to the integer at that position",
    "function_name": "generate_histogram",
    "code_1": "def generate_histogram(values):\n    \"\"\"Generate a histogram string from a list of nonnegative integers.\"\"\"\n    return \"\\n\".join(\"*\" * n for n in values)",
    "code_2": "def generate_histogram(values):\n    result = []\n    for count in values:\n        line = ''\n        for _ in range(count):\n            line += '*'\n        result.append(line)\n    return '\\\\n'.join(result)"
  },
  {
    "task": "Neon Number Check",
    "input": "integer",
    "output": "boolean (True if sum of digits of its square equals the number)",
    "function_name": "is_neon_number",
    "code_1": "def is_neon_number(n):\n    \"\"\"Return True if the sum of the digits of n squared equals n.\"\"\"\n    square = n * n\n    digit_sum = sum(int(d) for d in str(square))\n    return digit_sum == n",
    "code_2": "def is_neon_number(n):\n    sq = n * n\n    total = 0\n    while sq > 0:\n        total += sq % 10\n        sq //= 10\n    return total == n"
  },
  {
    "task": "Collatz Sequence Length",
    "input": "positive integer",
    "output": "integer (number of steps to reach 1 following Collatz rules)",
    "function_name": "collatz_steps",
    "code_1": "def collatz_steps(n):\n    \"\"\"Return the number of steps to reach 1 following the Collatz rules.\"\"\"\n    steps = 0\n    while n != 1:\n        if n % 2 == 0:\n            n //= 2\n        else:\n            n = 3 * n + 1\n        steps += 1\n    return steps",
    "code_2": "from functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef collatz_steps(n):\n    \"\"\"Return the number of steps to reach 1 following the Collatz rules.\"\"\"\n    if n == 1:\n        return 0\n    # Recursively compute the next step with memoization\n    next_n = n // 2 if n % 2 == 0 else 3 * n + 1\n    return 1 + collatz_steps(next_n)"
  },
  {
    "task": "Swap Nibbles",
    "input": "integer (0\u2013255)",
    "output": "integer (value after swapping its upper and lower 4-bit nibbles)",
    "function_name": "swap_nibbles",
    "code_1": "def swap_nibbles(n):\n    \"\"\"Swap the upper and lower 4-bit nibbles of an 8-bit integer (0\u2013255).\"\"\"\n    if not isinstance(n, int) or not 0 <= n <= 255:\n        raise ValueError(\"Input must be an integer between 0 and 255 inclusive\")\n    # Lower nibble: bits 0\u20133; Upper nibble: bits 4\u20137\n    lower = (n & 0x0F) << 4\n    upper = (n & 0xF0) >> 4\n    return lower | upper",
    "code_2": "def swap_nibbles(n):\n    \"\"\"Swap the upper and lower 4-bit nibbles of an 8-bit integer (0\u2013255).\"\"\"\n    if not isinstance(n, int) or not 0 <= n <= 255:\n        raise ValueError(\"Input must be an integer between 0 and 255 inclusive\")\n    # Represent as two-digit hex, swap the characters, then parse back\n    hex_str = format(n, '02x')\n    swapped = hex_str[1] + hex_str[0]\n    return int(swapped, 16)\n"
  },
  {
    "task": "Check Alphabetical Order",
    "input": "string",
    "output": "boolean (True if characters in the string are in non-decreasing alphabetical order)",
    "function_name": "check_alphabetical_order",
    "code_1": "def check_alphabetical_order(s):\n    \"\"\"Return True if characters in s are in non-decreasing alphabetical order.\"\"\"\n    for i in range(len(s) - 1):\n        if s[i] > s[i + 1]:\n            return False\n    return True",
    "code_2": "def check_alphabetical_order(s):\n    \"\"\"Return True if characters in s are in non-decreasing alphabetical order.\"\"\"\n    return s == ''.join(sorted(s))"
  },
  {
    "task": "Next Palindrome Number",
    "input": "Integer n",
    "output": "The smallest integer palindrome greater than n",
    "function_name": "next_palindrome",
    "code_1": "def next_palindrome(n):\n    s = str(n)\n    l = len(s)\n    half = l // 2\n    # Handle the case where all digits are '9'\n    if all(ch == '9' for ch in s):\n        return int('1' + '0' * (l - 1) + '1')\n    left = s[:half]\n    middle = s[half] if l % 2 else ''\n    # Form a palindrome by mirroring the left half\n    candidate = left + middle + left[::-1]\n    if int(candidate) > n:\n        return int(candidate)\n    # Need to increment the middle part (left+middle for odd, left for even)\n    prefix = left + middle if middle else left\n    prefix_list = list(prefix)\n    i = len(prefix_list) - 1\n    # Propagate carry\n    while i >= 0 and prefix_list[i] == '9':\n        prefix_list[i] = '0'\n        i -= 1\n    if i >= 0:\n        prefix_list[i] = str(int(prefix_list[i]) + 1)\n        new_prefix = ''.join(prefix_list)\n    else:\n        # e.g. \"99\" -> \"100\"\n        new_prefix = '1' + ''.join(prefix_list)\n    # Split new_prefix back into left and middle\n    if middle:\n        new_left = new_prefix[:-1]\n        new_middle = new_prefix[-1]\n    else:\n        new_left = new_prefix\n        new_middle = ''\n    # Form and return the new palindrome\n    return int(new_left + new_middle + new_left[::-1])",
    "code_2": "def next_palindrome(n):\n    from itertools import count\n    return next(i for i in count(n+1) if str(i) == str(i)[::-1])"
  },
  {
    "task": "Alternating Even-Odd Digits",
    "input": "positive integer",
    "output": "boolean (True if its digits alternate between even and odd)",
    "function_name": "is_alternating_even_odd",
    "code_1": "def is_alternating_even_odd(n):\n    # Return True if digits of n alternate between even and odd\n    prev = (n % 10) % 2\n    n //= 10\n    while n > 0:\n        curr = (n % 10) % 2\n        if curr == prev:\n            return False\n        prev = curr\n        n //= 10\n    return True",
    "code_2": "def is_alternating_even_odd(n):\n    # Convert number to list of digit parities (0 for even, 1 for odd)\n    parities = [int(d) % 2 for d in str(n)]\n    # Check that each adjacent pair differs\n    return all(a != b for a, b in zip(parities, parities[1:]))"
  },
  {
    "task": "Extract Substring Between Delimiters",
    "input": "string and two single-character delimiters (start and end)",
    "output": "string (content between the first occurrence of the delimiters)",
    "function_name": "extract_between_delimiters",
    "code_1": "def extract_between_delimiters(s, start_delim, end_delim):\n    \"\"\"\n    Extracts and returns the substring between the first occurrence of start_delim and end_delim in s.\n    If delimiters are not found or in wrong order, returns an empty string.\n    \"\"\"\n    try:\n        start_idx = s.index(start_delim) + 1\n        end_idx = s.index(end_delim, start_idx)\n        return s[start_idx:end_idx]\n    except ValueError:\n        return \"\"",
    "code_2": "def extract_between_delimiters(s, start_delim, end_delim):\n    \"\"\"\n    Extracts and returns the substring between the first occurrence of start_delim and end_delim in s.\n    If delimiters are not found or in wrong order, returns an empty string.\n    \"\"\"\n    # Split once at the start delimiter\n    parts = s.split(start_delim, 1)\n    if len(parts) < 2:\n        return \"\"\n    # Take the part after the first delimiter\n    after_start = parts[1]\n    # Split once at the end delimiter\n    end_parts = after_start.split(end_delim, 1)\n    # If end delimiter not found, return empty string\n    return end_parts[0] if len(end_parts) > 1 else \"\""
  },
  {
    "task": "Prefix Expression Evaluator",
    "input": "string (prefix expression with integers and operators +, -, *, / separated by spaces)",
    "output": "integer (result of evaluating the expression)",
    "function_name": "evaluate_prefix",
    "code_1": "def evaluate_prefix(expr):\n    tokens = expr.split()[::-1]\n    def helper():\n        token = tokens.pop()\n        if token in '+-*/':\n            left = helper()\n            right = helper()\n            if token == '+':\n                return left + right\n            if token == '-':\n                return left - right\n            if token == '*':\n                return left * right\n            if token == '/':\n                # integer division truncating toward zero\n                return int(left / right)\n        else:\n            return int(token)\n    return helper()",
    "code_2": "def evaluate_prefix(expr):\n    tokens = expr.split()\n    stack = []\n    for token in reversed(tokens):\n        if token in '+-*/':\n            a = stack.pop()\n            b = stack.pop()\n            if token == '+':\n                stack.append(a + b)\n            elif token == '-':\n                stack.append(a - b)\n            elif token == '*':\n                stack.append(a * b)\n            else:\n                stack.append(int(a / b))\n        else:\n            stack.append(int(token))\n    return stack[0]"
  },
  {
    "task": "Password Strength Checker",
    "input": "A password string",
    "output": "Strength level as a string: \u201cWeak\u201d, \u201cMedium\u201d, or \u201cStrong\u201d",
    "function_name": "check_password_strength",
    "code_1": "def check_password_strength(password):\n    import re\n    length = len(password)\n    lower = bool(re.search('[a-z]', password))\n    upper = bool(re.search('[A-Z]', password))\n    digit = bool(re.search('[0-9]', password))\n    special = bool(re.search('[!@#$%^&*(),.?\":{}|<>]', password))\n    categories = lower + upper + digit + special\n    if length < 6 or categories < 2:\n        return \"Weak\"\n    if length >= 8 and categories >= 3:\n        return \"Strong\"\n    return \"Medium\"",
    "code_2": "def check_password_strength(password):\n    import string\n    categories = set()\n    for ch in password:\n        if ch.islower():\n            categories.add('lower')\n        elif ch.isupper():\n            categories.add('upper')\n        elif ch.isdigit():\n            categories.add('digit')\n        elif ch in string.punctuation:\n            categories.add('special')\n    strength_types = len(categories)\n    length = len(password)\n    if length < 6 or strength_types < 2:\n        return \"Weak\"\n    if length >= 8 and strength_types >= 3:\n        return \"Strong\"\n    return \"Medium\""
  },
  {
    "task": "Longest Palindromic Substring",
    "input": "string",
    "output": "string (the longest substring that is a palindrome; return any one if multiple)",
    "function_name": "longest_palindromic_substring",
    "code_1": "def longest_palindromic_substring(s):\n    if not s:\n        return \"\"\n    def expand(left, right):\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return left + 1, right\n    start, end = 0, 0\n    for i in range(len(s)):\n        l1, r1 = expand(i, i)\n        l2, r2 = expand(i, i + 1)\n        if r1 - l1 > end - start:\n            start, end = l1, r1\n        if r2 - l2 > end - start:\n            start, end = l2, r2\n    return s[start:end]",
    "code_2": "def longest_palindromic_substring(s):\n    if not s:\n        return \"\"\n    # Manacher's algorithm: transform string to handle even palindromes\n    T = '^#' + '#'.join(s) + '#$'\n    n = len(T)\n    P = [0] * n\n    center = right = 0\n    for i in range(1, n - 1):\n        mirror = 2 * center - i\n        if i < right:\n            P[i] = min(right - i, P[mirror])\n        # Expand around i\n        while T[i + P[i] + 1] == T[i - P[i] - 1]:\n            P[i] += 1\n        # Update center and right boundary\n        if i + P[i] > right:\n            center, right = i, i + P[i]\n    # Find the longest palindrome\n    max_len, center_index = max((length, idx) for idx, length in enumerate(P))\n    # Determine start in original string\n    start = (center_index - max_len) // 2\n    return s[start:start + max_len]"
  },
  {
    "task": "Shortest Word with All Vowels",
    "input": "string (sentence of words separated by spaces)",
    "output": "string (the shortest word that contains all five vowels a, e, i, o, u; return an empty string if none)",
    "function_name": "find_shortest_word_with_all_vowels",
    "code_1": "def find_shortest_word_with_all_vowels(s):\n    vowels = set('aeiou')\n    words = s.split()\n    candidates = [w for w in words if vowels <= set(w.lower())]\n    return min(candidates, key=len) if candidates else ''",
    "code_2": "def find_shortest_word_with_all_vowels(s):\n    vowels = set('aeiou')\n    # sort words by length so shortest qualifying word is found first\n    for word in sorted(s.split(), key=len):\n        # check if all vowels are present in the lowercase form of the word\n        if vowels.issubset(word.lower()):\n            return word\n    return ''"
  },
  {
    "task": "Harshad Number Check",
    "input": "integer n",
    "output": "boolean (True if n is divisible by the sum of its digits)",
    "function_name": "is_harshad_number",
    "code_1": "def is_harshad_number(n):\n    # Calculate the sum of the digits of the absolute value of n\n    digit_sum = sum(int(d) for d in str(abs(n)))\n    # Avoid division by zero\n    if digit_sum == 0:\n        return False\n    # Return True if n is divisible by the sum of its digits\n    return n % digit_sum == 0",
    "code_2": "def is_harshad_number(n):\n    total = 0\n    m = abs(n)\n    # sum digits using divmod in a loop\n    while m:\n        m, digit = divmod(m, 10)\n        total += digit\n    # 0 sum means no valid division\n    if total == 0:\n        return False\n    # check divisibility\n    return n % total == 0"
  },
  {
    "task": "Angle Between Clock Hands",
    "input": "two integers (hour 1\u201312, minute 0\u201359)",
    "output": "float (smallest angle in degrees)",
    "function_name": "angle_between_clock_hands",
    "code_1": "def angle_between_clock_hands(hour, minute):\n    # Normalize hour to 0\u201311\n    hour = hour % 12\n    # Calculate the angles\n    hour_angle = hour * 30 + minute * 0.5\n    minute_angle = minute * 6\n    # Find the difference\n    angle = abs(hour_angle - minute_angle)\n    # Return the smaller angle of the two possible\n    if angle > 180:\n        angle = 360 - angle\n    return angle",
    "code_2": "def angle_between_clock_hands(hour, minute):\n    # reduce hour into 12-hour scale and compute circular fractions\n    h_mod = hour % 12\n    frac_h = (h_mod * 60 + minute) / 720.0   # fraction of full circle for hour hand\n    frac_m = minute / 60.0                   # fraction of full circle for minute hand\n    delta = abs(frac_h - frac_m)\n    # pick smaller of the two possible angles\n    return min(delta, 1 - delta) * 360"
  },
  {
    "task": "Sum of Divisors",
    "input": "integer n",
    "output": "integer (sum of all positive divisors of n)",
    "function_name": "sum_of_divisors",
    "code_1": "def sum_of_divisors(n):\n    \"\"\"Return the sum of all positive divisors of n.\"\"\"\n    if n <= 0:\n        return 0\n    total = 0\n    import math\n    limit = int(math.isqrt(n))\n    for i in range(1, limit + 1):\n        if n % i == 0:\n            total += i\n            j = n // i\n            if j != i:\n                total += j\n    return total",
    "code_2": "def sum_of_divisors(n):\n    '''Return the sum of all positive divisors of n using prime factorization.'''\n    if n <= 0:\n        return 0\n    result = 1\n    temp = n\n    # handle factor 2\n    count = 0\n    while temp % 2 == 0:\n        temp //= 2\n        count += 1\n    if count:\n        result *= (2**(count+1) - 1) // (2 - 1)\n    # handle odd factors\n    p = 3\n    while p * p <= temp:\n        count = 0\n        while temp % p == 0:\n            temp //= p\n            count += 1\n        if count:\n            result *= (p**(count+1) - 1) // (p - 1)\n        p += 2\n    # if remainder is a prime > 1\n    if temp > 1:\n        result *= (temp**2 - 1) // (temp - 1)\n    return result"
  },
  {
    "task": "Subsequence Check",
    "input": "two strings s and t",
    "output": "boolean (True if s is a subsequence of t)",
    "function_name": "is_subsequence",
    "code_1": "def is_subsequence(s, t):\n    \"\"\"\n    Return True if string s is a subsequence of string t, else False.\n    \"\"\"\n    i = 0\n    for c in t:\n        if i < len(s) and s[i] == c:\n            i += 1\n            if i == len(s):\n                return True\n    return i == len(s)",
    "code_2": "def is_subsequence(s, t):\n    \"\"\"\n    Return True if s is a subsequence of t using an iterator-based approach.\n    \"\"\"\n    it = iter(t)\n    return all(c in it for c in s)"
  },
  {
    "task": "Hexadecimal to Decimal",
    "input": "string (hexadecimal number)",
    "output": "integer (decimal equivalent)",
    "function_name": "hex_to_decimal",
    "code_1": "def hex_to_decimal(hex_str):\n    \"\"\"\n    Convert a hexadecimal string to its decimal (integer) equivalent.\n\n    Args:\n        hex_str (str): The hexadecimal number as a string (with or without '0x' prefix).\n\n    Returns:\n        int: The decimal equivalent of the given hexadecimal string.\n    \"\"\"\n    # Strip any leading/trailing whitespace and optional 0x/0X prefix\n    hex_str = hex_str.strip().lower()\n    if hex_str.startswith('0x'):\n        hex_str = hex_str[2:]\n    # Convert using built-in int with base 16\n    return int(hex_str, 16)",
    "code_2": "from functools import reduce\n\ndef hex_to_decimal(hex_str):\n    s = hex_str.strip()\n    # Remove optional 0x/0X prefix\n    if s[:2].lower() == '0x':\n        s = s[2:]\n    # Map a single hex digit to its decimal value\n    def char_value(c):\n        cl = c.lower()\n        if '0' <= c <= '9':\n            return ord(c) - ord('0')\n        if 'a' <= cl <= 'f':\n            return ord(cl) - ord('a') + 10\n        raise ValueError(f\"Invalid hexadecimal character: {c}\")\n    # Accumulate the decimal result using reduce\n    return reduce(lambda total, ch: total * 16 + char_value(ch), s, 0)"
  },
  {
    "task": "Generate Collatz Sequence",
    "input": "integer n",
    "output": "list of integers (Collatz sequence starting at n and ending at 1)",
    "function_name": "collatz_sequence",
    "code_1": "def collatz_sequence(n):\n    \"\"\"\n    Generate the Collatz sequence starting at n and ending at 1.\n    \"\"\"\n    seq = [n]\n    while n != 1:\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = 3 * n + 1\n        seq.append(n)\n    return seq",
    "code_2": "def collatz_sequence(n):\n    if n == 1:\n        return [1]\n    next_n = n//2 if n % 2 == 0 else 3*n + 1\n    return [n] + collatz_sequence(next_n)"
  },
  {
    "task": "Point in Circle Check",
    "input": "floats x, y (point), floats cx, cy, r (circle center and radius)",
    "output": "boolean (True if point (x, y) is inside or on the circle)",
    "function_name": "is_point_in_circle",
    "code_1": "def is_point_in_circle(x, y, cx, cy, r):\n    \"\"\"Return True if point (x, y) is inside or on the circle centered at (cx, cy) with radius r.\"\"\"\n    return (x - cx)**2 + (y - cy)**2 <= r**2",
    "code_2": "import math\n\ndef is_point_in_circle(x, y, cx, cy, r):\n    \"\"\"Return True if point (x, y) is inside or on the circle centered at (cx, cy) with radius r.\"\"\"\n    # Compute the Euclidean distance using math.hypot and compare to radius\n    return math.hypot(x - cx, y - cy) <= r"
  },
  {
    "task": "Word Lengths List",
    "input": "A string sentence",
    "output": "A list of integers representing the length of each word in the sentence",
    "function_name": "word_lengths",
    "code_1": "def word_lengths(sentence):\n    words = sentence.split()\n    return [len(word) for word in words]",
    "code_2": "import re\n\ndef word_lengths(sentence):\n    return [m.end() - m.start() for m in re.finditer(r'\\S+', sentence)]"
  },
  {
    "task": "Magic Square Check",
    "input": "list of lists of integers (3\u00d73 matrix)",
    "output": "boolean (True if the matrix is a magic square)",
    "function_name": "is_magic_square",
    "code_1": "def is_magic_square(matrix):\n    # Check for proper 3x3 dimensions\n    if len(matrix) != 3 or any(len(row) != 3 for row in matrix):\n        return False\n    # Calculate the magic sum from the first row\n    magic_sum = sum(matrix[0])\n    # Check all rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    # Check all columns\n    for col in range(3):\n        if sum(matrix[row][col] for row in range(3)) != magic_sum:\n            return False\n    # Check main diagonal\n    if sum(matrix[i][i] for i in range(3)) != magic_sum:\n        return False\n    # Check anti-diagonal\n    if sum(matrix[i][2 - i] for i in range(3)) != magic_sum:\n        return False\n    return True",
    "code_2": "def is_magic_square(matrix):\n    # Ensure it's a 3\u00d73 matrix\n    if len(matrix) != 3 or any(len(row) != 3 for row in matrix):\n        return False\n    # Gather all rows, columns, and diagonals\n    lines = []\n    lines.extend(matrix)\n    lines.extend(map(list, zip(*matrix)))\n    lines.append([matrix[i][i] for i in range(3)])\n    lines.append([matrix[i][2 - i] for i in range(3)])\n    # Compute sums and check uniformity\n    totals = list(map(sum, lines))\n    return all(total == totals[0] for total in totals)"
  },
  {
    "task": "Swap Elements at Indices",
    "input": "A list and two integers i and j",
    "output": "The list after swapping the elements at indices i and j",
    "function_name": "swap_elements",
    "code_1": "def swap_elements(lst, i, j):\n    # Swap the elements at indices i and j\n    lst[i], lst[j] = lst[j], lst[i]\n    return lst",
    "code_2": "def swap_elements(lst, i, j):\n    # Swap elements by removing and reinserting\n    if i < j:\n        first = lst.pop(i)\n        second = lst.pop(j - 1)\n        lst.insert(i, second)\n        lst.insert(j, first)\n    else:\n        first = lst.pop(i)\n        second = lst.pop(j)\n        lst.insert(j, first)\n        lst.insert(i, second)\n    return lst"
  },
  {
    "task": "Format Number With Commas",
    "input": "An integer",
    "output": "A string with commas inserted as thousands separators",
    "function_name": "format_number_with_commas",
    "code_1": "def format_number_with_commas(n):\n    return f\"{n:,}\"",
    "code_2": "def format_number_with_commas(n):\n    sign = '-' if n < 0 else ''\n    num = str(abs(n))\n    parts = []\n    while num:\n        parts.append(num[-3:])\n        num = num[:-3]\n    return sign + ','.join(reversed(parts))\n"
  },
  {
    "task": "First N Triangular Numbers",
    "input": "An integer n",
    "output": "A list of the first n triangular numbers",
    "function_name": "first_n_triangular_numbers",
    "code_1": "def first_n_triangular_numbers(n):\n    # Return a list of the first n triangular numbers\n    if n <= 0:\n        return []\n    return [i*(i+1)//2 for i in range(1, n+1)]",
    "code_2": "def first_n_triangular_numbers(n):\n    result = []\n    total = 0\n    for i in range(1, n+1):\n        total += i\n        result.append(total)\n    return result"
  },
  {
    "task": "Count Letters and Digits",
    "input": "A string",
    "output": "Two integers: the count of alphabetic letters and the count of numeric digits",
    "function_name": "count_letters_and_digits",
    "code_1": "def count_letters_and_digits(s):\n    \"\"\"\n    Count alphabetic letters and numeric digits in a string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        tuple: A tuple (letter_count, digit_count).\n    \"\"\"\n    letters = 0\n    digits = 0\n    for c in s:\n        if c.isalpha():\n            letters += 1\n        elif c.isdigit():\n            digits += 1\n    return letters, digits",
    "code_2": "def count_letters_and_digits(s):\n    # Use generator expressions to tally letters and digits\n    letter_count = sum(c.isalpha() for c in s)\n    digit_count = sum(c.isdigit() for c in s)\n    return letter_count, digit_count"
  },
  {
    "task": "Manhattan Distance",
    "input": "Two tuples of two numbers each representing (x1, y1) and (x2, y2)",
    "output": "The Manhattan distance between the two points",
    "function_name": "manhattan_distance",
    "code_1": "def manhattan_distance(point1, point2):\n    \"\"\"Calculate the Manhattan distance between two points (x1, y1) and (x2, y2).\"\"\"\n    x1, y1 = point1\n    x2, y2 = point2\n    return abs(x1 - x2) + abs(y1 - y2)",
    "code_2": "def manhattan_distance(point1, point2):\n    \"\"\"Calculate the Manhattan distance using a generator and zip.\"\"\"\n    return sum(abs(a - b) for a, b in zip(point1, point2))"
  },
  {
    "task": "Average Word Length",
    "input": "A string sentence",
    "output": "A float representing the average length of words in the sentence",
    "function_name": "average_word_length",
    "code_1": "def average_word_length(sentence):\n    \"\"\"Return the average length of words in a sentence.\"\"\"\n    import re\n    # Extract words consisting of alphanumeric characters and underscores\n    words = re.findall(r'\\b\\w+\\b', sentence)\n    if not words:\n        return 0.0\n    total_length = sum(len(word) for word in words)\n    return total_length / len(words)",
    "code_2": "def average_word_length(sentence):\n    # Replace non-word characters with spaces, then split\n    cleaned = ''.join(ch if (ch.isalnum() or ch == '_') else ' ' for ch in sentence)\n    words = cleaned.split()\n    if not words:\n        return 0.0\n    # Calculate average length\n    total_len = sum(len(w) for w in words)\n    return total_len / len(words)"
  },
  {
    "task": "Sum of Upper Triangular Matrix",
    "input": "A square matrix (list of lists of numbers)",
    "output": "The sum of elements in the upper triangular part, including the diagonal",
    "function_name": "sum_upper_triangular",
    "code_1": "def sum_upper_triangular(matrix):\n    \"\"\"Return the sum of elements in the upper triangular part of a square matrix, including the diagonal.\"\"\"\n    total = 0\n    n = len(matrix)\n    for i in range(n):\n        for j in range(i, n):\n            total += matrix[i][j]\n    return total",
    "code_2": "def sum_upper_triangular(matrix):\n    \"\"\"Return the sum of elements in the upper triangular part of a square matrix, including the diagonal.\"\"\"\n    # Sum each row's slice from the diagonal index onward\n    return sum(sum(row[i:]) for i, row in enumerate(matrix))"
  },
  {
    "task": "Random RGB Color Generator",
    "input": "integer n",
    "output": "list of strings (n random RGB color code_1s in \u201c#RRGGBB\u201d format)",
    "function_name": "generate_random_colors",
    "code_1": "import random\n\ndef generate_random_colors(n):\n    colors = []\n    for _ in range(n):\n        r = random.randint(0, 255)\n        g = random.randint(0, 255)\n        b = random.randint(0, 255)\n        colors.append('#%02X%02X%02X' % (r, g, b))\n    return colors",
    "code_2": "import secrets\n\ndef generate_random_colors(n):\n    \"\"\"Generate n random RGB color codes in #RRGGBB format using secure random bytes.\"\"\"\n    return ['#' + secrets.token_hex(3).upper() for _ in range(n)]"
  },
  {
    "task": "Convert List of Strings to Integers",
    "input": "A list of strings where each string represents an integer",
    "output": "A list of integers converted from the input strings",
    "function_name": "strings_to_ints",
    "code_1": "def strings_to_ints(str_list):\n    return [int(s) for s in str_list]",
    "code_2": "def strings_to_ints(str_list):\n    return list(map(int, str_list))"
  },
  {
    "task": "Sum of Squares",
    "input": "List of integers",
    "output": "Integer representing the sum of each integer squared",
    "function_name": "sum_of_squares",
    "code_1": "def sum_of_squares(numbers):\n    \"\"\"Return the sum of each integer in the list squared.\"\"\"\n    return sum(x * x for x in numbers)",
    "code_2": "from functools import reduce\n\ndef sum_of_squares(numbers):\n    \"\"\"Compute the sum of squares using reduce.\"\"\"\n    return reduce(lambda acc, x: acc + x * x, numbers, 0)"
  },
  {
    "task": "Scale List",
    "input": "List of numbers and a number factor",
    "output": "List where each element is multiplied by the factor",
    "function_name": "scale_list",
    "code_1": "def scale_list(numbers, factor):\n    \"\"\"Return a new list where each element in numbers is multiplied by factor.\"\"\"\n    return [num * factor for num in numbers]",
    "code_2": "import itertools\nimport operator\n\ndef scale_list(numbers, factor):\n    \"\"\"Return a new list where each element in numbers is multiplied by factor.\"\"\"\n    return list(map(operator.mul, numbers, itertools.repeat(factor)))"
  },
  {
    "task": "Remove Leading Zeros",
    "input": "A string representing a number with leading zeros",
    "output": "A string representing the number without any leading zeros",
    "function_name": "remove_leading_zeros",
    "code_1": "def remove_leading_zeros(num_str):\n    # Strip leading zeros\n    stripped = num_str.lstrip('0')\n    # If result is empty, it means the string was all zeros\n    return stripped if stripped else '0'",
    "code_2": "def remove_leading_zeros(num_str):\n    # find the first non-zero index\n    idx = next((i for i, c in enumerate(num_str) if c != '0'), len(num_str))\n    # slice from that index, defaulting to '0' if result is empty\n    return num_str[idx:] or '0'"
  },
  {
    "task": "Product of Non-Zero Digits",
    "input": "Integer",
    "output": "Integer equal to the product of its non-zero digits",
    "function_name": "product_of_non_zero_digits",
    "code_1": "def product_of_non_zero_digits(n):\n    \"\"\"Return the product of the non-zero digits of integer n.\"\"\"\n    product = 1\n    for digit in str(abs(n)):\n        if digit != '0':\n            product *= int(digit)\n    return product",
    "code_2": "def product_of_non_zero_digits(n):\n    from math import prod\n    return prod(int(d) for d in str(abs(n)) if d != '0')"
  },
  {
    "task": "Fahrenheit to Kelvin List",
    "input": "List of floats (temperatures in Fahrenheit)",
    "output": "List of floats (temperatures converted to Kelvin)",
    "function_name": "fahrenheit_to_kelvin_list",
    "code_1": "def fahrenheit_to_kelvin_list(f_temps):\n    \"\"\"\n    Convert a list of temperatures from Fahrenheit to Kelvin.\n\n    Args:\n        f_temps (list of float): Temperatures in Fahrenheit.\n\n    Returns:\n        list of float: Temperatures in Kelvin.\n    \"\"\"\n    return [(f - 32) * 5.0/9.0 + 273.15 for f in f_temps]",
    "code_2": "def fahrenheit_to_kelvin_list(f_temps):\n    \"\"\"\n    Convert a list of temperatures from Fahrenheit to Kelvin using map and a helper lambda.\n    \"\"\"\n    return list(map(lambda f: (f - 32) * 5.0/9.0 + 273.15, f_temps))"
  },
  {
    "task": "String to Morse code_1",
    "input": "string (letters and digits)",
    "output": "string (Morse code_1, letters separated by spaces)",
    "function_name": "string_to_morse",
    "code_1": "def string_to_morse(text):\n    '''Convert a string of letters and digits to Morse code_1.'''\n    morse_dict = {\n        'A': '.-',\n        'B': '-...',\n        'C': '-.-.',\n        'D': '-..',\n        'E': '.',\n        'F': '..-.',\n        'G': '--.',\n        'H': '....',\n        'I': '..',\n        'J': '.---',\n        'K': '-.-',\n        'L': '.-..',\n        'M': '--',\n        'N': '-.',\n        'O': '---',\n        'P': '.--.',\n        'Q': '--.-',\n        'R': '.-.',\n        'S': '...',\n        'T': '-',\n        'U': '..-',\n        'V': '...-',\n        'W': '.--',\n        'X': '-..-',\n        'Y': '-.--',\n        'Z': '--..',\n        '0': '-----',\n        '1': '.----',\n        '2': '..---',\n        '3': '...--',\n        '4': '....-',\n        '5': '.....',\n        '6': '-....',\n        '7': '--...',\n        '8': '---..',\n        '9': '----.'\n    }\n    return ' '.join(morse_dict[char.upper()] for char in text if char.upper() in morse_dict)",
    "code_2": "def string_to_morse(text):\n    '''Convert a string of letters and digits to Morse code_1 using zip mapping.'''\n    letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'\n    morse_codes = [\n        '.-', '-...', '-.-.', '-..', '.', '..-.', '--.', '....', '..',\n        '.---', '-.-', '.-..', '--', '-.', '---', '.--.', '--.-', '.-.',\n        '...', '-', '..-', '...-', '.--', '-..-', '-.--', '--..',\n        '-----', '.----', '..---', '...--', '....-', '.....', '-....',\n        '--...', '---..', '----.'\n    ]\n    mapping = dict(zip(letters, morse_codes))\n    # Map each valid character to its Morse code, ignoring others\n    return ' '.join(mapping[ch] for ch in text.upper() if ch in mapping)"
  },
  {
    "task": "Pronic Numbers",
    "input": "Integer n",
    "output": "List of the first n pronic numbers (numbers of the form k*(k+1))",
    "function_name": "get_pronic_numbers",
    "code_1": "def get_pronic_numbers(n):\n    \"\"\"\n    Return a list of the first n pronic numbers (k*(k+1)).\n    \"\"\"\n    return [k * (k + 1) for k in range(n)]",
    "code_2": "def get_pronic_numbers(n):\n    \"\"\"\n    Return a list of the first n pronic numbers (k*(k+1)) using an iterative difference method.\n    \"\"\"\n    result = []\n    value = 0\n    diff = 2\n    for _ in range(n):\n        result.append(value)\n        value += diff\n        diff += 2\n    return result\n"
  },
  {
    "task": "Identity Matrix Check",
    "input": "List of lists of numbers (square matrix)",
    "output": "Boolean indicating whether the matrix is an identity matrix",
    "function_name": "is_identity_matrix",
    "code_1": "def is_identity_matrix(matrix):\n    \"\"\"Return True if the given square matrix is an identity matrix.\"\"\"\n    n = len(matrix)\n    # Check for square matrix\n    for row in matrix:\n        if len(row) != n:\n            return False\n    # Check identity conditions\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                if matrix[i][j] != 1:\n                    return False\n            else:\n                if matrix[i][j] != 0:\n                    return False\n    return True",
    "code_2": "def is_identity_matrix(matrix):\n    \"\"\"Return True if the given square matrix is an identity matrix.\"\"\"\n    n = len(matrix)\n    # must be square\n    if any(len(row) != n for row in matrix):\n        return False\n    # check each element: 1 on diagonal, 0 elsewhere\n    return all(\n        val == (1 if i == j else 0)\n        for i, row in enumerate(matrix)\n        for j, val in enumerate(row)\n    )"
  },
  {
    "task": "Alphanumeric Check",
    "input": "String",
    "output": "Boolean indicating whether every character is alphanumeric",
    "function_name": "is_alphanumeric",
    "code_1": "def is_alphanumeric(s):\n    for char in s:\n        if not char.isalnum():\n            return False\n    return True",
    "code_2": "import re\n\ndef is_alphanumeric(s):\n    # Use a regular expression to ensure all characters are alphanumeric (including empty string)\n    return bool(re.fullmatch(r'[A-Za-z0-9]*', s))\n"
  },
  {
    "task": "ASCII Sum",
    "input": "String",
    "output": "Integer sum of the ASCII values of all characters in the string",
    "function_name": "ascii_sum",
    "code_1": "def ascii_sum(input_string):\n    return sum(ord(c) for c in input_string)",
    "code_2": "def ascii_sum(input_string):\n    from functools import reduce\n    return reduce(lambda total, char: total + ord(char), input_string, 0)"
  },
  {
    "task": "Distance Between Points",
    "input": "Two tuples of numbers (coordinates of two points)",
    "output": "Float representing the Euclidean distance between the points",
    "function_name": "calculate_distance",
    "code_1": "def calculate_distance(point1, point2):\n    \"\"\"\n    Calculate the Euclidean distance between two points given as tuples of coordinates.\n    \"\"\"\n    # Compute sum of squared differences for each coordinate pair\n    squared_diffs = [(p1 - p2) ** 2 for p1, p2 in zip(point1, point2)]\n    # Return the square root of the sum\n    return sum(squared_diffs) ** 0.5",
    "code_2": "import math\n\ndef calculate_distance(point1, point2):\n    \"\"\"Calculate Euclidean distance using math.hypot over coordinate differences.\"\"\"\n    diffs = (x - y for x, y in zip(point1, point2))\n    return math.hypot(*diffs)"
  },
  {
    "task": "Sum of Digits at Even Positions",
    "input": "integer number",
    "output": "integer sum of digits at even indices (0-based)",
    "function_name": "sum_even_position_digits",
    "code_1": "def sum_even_position_digits(n):\n    \"\"\"\n    Returns the sum of digits at even indices (0-based) of the integer n.\n    \"\"\"\n    s = str(abs(n))\n    total = 0\n    for i, ch in enumerate(s):\n        if i % 2 == 0:\n            total += int(ch)\n    return total",
    "code_2": "def sum_even_position_digits(n):\n    \"\"\"Returns the sum of digits at even indices (0-based) of the integer n using slicing.\"\"\"\n    # Convert to string, take every second character starting from index 0, convert to int and sum\n    return sum(map(int, str(abs(n))[::2]))"
  },
  {
    "task": "Split String into Chunks",
    "input": "string and integer chunk_size",
    "output": "list of substrings of length chunk_size (last may be shorter)",
    "function_name": "chunk_string",
    "code_1": "def chunk_string(s, chunk_size):\n    # Split the string s into chunks of length chunk_size\n    return [s[i:i+chunk_size] for i in range(0, len(s), chunk_size)]",
    "code_2": "def chunk_string(s, chunk_size):\n    from itertools import islice\n    it = iter(s)\n    chunks = []\n    while True:\n        part = ''.join(islice(it, chunk_size))\n        if not part:\n            break\n        chunks.append(part)\n    return chunks"
  },
  {
    "task": "Longest Even-Length Word",
    "input": "String (a sentence)",
    "output": "The longest word in the sentence that has an even number of characters",
    "function_name": "longest_even_length_word",
    "code_1": "def longest_even_length_word(sentence):\n    words = sentence.split()\n    longest = \"\"\n    for w in words:\n        clean_w = ''.join(c for c in w if c.isalpha())\n        if len(clean_w) % 2 == 0:\n            if len(clean_w) > len(longest):\n                longest = clean_w\n    return longest",
    "code_2": "import re\n\ndef longest_even_length_word(sentence):\n    # extract alphabetic tokens\n    tokens = re.findall(r'[A-Za-z]+', sentence)\n    # pick only even-length words\n    even_words = [tok for tok in tokens if len(tok) % 2 == 0]\n    # return the longest even-length word or empty string\n    return max(even_words, key=len, default=\"\")"
  },
  {
    "task": "Power of Two Check",
    "input": "integer n",
    "output": "boolean indicating whether n is a power of two",
    "function_name": "is_power_of_two",
    "code_1": "def is_power_of_two(n):\n    \"\"\"\n    Check if a given integer n is a power of two.\n    Returns True if n is a power of two, False otherwise.\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        return False\n    return (n & (n - 1)) == 0",
    "code_2": "def is_power_of_two(n):\n    \"\"\"\n    Check if a given integer n is a power of two by dividing out factors of 2.\n    Returns True if n is a power of two, False otherwise.\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        return False\n    while n > 1:\n        if n % 2 != 0:\n            return False\n        n //= 2\n    return True"
  },
  {
    "task": "Sum First and Last Digit",
    "input": "integer number",
    "output": "integer sum of its first and last digit",
    "function_name": "sum_first_last_digit",
    "code_1": "def sum_first_last_digit(n):\n    \"\"\"Return the sum of the first and last digit of the integer n.\"\"\"\n    n = abs(n)\n    # Get last digit\n    last = n % 10\n    # Get first digit\n    first = n\n    while first >= 10:\n        first //= 10\n    return first + last",
    "code_2": "def sum_first_last_digit(n):\n    \"\"\"Return the sum of the first and last digit of the integer n.\"\"\"\n    s = str(abs(n))\n    return int(s[0]) + int(s[-1])"
  },
  {
    "task": "Unique Words Sorted",
    "input": "string sentence",
    "output": "list of unique words sorted alphabetically",
    "function_name": "unique_words_sorted",
    "code_1": "def unique_words_sorted(sentence):\n    \"\"\"\n    Return a list of unique words from the input sentence, sorted alphabetically.\n    Words are separated by whitespace.\n    \"\"\"\n    # Split the sentence into words by whitespace\n    words = sentence.split()\n    # Use a set to get unique words\n    unique = set(words)\n    # Return the sorted list of unique words\n    return sorted(unique)",
    "code_2": "def unique_words_sorted(sentence):\n    from itertools import groupby\n    # Split into words, then sort for grouping\n    words = sentence.split()\n    words.sort()\n    # Group adjacent duplicates and extract the unique keys\n    return [word for word, _ in groupby(words)]"
  },
  {
    "task": "Seconds to H:M:S",
    "input": "integer total_seconds",
    "output": "tuple of three integers (hours, minutes, seconds)",
    "function_name": "seconds_to_hms",
    "code_1": "def seconds_to_hms(total_seconds):\n    \"\"\"Convert total seconds to hours, minutes, and seconds.\"\"\"\n    hours = total_seconds // 3600\n    minutes = (total_seconds % 3600) // 60\n    seconds = total_seconds % 60\n    return hours, minutes, seconds",
    "code_2": "def seconds_to_hms(total_seconds):\n    '''Convert total seconds to hours, minutes, and seconds.'''\n    hours, rem = divmod(total_seconds, 3600)\n    minutes, seconds = divmod(rem, 60)\n    return hours, minutes, seconds"
  },
  {
    "task": "Intersperse List",
    "input": "list elements and a separator element",
    "output": "new list with the separator inserted between original elements",
    "function_name": "intersperse_list",
    "code_1": "def intersperse_list(lst, sep):\n    result = []\n    for i, item in enumerate(lst):\n        if i:\n            result.append(sep)\n        result.append(item)\n    return result",
    "code_2": "def intersperse_list(lst, sep):\n    if not lst:\n        return []\n    # build a flat list of (item, sep) pairs and drop the last sep\n    interspersed = [elem for item in lst for elem in (item, sep)]\n    return interspersed[:-1]"
  },
  {
    "task": "Harmonic Mean",
    "input": "list of positive numbers",
    "output": "float harmonic mean of the numbers",
    "function_name": "harmonic_mean",
    "code_1": "def harmonic_mean(numbers):\n    \"\"\"Return the harmonic mean of a list of positive numbers.\"\"\"\n    if not numbers:\n        raise ValueError(\"The list of numbers is empty\")\n    inv_sum = 0.0\n    for x in numbers:\n        if x <= 0:\n            raise ValueError(\"All numbers must be positive\")\n        inv_sum += 1.0 / x\n    return len(numbers) / inv_sum",
    "code_2": "def harmonic_mean(numbers):\n    if not numbers:\n        raise ValueError(\"The list of numbers is empty\")\n    if any(x <= 0 for x in numbers):\n        raise ValueError(\"All numbers must be positive\")\n    return len(numbers) / sum(1/x for x in numbers)"
  },
  {
    "task": "Trapezoid Area Calculator",
    "input": "two floats representing the lengths of the parallel bases and a float for the height",
    "output": "float area of the trapezoid",
    "function_name": "calculate_trapezoid_area",
    "code_1": "def calculate_trapezoid_area(base1, base2, height):\n    \"\"\"Calculate the area of a trapezoid given two bases and height.\"\"\"\n    return ((base1 + base2) / 2) * height",
    "code_2": "from functools import reduce\nfrom operator import add, mul\n\ndef calculate_trapezoid_area(base1, base2, height):\n    '''Calculate trapezoid area with functional approach.'''\n    # sum the two bases, then multiply by half the height\n    return mul(height / 2, reduce(add, (base1, base2)))"
  },
  {
    "task": "Alphabet Position Sum",
    "input": "string text",
    "output": "integer sum of letter positions (A=1, B=2, \u2026; ignore non-letters)",
    "function_name": "sum_alphabet_positions",
    "code_1": "def sum_alphabet_positions(text):\n    total = 0\n    for char in text:\n        if char.isalpha():\n            total += ord(char.upper()) - ord('A') + 1\n    return total",
    "code_2": "import re\n\ndef sum_alphabet_positions(text):\n    # Find all letters, convert to uppercase, then sum their positions\n    letters = re.findall(r'[A-Za-z]', text)\n    return sum(ord(c.upper()) - ord('A') + 1 for c in letters)"
  },
  {
    "task": "Format Credit Card Number",
    "input": "string of digits",
    "output": "string with the digits grouped into blocks of four separated by spaces",
    "function_name": "format_credit_card_number",
    "code_1": "def format_credit_card_number(cc_number: str) -> str:\n    \"\"\"Format a credit card number string into groups of four digits separated by spaces.\"\"\"\n    # Split the string into chunks of 4 and join with spaces\n    return ' '.join(cc_number[i:i+4] for i in range(0, len(cc_number), 4))",
    "code_2": "def format_credit_card_number(cc_number: str) -> str:\n    \"\"\"Format a credit card number string into groups of four digits separated by spaces.\"\"\"\n    from textwrap import wrap\n    return ' '.join(wrap(cc_number, 4))\n"
  },
  {
    "task": "Derangement Check",
    "input": "two lists of equal length",
    "output": "boolean indicating no element is in the same position in both lists",
    "function_name": "is_derangement",
    "code_1": "def is_derangement(a, b):\n    \"\"\"Check if two lists a and b are a derangement of each other (no element in the same position).\"\"\"\n    if len(a) != len(b):\n        raise ValueError(\"Lists must have equal length\")\n    return all(x != y for x, y in zip(a, b))",
    "code_2": "def is_derangement(a, b):\n    \"\"\"Check if two lists a and b are a derangement of each other (no element in the same position).\"\"\"\n    if len(a) != len(b):\n        raise ValueError(\"Lists must have equal length\")\n    # scan positions and exit on the first match\n    for i in range(len(a)):\n        if a[i] == b[i]:\n            return False\n    return True"
  },
  {
    "task": "Text Statistics",
    "input": "multiline string",
    "output": "tuple of three integers: (number of lines, number of words, number of characters)",
    "function_name": "text_statistics",
    "code_1": "def text_statistics(text):\n    # Count the number of lines\n    lines = len(text.splitlines())\n    # Count the number of words\n    words = len(text.split())\n    # Count the number of characters\n    characters = len(text)\n    return (lines, words, characters)",
    "code_2": "def text_statistics(text):\n    import re\n    # Count characters by iterating\n    char_count = sum(1 for _ in text)\n    # Count lines by newline occurrences, adjust if no trailing newline\n    line_count = sum(1 for c in text if c == '\\n')\n    if text and not text.endswith('\\n'):\n        line_count += 1\n    # Count words using regex for non-whitespace sequences\n    word_count = len(re.findall(r'\\S+', text))\n    return (line_count, word_count, char_count)"
  },
  {
    "task": "String Permutations",
    "input": "string",
    "output": "list of all unique permutations of the string\u2019s characters",
    "function_name": "string_permutations",
    "code_1": "def string_permutations(s):\n    import itertools\n    # Generate all permutations and use a set to ensure uniqueness\n    perms = {\"\".join(p) for p in itertools.permutations(s)}\n    return list(perms)",
    "code_2": "def string_permutations(s):\n    results = []\n    def backtrack(prefix, remainder):\n        if not remainder:\n            results.append(prefix)\n            return\n        seen = set()\n        for i, ch in enumerate(remainder):\n            if ch in seen:\n                continue\n            seen.add(ch)\n            backtrack(prefix + ch, remainder[:i] + remainder[i+1:])\n    backtrack(\"\", s)\n    return results"
  },
  {
    "task": "Sliding Window Median",
    "input": "list of integers and an integer window size",
    "output": "list of floats representing the median of each sliding window",
    "function_name": "sliding_window_median",
    "code_1": "def sliding_window_median(nums, k):\n    import bisect\n    n = len(nums)\n    if k == 0 or n < k:\n        return []\n    window = sorted(nums[:k])\n    medians = []\n    for i in range(k, n + 1):\n        # compute median\n        if k % 2 == 1:\n            med = float(window[k // 2])\n        else:\n            med = (window[k // 2 - 1] + window[k // 2]) / 2.0\n        medians.append(med)\n        if i == n:\n            break\n        # slide the window\n        out_num = nums[i - k]\n        in_num = nums[i]\n        # remove the element going out\n        idx = bisect.bisect_left(window, out_num)\n        window.pop(idx)\n        # insert the new element\n        bisect.insort(window, in_num)\n    return medians",
    "code_2": "def sliding_window_median(nums, k):\n    import heapq\n    if k == 0 or len(nums) < k:\n        return []\n\n    # max-heap (store negatives) and min-heap\n    small, large = [], []\n    delayed = {}       # counts of elements to remove lazily\n    small_size = large_size = 0\n\n    def prune(heap):\n        # Remove top elements marked for deletion\n        while heap:\n            num = -heap[0] if heap is small else heap[0]\n            if delayed.get(num, 0):\n                delayed[num] -= 1\n                if delayed[num] == 0:\n                    del delayed[num]\n                heapq.heappop(heap)\n            else:\n                break\n\n    def balance():\n        nonlocal small_size, large_size\n        # Keep sizes balanced: small may have one extra\n        if small_size > large_size + 1:\n            val = -heapq.heappop(small)\n            small_size -= 1\n            heapq.heappush(large, val)\n            large_size += 1\n            prune(small)\n        elif small_size < large_size:\n            val = heapq.heappop(large)\n            large_size -= 1\n            heapq.heappush(small, -val)\n            small_size += 1\n            prune(large)\n\n    def add(num):\n        nonlocal small_size, large_size\n        if not small or num <= -small[0]:\n            heapq.heappush(small, -num)\n            small_size += 1\n        else:\n            heapq.heappush(large, num)\n            large_size += 1\n        balance()\n\n    def remove(num):\n        nonlocal small_size, large_size\n        delayed[num] = delayed.get(num, 0) + 1\n        # Adjust size counters\n        if small and num <= -small[0]:\n            small_size -= 1\n            if num == -small[0]:\n                prune(small)\n        else:\n            large_size -= 1\n            if large and num == large[0]:\n                prune(large)\n        balance()\n\n    # Initialize with first k elements\n    for i in range(k):\n        add(nums[i])\n\n    medians = []\n    # Helper to get current median\n    def get_med():\n        if small_size > large_size:\n            return float(-small[0])\n        return (-small[0] + large[0]) / 2.0\n\n    medians.append(get_med())\n\n    # Slide the window\n    for i in range(k, len(nums)):\n        add(nums[i])\n        remove(nums[i - k])\n        medians.append(get_med())\n\n    return medians"
  },
  {
    "task": "Rectangle Overlap Checker",
    "input": "two tuples each containing four integers (x1, y1, x2, y2) defining opposite corners of two rectangles",
    "output": "boolean indicating whether the rectangles overlap",
    "function_name": "rectangles_overlap",
    "code_1": "def rectangles_overlap(rect1, rect2):\n    \"\"\"\n    Check if two axis-aligned rectangles overlap. Each rectangle is defined by a tuple (x1, y1, x2, y2) of opposite corners.\n    Returns True if they overlap (positive area intersection), False otherwise.\n    \"\"\"\n    # Unpack coordinates\n    x11, y11, x12, y12 = rect1\n    x21, y21, x22, y22 = rect2\n\n    # Normalize to (left, right) and (bottom, top)\n    left1, right1 = min(x11, x12), max(x11, x12)\n    bottom1, top1 = min(y11, y12), max(y11, y12)\n    left2, right2 = min(x21, x22), max(x21, x22)\n    bottom2, top2 = min(y21, y22), max(y21, y22)\n\n    # Check for no overlap conditions\n    no_overlap = (\n        right1 <= left2 or  # rect1 is to the left of rect2\n        right2 <= left1 or  # rect2 is to the left of rect1\n        top1 <= bottom2 or  # rect1 is below rect2\n        top2 <= bottom1     # rect2 is below rect1\n    )\n\n    return not no_overlap",
    "code_2": "def rectangles_overlap(rect1, rect2):\n    # Extract and sort x and y coordinates for both rectangles\n    xs1 = sorted(rect1[0::2])  # [left1, right1]\n    ys1 = sorted(rect1[1::2])  # [bottom1, top1]\n    xs2 = sorted(rect2[0::2])  # [left2, right2]\n    ys2 = sorted(rect2[1::2])  # [bottom2, top2]\n    # Compute overlap along each axis\n    overlap_x = min(xs1[1], xs2[1]) > max(xs1[0], xs2[0])\n    overlap_y = min(ys1[1], ys2[1]) > max(ys1[0], ys2[0])\n    return overlap_x and overlap_y"
  },
  {
    "task": "Closest Pair Finder",
    "input": "list of integers",
    "output": "tuple of two integers from the list that have the smallest absolute difference",
    "function_name": "find_closest_pair",
    "code_1": "def find_closest_pair(nums):\n    if len(nums) < 2:\n        raise ValueError(\"At least two numbers are required\")\n    nums_sorted = sorted(nums)\n    min_diff = float('inf')\n    pair = (nums_sorted[0], nums_sorted[1])\n    for i in range(1, len(nums_sorted)):\n        diff = nums_sorted[i] - nums_sorted[i-1]\n        if diff < min_diff:\n            min_diff = diff\n            pair = (nums_sorted[i-1], nums_sorted[i])\n    return pair",
    "code_2": "def find_closest_pair(nums):\n    if len(nums) < 2:\n        raise ValueError(\"At least two numbers are required\")\n    import itertools\n\n    # Generate all unique pairs and pick the one with minimal absolute difference\n    best_pair = min(\n        itertools.combinations(nums, 2),\n        key=lambda pair: abs(pair[0] - pair[1])\n    )\n\n    # Return the pair in ascending order\n    return tuple(sorted(best_pair))"
  },
  {
    "task": "Sum of Proper Divisors",
    "input": "integer n (>0)",
    "output": "sum of all divisors of n excluding n itself",
    "function_name": "sum_proper_divisors",
    "code_1": "def sum_proper_divisors(n):\n    if n <= 1:\n        return 0\n    total = 1\n    limit = int(n**0.5)\n    for i in range(2, limit + 1):\n        if n % i == 0:\n            total += i\n            other = n // i\n            if other != i:\n                total += other\n    return total",
    "code_2": "def sum_proper_divisors(n):\n    # Uses the divisor-sum formula from prime factorization\n    if n <= 1:\n        return 0\n    original = n\n    factors = {}\n    # factor out 2s\n    while n % 2 == 0:\n        factors[2] = factors.get(2, 0) + 1\n        n //= 2\n    # factor odd primes\n    p = 3\n    while p * p <= n:\n        while n % p == 0:\n            factors[p] = factors.get(p, 0) + 1\n            n //= p\n        p += 2\n    if n > 1:\n        factors[n] = factors.get(n, 0) + 1\n    # compute sum of all divisors via product formula\n    total = 1\n    for p, exp in factors.items():\n        total *= (p**(exp+1) - 1) // (p - 1)\n    # subtract the number itself to get proper divisors\n    return total - original"
  },
  {
    "task": "Digit Frequency in Range",
    "input": "two integers defining a range [a, b]",
    "output": "dictionary mapping each digit (0\u20139) to its total count in all numbers from a to b inclusive",
    "function_name": "digit_frequency_in_range",
    "code_1": "def digit_frequency_in_range(a, b):\n    if a > b:\n        a, b = b, a\n    counts = {i: 0 for i in range(10)}\n    for num in range(a, b + 1):\n        for ch in str(abs(num)):\n            counts[int(ch)] += 1\n    return counts",
    "code_2": "def digit_frequency_in_range(a, b):\n    if a > b:\n        a, b = b, a\n    counts = {i: 0 for i in range(10)}\n    for num in range(a, b + 1):\n        n = abs(num)\n        if n == 0:\n            counts[0] += 1\n        while n > 0:\n            counts[n % 10] += 1\n            n //= 10\n    return counts"
  },
  {
    "task": "Normalize Spaces",
    "input": "string",
    "output": "string with all sequences of whitespace replaced by a single space and trimmed of leading/trailing spaces",
    "function_name": "normalize_spaces",
    "code_1": "def normalize_spaces(s):\n    return ' '.join(s.split())",
    "code_2": "import re\n\ndef normalize_spaces(s):\n    # Replace any sequence of whitespace with a single space, then trim\n    return re.sub(r'\\s+', ' ', s).strip()"
  },
  {
    "task": "Flatten Dictionary",
    "input": "nested dictionary with string keys and non-dictionary values",
    "output": "flat dictionary where nested keys are joined by dots to represent the path",
    "function_name": "flatten_dict",
    "code_1": "def flatten_dict(d):\n    result = {}\n    def _flatten(subdict, prefix=''):\n        for k, v in subdict.items():\n            new_key = prefix + '.' + k if prefix else k\n            if isinstance(v, dict):\n                _flatten(v, new_key)\n            else:\n                result[new_key] = v\n    _flatten(d)\n    return result",
    "code_2": "def flatten_dict(d):\n    flat = {}\n    stack = [(\"\", d)]\n    while stack:\n        prefix, current = stack.pop()\n        for key, val in current.items():\n            composed = key if not prefix else prefix + \".\" + key\n            if isinstance(val, dict):\n                stack.append((composed, val))\n            else:\n                flat[composed] = val\n    return flat"
  },
  {
    "task": "Power of Three Check",
    "input": "integer n",
    "output": "boolean indicating if n is a power of three",
    "function_name": "is_power_of_three",
    "code_1": "def is_power_of_three(n):\n    if n <= 0:\n        return False\n    while n % 3 == 0:\n        n //= 3\n    return n == 1",
    "code_2": "import math\n\ndef is_power_of_three(n):\n    if n <= 0:\n        return False\n    # Compute logarithm base 3 and check near-integer\n    exponent = math.log(n, 3)\n    return abs(exponent - round(exponent)) < 1e-10"
  },
  {
    "task": "Excel Column Title to Number",
    "input": "string of uppercase letters",
    "output": "corresponding column number as an integer",
    "function_name": "title_to_number",
    "code_1": "def title_to_number(s: str) -> int:\n    \"\"\"Convert Excel column title (e.g., 'AB') to its corresponding number (e.g., 28).\"\"\"\n    result = 0\n    for char in s:\n        result = result * 26 + (ord(char) - ord('A') + 1)\n    return result",
    "code_2": "def title_to_number(s: str) -> int:\n    # Treat the title as a base-26 number with 'A' = 1\n    return sum((ord(c) - ord('A') + 1) * (26 ** i) for i, c in enumerate(reversed(s)))"
  },
  {
    "task": "Monotonic List Check",
    "input": "list of numbers",
    "output": "boolean indicating if list is entirely non-increasing or non-decreasing",
    "function_name": "is_monotonic",
    "code_1": "def is_monotonic(nums):\n    # An empty list or single-element list is monotonic\n    if len(nums) < 2:\n        return True\n    increasing = True\n    decreasing = True\n    for i in range(1, len(nums)):\n        if nums[i] > nums[i - 1]:\n            decreasing = False\n        if nums[i] < nums[i - 1]:\n            increasing = False\n        # If it is neither non-decreasing nor non-increasing, it's not monotonic\n        if not increasing and not decreasing:\n            return False\n    return True",
    "code_2": "def is_monotonic(nums):\n    \"\"\"\n    Return True if the list is entirely non-decreasing or non-increasing.\n    \"\"\"\n    # Check non-decreasing and non-increasing via pairwise comparisons\n    if not nums:\n        return True\n    inc = all(x <= y for x, y in zip(nums, nums[1:]))\n    dec = all(x >= y for x, y in zip(nums, nums[1:]))\n    return inc or dec"
  },
  {
    "task": "All String Rotations",
    "input": "string s",
    "output": "list of all cyclic rotations of s",
    "function_name": "all_string_rotations",
    "code_1": "def all_string_rotations(s):\n    \"\"\"Return a list of all cyclic rotations of string s.\"\"\"\n    return [s[i:] + s[:i] for i in range(len(s))]",
    "code_2": "from collections import deque\n\ndef all_string_rotations(s):\n    dq = deque(s)\n    rotations = []\n    for _ in range(len(s)):\n        rotations.append(''.join(dq))\n        dq.rotate(-1)\n    return rotations"
  },
  {
    "task": "Simple Expression Evaluation",
    "input": "string containing non-negative integers with '+' and '-' operators",
    "output": "integer result after evaluating the expression left to right",
    "function_name": "eval_simple_expr",
    "code_1": "def eval_simple_expr(expr):\n    import re\n    # Split the expression into numbers and operators\n    tokens = re.split(r'([+-])', expr)\n    # Initialize the result with the first number\n    result = int(tokens[0])\n    # Process each operator and the following number\n    for i in range(1, len(tokens), 2):\n        op = tokens[i]\n        num = int(tokens[i+1])\n        if op == '+':\n            result += num\n        else:\n            result -= num\n    return result",
    "code_2": "def eval_simple_expr(expr):\n    # Convert operators into signed number prefixes and split\n    terms = expr.replace('+', ' +').replace('-', ' -').split()\n    # Sum all signed integers\n    return sum(int(term) for term in terms)"
  },
  {
    "task": "CamelCase Word Count",
    "input": "camelCase string",
    "output": "integer count of words in the string",
    "function_name": "count_camel_case",
    "code_1": "def count_camel_case(s):\n    \"\"\"\n    Count the number of words in a camelCase string.\n    Returns 0 for empty string.\n    \"\"\"\n    if not s:\n        return 0\n    count = 1\n    for c in s:\n        if c.isupper():\n            count += 1\n    return count",
    "code_2": "def count_camel_case(s):\n    import re\n    # Return 0 for empty input\n    if not s:\n        return 0\n    # Split the string at positions preceding uppercase letters\n    parts = re.split(r'(?=[A-Z])', s)\n    return len(parts)\n"
  },
  {
    "task": "Alternating Vowel Consonant",
    "input": "string of letters",
    "output": "boolean indicating if letters alternate between vowel and consonant",
    "function_name": "alternating_vowel_consonant",
    "code_1": "def alternating_vowel_consonant(s):\n    \"\"\"Return True if letters in s alternate between vowel and consonant.\"\"\"\n    vowels = set('aeiouAEIOU')\n    prev_is_vowel = None\n    for char in s:\n        if not char.isalpha():\n            continue\n        curr_is_vowel = char in vowels\n        if prev_is_vowel is None:\n            prev_is_vowel = curr_is_vowel\n        else:\n            if curr_is_vowel == prev_is_vowel:\n                return False\n            prev_is_vowel = curr_is_vowel\n    return True",
    "code_2": "def alternating_vowel_consonant(s):\n    import re\n    # extract only letters using regex\n    letters = re.findall(r'[A-Za-z]', s)\n    # map each letter to True if vowel, False if consonant\n    pattern = [ch.lower() in 'aeiou' for ch in letters]\n    # check that no two adjacent values are the same\n    return all(a != b for a, b in zip(pattern, pattern[1:]))"
  },
  {
    "task": "Repeated Substring Pattern Check",
    "input": "string s",
    "output": "boolean indicating if s can be formed by repeating a substring",
    "function_name": "is_repeated_substring",
    "code_1": "def is_repeated_substring(s):\n    return len(s) > 0 and s in (s + s)[1:-1]",
    "code_2": "def is_repeated_substring(s):\n    # Return False for empty string\n    if not s:\n        return False\n    n = len(s)\n    # Try every possible substring length up to half\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            # Build string by repeating the candidate substring\n            if s[:i] * (n // i) == s:\n                return True\n    return False"
  },
  {
    "task": "First Missing Positive",
    "input": "list of integers",
    "output": "smallest missing positive integer (\u22651)",
    "function_name": "first_missing_positive",
    "code_1": "def first_missing_positive(nums):\n    s = set(nums)\n    i = 1\n    while True:\n        if i not in s:\n            return i\n        i += 1",
    "code_2": "def first_missing_positive(nums):\n    # Sort only the positive integers\n    positives = sorted(x for x in nums if x > 0)\n    # Start looking for the smallest missing positive\n    missing = 1\n    for num in positives:\n        if num == missing:\n            missing += 1\n        # If we skip over missing, that's our answer\n        elif num > missing:\n            break\n    return missing"
  },
  {
    "task": "List Perfect Squares",
    "input": "an integer N",
    "output": "a list of all perfect squares less than or equal to N",
    "function_name": "list_perfect_squares",
    "code_1": "def list_perfect_squares(N):\n    \"\"\"\n    Return a list of all perfect squares less than or equal to N.\n    \"\"\"\n    squares = []\n    i = 1\n    while i * i <= N:\n        squares.append(i * i)\n        i += 1\n    return squares",
    "code_2": "def list_perfect_squares(N):\n    \"\"\"\n    Return a list of all perfect squares less than or equal to N.\n    \"\"\"\n    import math\n    # Use integer square root to bound the range\n    max_root = math.isqrt(N)\n    return [r*r for r in range(1, max_root + 1)]"
  },
  {
    "task": "Matrix Column Maxima",
    "input": "a list of lists of numbers representing a matrix",
    "output": "a list of the maximum value from each column",
    "function_name": "matrix_column_maxima",
    "code_1": "def matrix_column_maxima(matrix):\n    \"\"\"Return a list of the maximum value from each column of the input matrix.\"\"\"\n    if not matrix or not matrix[0]:\n        return []\n    # Transpose rows to columns and compute max for each column\n    return [max(col) for col in zip(*matrix)]",
    "code_2": "def matrix_column_maxima(matrix):\n    \"\"\"Return a list of the maximum value from each column of the input matrix.\"\"\"\n    # Handle empty matrix or rows\n    if not matrix or not matrix[0]:\n        return []\n    # Determine number of columns\n    num_cols = len(matrix[0])\n    maxima = []\n    # Iterate over each column index\n    for col in range(num_cols):\n        # Initialize with the first row's value\n        current_max = matrix[0][col]\n        # Compare with subsequent rows\n        for row in matrix[1:]:\n            value = row[col]\n            if value > current_max:\n                current_max = value\n        maxima.append(current_max)\n    return maxima"
  },
  {
    "task": "Categorize Numbers",
    "input": "a list of integers",
    "output": "a dictionary with keys \"positive\", \"negative\", \"zero\" and their respective counts",
    "function_name": "categorize_numbers",
    "code_1": "def categorize_numbers(numbers):\n    positive = 0\n    negative = 0\n    zero = 0\n    for num in numbers:\n        if num > 0:\n            positive += 1\n        elif num < 0:\n            negative += 1\n        else:\n            zero += 1\n    return {'positive': positive, 'negative': negative, 'zero': zero}",
    "code_2": "def categorize_numbers(numbers):\n    from collections import Counter\n    # Map each number to its category\n    def sign(n):\n        return 'positive' if n > 0 else ('negative' if n < 0 else 'zero')\n    counts = Counter(sign(n) for n in numbers)\n    # Ensure all keys are present\n    return {key: counts.get(key, 0) for key in ['positive', 'negative', 'zero']}"
  },
  {
    "task": "Reverse Each Word",
    "input": "a string containing multiple words separated by spaces",
    "output": "a string where each word is reversed but the word order remains the same",
    "function_name": "reverse_each_word",
    "code_1": "def reverse_each_word(s):\n    \"\"\"\n    Reverse each word in the input string while preserving the word order.\n    Words are assumed to be separated by whitespace.\n    \"\"\"\n    return ' '.join(word[::-1] for word in s.split())",
    "code_2": "def reverse_each_word(s):\n    \"\"\"\n    Reverse each word in the input string while preserving the original spacing.\n    Words are sequences of non-space characters.\n    \"\"\"\n    result = []\n    current = []\n    for ch in s:\n        if ch == ' ':\n            # End of a word: flush current in reverse\n            while current:\n                result.append(current.pop())\n            # Preserve the space\n            result.append(ch)\n        else:\n            current.append(ch)\n    # Flush the final word\n    while current:\n        result.append(current.pop())\n    return ''.join(result)"
  },
  {
    "task": "Pairs With Difference K",
    "input": "a list of integers and an integer K",
    "output": "a list of tuples of integer pairs whose absolute difference equals K",
    "function_name": "pairs_with_diff_k",
    "code_1": "def pairs_with_diff_k(nums, k):\n    k = abs(k)\n    if k == 0:\n        from collections import Counter\n        freq = Counter(nums)\n        return [(x, x) for x, count in freq.items() if count > 1]\n    seen = set(nums)\n    result = []\n    for x in seen:\n        if x + k in seen:\n            result.append((x, x+k))\n    return result",
    "code_2": "def pairs_with_diff_k(nums, k):\n    # Normalize k to non-negative\n    k = abs(k)\n    n = len(nums)\n    # Special case: k == 0, find duplicates\n    if k == 0:\n        # Sort and scan for consecutive equals\n        nums_sorted = sorted(nums)\n        result = []\n        seen = set()\n        for i in range(1, n):\n            if nums_sorted[i] == nums_sorted[i-1] and nums_sorted[i] not in seen:\n                result.append((nums_sorted[i], nums_sorted[i]))\n                seen.add(nums_sorted[i])\n        return result\n    # For k > 0, use two-pointer on sorted unique values\n    unique_vals = sorted(set(nums))\n    result = []\n    i, j = 0, 1\n    m = len(unique_vals)\n    while i < m and j < m:\n        if i == j:\n            j += 1\n            continue\n        diff = unique_vals[j] - unique_vals[i]\n        if diff == k:\n            result.append((unique_vals[i], unique_vals[j]))\n            i += 1\n            j += 1\n        elif diff < k:\n            j += 1\n        else:\n            i += 1\n    return result"
  },
  {
    "task": "Count Digits Per Number",
    "input": "a list of non-negative integers",
    "output": "a list of integers representing the digit count of each input number",
    "function_name": "count_digits_per_number",
    "code_1": "def count_digits_per_number(numbers):\n    \"\"\"\n    Given a list of non-negative integers, return a list containing the digit count of each integer.\n    \"\"\"\n    # Convert each number to string and count its characters\n    return [len(str(num)) for num in numbers]",
    "code_2": "def count_digits_per_number(numbers):\n    \"\"\"\n    Given a list of non-negative integers, return a list containing the digit count of each integer.\n    \"\"\"\n    counts = []\n    for num in numbers:\n        # Start with at least one digit\n        digit_count = 1\n        # Use integer division to count digits\n        while num >= 10:\n            num //= 10\n            digit_count += 1\n        counts.append(digit_count)\n    return counts"
  },
  {
    "task": "Armstrong Numbers In Range",
    "input": "two integers representing the start and end of a range (inclusive)",
    "output": "a list of all Armstrong numbers within that range",
    "function_name": "find_armstrong_numbers_in_range",
    "code_1": "def find_armstrong_numbers_in_range(start, end):\n    \"\"\"\n    Return a list of all Armstrong numbers between start and end (inclusive).\n    An Armstrong number is an integer such that the sum of its own digits\n    each raised to the power of the number of digits equals the number itself.\n    \"\"\"\n    result = []\n    for num in range(start, end + 1):\n        if num < 0:\n            continue\n        digits = str(num)\n        power = len(digits)\n        total = sum(int(d) ** power for d in digits)\n        if total == num:\n            result.append(num)\n    return result",
    "code_2": "def find_armstrong_numbers_in_range(start, end):\n    # Nested helper to check Armstrong property without string conversion\n    def is_armstrong(n):\n        if n < 0:\n            return False\n        # collect digits numerically\n        digits = []\n        temp = n\n        if temp == 0:\n            digits.append(0)\n        while temp > 0:\n            digits.append(temp % 10)\n            temp //= 10\n        power = len(digits)\n        # sum each digit^power and compare\n        return sum(d ** power for d in digits) == n\n\n    # build and return list using list comprehension and the helper\n    return [num for num in range(start, end + 1) if is_armstrong(num)]\n"
  },
  {
    "task": "Next Greater Element",
    "input": "a list of integers",
    "output": "a list where each element is replaced by the next greater element to its right in the list or -1 if none exists",
    "function_name": "next_greater_elements",
    "code_1": "def next_greater_elements(nums):\n    \"\"\"\n    Given a list of integers, returns a list where each element is replaced by\n    the next greater element to its right in the list or -1 if none exists.\n    \"\"\"\n    n = len(nums)\n    res = [-1] * n\n    stack = []  # will store indices of nums\n\n    for i, val in enumerate(nums):\n        # Resolve all smaller elements in the stack\n        while stack and val > nums[stack[-1]]:\n            idx = stack.pop()\n            res[idx] = val\n        stack.append(i)\n\n    return res",
    "code_2": "def next_greater_elements(nums):\n    \"\"\"\n    Given a list of integers, returns a list where each element is replaced by\n    the next greater element to its right in the list or -1 if none exists.\n    \"\"\"\n    # For each element, look ahead with a generator expression\n    return [next((x for x in nums[i+1:] if x > num), -1) for i, num in enumerate(nums)]"
  },
  {
    "task": "Determinant 2x2 Matrix",
    "input": "two-dimensional list of four numbers (2x2 matrix)",
    "output": "determinant value",
    "function_name": "determinant_2x2",
    "code_1": "def determinant_2x2(matrix):\n    \"\"\"\n    Calculate the determinant of a 2x2 matrix.\n    Input: matrix as a list of lists [[a, b], [c, d]]\n    Returns: a * d - b * c\n    \"\"\"\n    return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0]",
    "code_2": "def determinant_2x2(matrix):\n    \"\"\"\n    Calculate the determinant of a 2x2 matrix by flattening the input.\n    Input: matrix as a list of lists [[a, b], [c, d]]\n    Returns: a * d - b * c\n    \"\"\"\n    flat = matrix[0] + matrix[1]\n    a, b, c, d = flat\n    return a * d - b * c\n"
  },
  {
    "task": "Mirror List",
    "input": "list of elements",
    "output": "list concatenated with its reverse",
    "function_name": "mirror_list",
    "code_1": "def mirror_list(input_list):\n    \"\"\"Return the list concatenated with its reverse.\"\"\"\n    return input_list + input_list[::-1]",
    "code_2": "def mirror_list(input_list):\n    \"\"\"Return the list concatenated with its reverse.\"\"\"\n    result = list(input_list)\n    for element in reversed(input_list):\n        result.append(element)\n    return result"
  },
  {
    "task": "Split Into Increasing Runs",
    "input": "a list of integers",
    "output": "a list of lists, each sublist being a maximal strictly increasing contiguous run from the input",
    "function_name": "split_into_increasing_runs",
    "code_1": "def split_into_increasing_runs(lst):\n    \"\"\"Split a list of integers into maximal strictly increasing contiguous runs.\"\"\"\n    runs = []\n    if not lst:\n        return runs\n    current = [lst[0]]\n    for elem in lst[1:]:\n        if elem > current[-1]:\n            current.append(elem)\n        else:\n            runs.append(current)\n            current = [elem]\n    runs.append(current)\n    return runs",
    "code_2": "def split_into_increasing_runs(lst):\n    \"\"\"Split a list of integers into maximal strictly increasing contiguous runs.\"\"\"\n    if not lst:\n        return []\n    # Determine start indices of each run\n    starts = [0] + [i for i in range(1, len(lst)) if lst[i] <= lst[i-1]]\n    # Append end sentinel\n    starts.append(len(lst))\n    # Slice the list at the computed boundaries\n    return [lst[starts[i]:starts[i+1]] for i in range(len(starts) - 1)]\n"
  },
  {
    "task": "Replace Vowels",
    "input": "string",
    "output": "string with all vowels replaced by '*'",
    "function_name": "replace_vowels",
    "code_1": "def replace_vowels(s):\n    \"\"\"Return a copy of s with all vowels replaced by '*'\"\"\"\n    return ''.join('*' if c.lower() in 'aeiou' else c for c in s)",
    "code_2": "def replace_vowels(s):\n    # build a translation table mapping all vowels to '*'\n    table = str.maketrans('aeiouAEIOU', '*' * 10)\n    # apply the translation to the input string\n    return s.translate(table)"
  },
  {
    "task": "Longest Unique-Char Word",
    "input": "a list of strings",
    "output": "the longest string that contains no repeated characters (if tie, return any)",
    "function_name": "longest_unique_char_word",
    "code_1": "def longest_unique_char_word(words):\n    best = ''\n    for w in words:\n        # Check if all characters are unique\n        if len(w) > len(best) and len(set(w)) == len(w):\n            best = w\n    return best",
    "code_2": "def longest_unique_char_word(words):\n    # Filter words with all unique characters and pick the longest\n    unique_words = (w for w in words if len(set(w)) == len(w))\n    return max(unique_words, key=len, default='')"
  },
  {
    "task": "Generate Odd Numbers",
    "input": "integer n",
    "output": "list of the first n odd numbers",
    "function_name": "generate_odd_numbers",
    "code_1": "def generate_odd_numbers(n):\n    \"\"\"Return a list of the first n odd numbers.\"\"\"\n    return [2*i + 1 for i in range(n)]",
    "code_2": "def generate_odd_numbers(n):\n    '''Return a list of the first n odd numbers.'''\n    from itertools import islice, count\n    # Generate an infinite sequence of odd numbers and take the first n\n    return list(islice(count(1, 2), n))"
  },
  {
    "task": "Character Positions",
    "input": "string of lowercase letters",
    "output": "list of integer positions in the alphabet (a=1, b=2, \u2026)",
    "function_name": "get_char_positions",
    "code_1": "def get_char_positions(s):\n    \"\"\"Return a list of positions of lowercase letters in the alphabet (a=1, b=2, \u2026 z=26).\"\"\"\n    return [ord(char) - ord('a') + 1 for char in s]",
    "code_2": "def get_char_positions(s):\n    import string\n    # Create a lookup dict mapping each lowercase letter to its position\n    letter_to_pos = {letter: idx + 1 for idx, letter in enumerate(string.ascii_lowercase)}\n    # Map each character in the input string to its position\n    return list(map(letter_to_pos.__getitem__, s))"
  },
  {
    "task": "Sort Tuples by Sum",
    "input": "list of tuples of numbers",
    "output": "list of tuples sorted by the sum of their elements",
    "function_name": "sort_tuples_by_sum",
    "code_1": "def sort_tuples_by_sum(tuple_list):\n    \"\"\"\n    Sorts a list of tuples by the sum of their elements.\n    :param tuple_list: List of tuples containing numbers\n    :return: List of tuples sorted by the sum of elements\n    \"\"\"\n    return sorted(tuple_list, key=sum)",
    "code_2": "def sort_tuples_by_sum(tuple_list):\n    \"\"\"\n    Sorts a list of tuples by the sum of their elements using a heap.\n    \"\"\"\n    import heapq\n    # Build a heap of (sum, tuple) pairs\n    heap = [(sum(t), t) for t in tuple_list]\n    heapq.heapify(heap)\n    # Extract tuples in ascending order of their sums\n    return [heapq.heappop(heap)[1] for _ in range(len(heap))]"
  },
  {
    "task": "Extract Vowel Words",
    "input": "string (sentence)",
    "output": "list of words that start with a vowel",
    "function_name": "extract_vowel_words",
    "code_1": "def extract_vowel_words(sentence):\n    \"\"\"\n    Extracts and returns a list of words from the input sentence that start with a vowel.\n    \"\"\"\n    # Define the set of vowel characters\n    vowels = set('AEIOUaeiou')\n    # Split the sentence into words based on whitespace\n    words = sentence.split()\n    # Filter and return words starting with a vowel\n    return [word for word in words if word and word[0] in vowels]",
    "code_2": "import re\n\ndef extract_vowel_words(sentence):\n    \"\"\"\n    Extract and return words starting with a vowel using regex.\n    \"\"\"\n    pattern = re.compile(r\"\\b[AEIOUaeiou][^\\s]*\")\n    return pattern.findall(sentence)"
  },
  {
    "task": "Count Leading Zeros",
    "input": "string of digits",
    "output": "integer count of leading '0' characters",
    "function_name": "count_leading_zeros",
    "code_1": "def count_leading_zeros(s):\n    \"\"\"\n    Count the number of leading '0' characters in the input string s.\n    Args:\n        s (str): A string of digits.\n    Returns:\n        int: The count of leading zeros.\n    \"\"\"\n    count = 0\n    for char in s:\n        if char == '0':\n            count += 1\n        else:\n            break\n    return count\n",
    "code_2": "def count_leading_zeros(s):\n    \"\"\"Count the number of leading '0' characters in the input string s.\"\"\"\n    return len(s) - len(s.lstrip('0'))\n"
  },
  {
    "task": "Swap Variables Without Temp",
    "input": "Two numbers (ints or floats)",
    "output": "A tuple with the two numbers swapped",
    "function_name": "swap_variables",
    "code_1": "def swap_variables(a, b):\n    return b, a",
    "code_2": "def swap_variables(a, b):\n    # use arithmetic operations to swap without a temp variable\n    a = a + b\n    b = a - b\n    a = a - b\n    return a, b"
  },
  {
    "task": "Element-wise List Maximum",
    "input": "Two lists of numbers of equal length",
    "output": "A list where each element is the maximum of the corresponding elements of the input lists",
    "function_name": "elementwise_max",
    "code_1": "def elementwise_max(list1, list2):\n    \"\"\"Return a list of element-wise maxima of two equal-length lists.\"\"\"\n    return [max(a, b) for a, b in zip(list1, list2)]",
    "code_2": "def elementwise_max(list1, list2):\n    \"\"\"Return a list of element-wise maxima of two equal-length lists.\"\"\"\n    # Use map with a lambda to compare corresponding items\n    return list(map(lambda x, y: x if x >= y else y, list1, list2))"
  },
  {
    "task": "Key with Maximum Value",
    "input": "dictionary with numeric values",
    "output": "key corresponding to the maximum value",
    "function_name": "key_with_max_value",
    "code_1": "def key_with_max_value(d):\n    \"\"\"\n    Return the key with the maximum numeric value in the dictionary d.\n    If d is empty, returns None.\n    \"\"\"\n    if not d:\n        return None\n    return max(d, key=d.get)",
    "code_2": "def key_with_max_value(d):\n    '''\n    Return the key with the maximum numeric value in the dictionary d.\n    If d is empty, returns None.\n    '''\n    best = None\n    for k, v in d.items():\n        if best is None or v > best[1]:\n            best = (k, v)\n    return best[0] if best else None"
  },
  {
    "task": "Product Except Self",
    "input": "A list of numbers",
    "output": "A list where each element is the product of all other elements in the input list except itself",
    "function_name": "product_except_self",
    "code_1": "def product_except_self(nums):\n    n = len(nums)\n    result = [1] * n\n    prefix = 1\n    for i in range(n):\n        result[i] = prefix\n        prefix *= nums[i]\n    suffix = 1\n    for i in range(n - 1, -1, -1):\n        result[i] *= suffix\n        suffix *= nums[i]\n    return result",
    "code_2": "def product_except_self(nums):\n    from functools import reduce\n    from operator import mul\n    # Count zeros to handle edge cases\n    zero_count = nums.count(0)\n    if zero_count > 1:\n        # More than one zero => all results zero\n        return [0] * len(nums)\n    # Compute product of all non-zero elements\n    total_prod = reduce(mul, (x for x in nums if x != 0), 1)\n    if zero_count == 1:\n        # Exactly one zero => only the position with zero gets total_prod\n        return [total_prod if x == 0 else 0 for x in nums]\n    # No zeros => divide total_prod by each element\n    return [total_prod // x for x in nums]"
  },
  {
    "task": "Count Trailing Ones in Binary",
    "input": "An integer",
    "output": "The count of consecutive 1s at the least significant end of its binary representation",
    "function_name": "count_trailing_ones",
    "code_1": "def count_trailing_ones(n):\n    \"\"\"\n    Count the number of consecutive 1s at the least significant end of the binary representation of n.\n    Args:\n        n (int): A non-negative integer\n    Returns:\n        int: The count of trailing ones\n    \"\"\"\n    count = 0\n    # Iterate while the least significant bit is 1\n    while n & 1:\n        count += 1\n        n >>= 1\n    return count",
    "code_2": "def count_trailing_ones(n):\n    \"\"\"\n    Count the number of consecutive 1s at the least significant end of the binary representation of n.\n    \"\"\"\n    # Convert to binary string without '0b'\n    b = bin(n)[2:]\n    # Find last zero; everything after it are trailing ones\n    idx = b.rfind('0')\n    return len(b) if idx == -1 else len(b) - idx - 1\n"
  },
  {
    "task": "Kth Smallest Element",
    "input": "A list of numbers and an integer k",
    "output": "The kth smallest element in the list",
    "function_name": "kth_smallest",
    "code_1": "def kth_smallest(nums, k):\n    \"\"\"\n    Return the k-th smallest element in the list nums.\n    Raises ValueError if k is out of bounds.\n    \"\"\"\n    if not isinstance(nums, list):\n        raise TypeError(\"nums must be a list of numbers\")\n    n = len(nums)\n    if k < 1 or k > n:\n        raise ValueError(\"k is out of the bounds of the list\")\n    # Sort and return the (k-1)th index element\n    sorted_nums = sorted(nums)\n    return sorted_nums[k-1]",
    "code_2": "def kth_smallest(nums, k):\n    \"\"\"\n    Return the k-th smallest element in the list nums.\n    Raises ValueError if k is out of bounds.\n    \"\"\"\n    if not isinstance(nums, list):\n        raise TypeError(\"nums must be a list of numbers\")\n    n = len(nums)\n    if k < 1 or k > n:\n        raise ValueError(\"k is out of the bounds of the list\")\n    import heapq\n    # Get the k smallest elements and pick the largest among them\n    return heapq.nsmallest(k, nums)[-1]"
  },
  {
    "task": "Ugly Number Check",
    "input": "An integer",
    "output": "Boolean indicating whether the number\u2019s only prime factors are 2, 3, or 5",
    "function_name": "is_ugly",
    "code_1": "def is_ugly(num):\n    \"\"\"\n    Check if a number is an Ugly number.\n    An Ugly number's only prime factors are 2, 3, or 5.\n    Returns True if num is ugly, False otherwise.\n    \"\"\"\n    if num <= 0:\n        return False\n    for p in (2, 3, 5):\n        while num % p == 0:\n            num //= p\n    return num == 1",
    "code_2": "from functools import lru_cache\n\n@lru_cache(None)\ndef is_ugly(num):\n    \"\"\"\n    Check if a number is an Ugly number using recursion and memoization.\n    An Ugly number's only prime factors are 2, 3, or 5.\n    Returns True if num is ugly, False otherwise.\n    \"\"\"\n    if num == 1:\n        return True\n    if num <= 0:\n        return False\n    for p in (2, 3, 5):\n        if num % p == 0 and is_ugly(num // p):\n            return True\n    return False"
  },
  {
    "task": "Arithmetic Progression Check",
    "input": "A list of numbers",
    "output": "Boolean indicating whether the list elements form an arithmetic progression when ordered",
    "function_name": "is_arithmetic_progression",
    "code_1": "def is_arithmetic_progression(nums):\n    # Empty or single-element or two-element lists are trivially arithmetic\n    if len(nums) <= 2:\n        return True\n    # Sort the list to check progression regardless of original order\n    sorted_nums = sorted(nums)\n    # Common difference from first two elements\n    diff = sorted_nums[1] - sorted_nums[0]\n    # Verify that each consecutive difference matches\n    for i in range(2, len(sorted_nums)):\n        if sorted_nums[i] - sorted_nums[i-1] != diff:\n            return False\n    return True",
    "code_2": "def is_arithmetic_progression(nums):\n    n = len(nums)\n    if n < 3:\n        return True\n    mn, mx = min(nums), max(nums)\n    # total span must be divisible by number of intervals\n    if (mx - mn) % (n - 1) != 0:\n        return False\n    step = (mx - mn) // (n - 1)\n    values = set(nums)\n    # check each expected term\n    return all(mn + i * step in values for i in range(n))\n"
  },
  {
    "task": "Group Words by Initial",
    "input": "A list of strings",
    "output": "A dictionary mapping each initial character to a list of words beginning with that character",
    "function_name": "group_words_by_initial",
    "code_1": "def group_words_by_initial(words):\n    \"\"\"\n    Group words by their initial character.\n\n    Args:\n        words (list of str): The list of words to group.\n\n    Returns:\n        dict: A dictionary mapping each initial character to a list of words starting with that character.\n    \"\"\"\n    result = {}\n    for word in words:\n        if word:\n            key = word[0]\n            result.setdefault(key, []).append(word)\n    return result",
    "code_2": "from collections import defaultdict\n\ndef group_words_by_initial(words):\n    grouped = defaultdict(list)\n    for word in words:\n        if word:\n            grouped[word[0]].append(word)\n    return dict(grouped)"
  },
  {
    "task": "ASCII Value List",
    "input": "A string",
    "output": "A list of integers representing the ASCII code_1 of each character in the string",
    "function_name": "ascii_value_list",
    "code_1": "def ascii_value_list(input_string):\n    \"\"\"Return a list of ASCII code_1s for each character in the input string.\"\"\"\n    return [ord(char) for char in input_string]",
    "code_2": "def ascii_value_list(input_string):\n    # Use map to convert each char to its ASCII code\n    return list(map(ord, input_string))"
  },
  {
    "task": "Words Longer Than Average",
    "input": "A string sentence",
    "output": "A list of words from the sentence whose length is greater than the average word length",
    "function_name": "words_longer_than_average",
    "code_1": "def words_longer_than_average(sentence):\n    # Split the sentence into words\n    words = sentence.split()\n    # If there are no words, return an empty list\n    if not words:\n        return []\n    # Compute the average word length\n    average_length = sum(len(word) for word in words) / len(words)\n    # Return words longer than the average length\n    return [word for word in words if len(word) > average_length]",
    "code_2": "def words_longer_than_average(sentence):\n    import statistics\n    words = sentence.split()\n    try:\n        avg = statistics.mean(map(len, words))\n    except statistics.StatisticsError:\n        return []\n    return list(filter(lambda w, a=avg: len(w) > a, words))\n"
  },
  {
    "task": "Triangle Area Calculator",
    "input": "List of three coordinate pairs as tuples of floats",
    "output": "Float area of the triangle",
    "function_name": "calculate_triangle_area",
    "code_1": "def calculate_triangle_area(points):\n    # points is a list of three (x, y) tuples\n    (x1, y1), (x2, y2), (x3, y3) = points\n    # Shoelace formula for triangle area\n    return abs(x1*(y2 - y3) + x2*(y3 - y1) + x3*(y1 - y2)) / 2.0",
    "code_2": "import math\n\ndef calculate_triangle_area(points):\n    (x1, y1), (x2, y2), (x3, y3) = points\n    # Compute side lengths\n    a = math.hypot(x2 - x1, y2 - y1)\n    b = math.hypot(x3 - x2, y3 - y2)\n    c = math.hypot(x1 - x3, y1 - y3)\n    # Heron's formula\n    s = (a + b + c) / 2.0\n    return math.sqrt(s * (s - a) * (s - b) * (s - c))"
  },
  {
    "task": "ATM Cash Dispenser",
    "input": "Integer amount",
    "output": "Dictionary mapping note denominations to counts",
    "function_name": "atm_cash_dispenser",
    "code_1": "def atm_cash_dispenser(amount):\n    notes = [100, 50, 20, 10, 5, 1]\n    result = {}\n    for note in notes:\n        count, amount = divmod(amount, note)\n        if count:\n            result[note] = count\n    return result",
    "code_2": "def atm_cash_dispenser(amount):\n    notes = [100, 50, 20, 10, 5, 1]\n    res = {}\n    rem = amount\n    while rem > 0:\n        note = max(n for n in notes if n <= rem)\n        res[note] = res.get(note, 0) + 1\n        rem -= note\n    return res"
  },
  {
    "task": "Join List with Delimiter",
    "input": "List of strings and a string delimiter",
    "output": "Single string with elements joined by the delimiter",
    "function_name": "join_with_delimiter",
    "code_1": "def join_with_delimiter(strings, delimiter):\n    return delimiter.join(strings)",
    "code_2": "def join_with_delimiter(strings, delimiter):\n    result = ''\n    for item in strings:\n        if result:\n            result += delimiter\n        result += item\n    return result"
  },
  {
    "task": "Max Adjacent Difference",
    "input": "List of numbers (integers or floats)",
    "output": "Maximum absolute difference between consecutive elements",
    "function_name": "max_adjacent_difference",
    "code_1": "def max_adjacent_difference(nums):\n    \"\"\"\n    Compute the maximum absolute difference between consecutive elements in a list of numbers.\n    Returns 0 for lists with fewer than 2 elements.\n    \"\"\"\n    if not isinstance(nums, (list, tuple)):\n        raise TypeError(\"Input must be a list or tuple of numbers\")\n    if len(nums) < 2:\n        return 0\n    max_diff = 0\n    for prev, curr in zip(nums, nums[1:]):\n        diff = abs(curr - prev)\n        if diff > max_diff:\n            max_diff = diff\n    return max_diff",
    "code_2": "def max_adjacent_difference(nums):\n    import functools\n\n    # Validate input type\n    if not isinstance(nums, (list, tuple)):\n        raise TypeError(\"Input must be a list or tuple of numbers\")\n    # If fewer than two elements, no adjacent pairs exist\n    if len(nums) < 2:\n        return 0\n    # Use reduce to accumulate the maximum absolute difference\n    return functools.reduce(\n        lambda current_max, pair: max(current_max, abs(pair[1] - pair[0])),\n        zip(nums, nums[1:]),\n        0\n    )"
  },
  {
    "task": "Random Case String",
    "input": "String text",
    "output": "String with each alphabetic character randomly converted to uppercase or lowercase",
    "function_name": "random_case_string",
    "code_1": "def random_case_string(text):\n    import random\n    result_chars = []\n    for c in text:\n        if c.isalpha():\n            c = random.choice([c.upper(), c.lower()])\n        result_chars.append(c)\n    return ''.join(result_chars)",
    "code_2": "def random_case_string(text):\n    import random, re\n    return re.sub(r'[A-Za-z]',\n                  lambda m: m.group(0).upper() if random.getrandbits(1) else m.group(0).lower(),\n                  text)"
  },
  {
    "task": "Sum of Digits in List",
    "input": "List of non-negative integers",
    "output": "List of integers representing the sum of digits for each input number",
    "function_name": "sum_of_digits_in_list",
    "code_1": "def sum_of_digits_in_list(numbers):\n    result = []\n    for num in numbers:\n        digit_sum = sum(int(d) for d in str(num))\n        result.append(digit_sum)\n    return result",
    "code_2": "def sum_of_digits_in_list(numbers):\n    def digit_sum(n):\n        total = 0\n        while n:\n            total, n = total + n % 10, n // 10\n        return total\n    return [digit_sum(num) for num in numbers]"
  },
  {
    "task": "Bracket Balance Check",
    "input": "String containing brackets '()', '[]', '{}'",
    "output": "Boolean indicating whether all bracket types are properly balanced",
    "function_name": "is_bracket_balanced",
    "code_1": "def is_bracket_balanced(s):\n    stack = []\n    pairs = {')': '(', ']': '[', '}': '{'}\n    for ch in s:\n        if ch in '([{':\n            stack.append(ch)\n        elif ch in ')]}':\n            if not stack or stack[-1] != pairs[ch]:\n                return False\n            stack.pop()\n    return not stack",
    "code_2": "def is_bracket_balanced(s):\n    filtered = ''.join(c for c in s if c in '()[]{}')\n    prev = None\n    while prev != filtered:\n        prev = filtered\n        filtered = filtered.replace('()','').replace('[]','').replace('{}','')\n    return not filtered"
  },
  {
    "task": "Valid Identifier Check",
    "input": "String",
    "output": "Boolean indicating whether the string is a valid Python identifier",
    "function_name": "is_valid_identifier",
    "code_1": "def is_valid_identifier(s):\n    \"\"\"Return True if s is a valid Python identifier.\"\"\"\n    return isinstance(s, str) and s.isidentifier()",
    "code_2": "def is_valid_identifier(s):\n    if not isinstance(s, str):\n        return False\n    import re\n    # must start with a letter or underscore, followed by word characters\n    return bool(re.match(\"[^\\\\d\\\\W]\\\\w*\\\\Z\", s, re.UNICODE))"
  },
  {
    "task": "Luhn Checksum Validation",
    "input": "Numeric string",
    "output": "Boolean indicating whether the string passes the Luhn check",
    "function_name": "is_luhn_valid",
    "code_1": "def is_luhn_valid(num_str):\n    total = 0\n    reverse_digits = num_str[::-1]\n    for i, ch in enumerate(reverse_digits):\n        if not ch.isdigit():\n            return False\n        digit = int(ch)\n        if i % 2 == 1:\n            digit *= 2\n            if digit > 9:\n                digit -= 9\n        total += digit\n    return total % 10 == 0",
    "code_2": "def is_luhn_valid(num_str):\n    \"\"\"Return True if num_str passes the Luhn checksum, False otherwise.\"\"\"\n    from itertools import cycle\n    # Attempt to convert all characters to integers\n    try:\n        digits = list(map(int, num_str))\n    except ValueError:\n        return False\n    # Apply alternating factors 1,2 from the rightmost digit\n    total = 0\n    for d, factor in zip(reversed(digits), cycle([1, 2])):\n        dbl = d * factor\n        total += dbl - 9 if dbl > 9 else dbl\n    return total % 10 == 0"
  },
  {
    "task": "Floyd\u2019s Triangle Generator",
    "input": "integer rows",
    "output": "list of lists representing Floyd\u2019s triangle with given number of rows",
    "function_name": "generate_floyd_triangle",
    "code_1": "def generate_floyd_triangle(rows):\n    \"\"\"\n    Generate Floyd's triangle with the given number of rows.\n    Each row i contains i sequential numbers starting from 1.\n    Returns a list of lists representing the triangle.\n    \"\"\"\n    result = []\n    counter = 1\n    for i in range(1, rows + 1):\n        row = []\n        for _ in range(i):\n            row.append(counter)\n            counter += 1\n        result.append(row)\n    return result",
    "code_2": "def generate_floyd_triangle(rows):\n    from itertools import count, islice\n    seq = count(1)\n    return [list(islice(seq, n)) for n in range(1, rows+1)]"
  },
  {
    "task": "Kaprekar Number Check",
    "input": "integer n",
    "output": "Boolean indicating whether n is a Kaprekar number",
    "function_name": "is_kaprekar",
    "code_1": "def is_kaprekar(n):\n    if n < 1:\n        return False\n    sq = n * n\n    s = str(sq)\n    d = len(str(n))\n    right = s[-d:]\n    left = s[:-d]\n    left_num = int(left) if left else 0\n    right_num = int(right) if right else 0\n    return left_num + right_num == n",
    "code_2": "def is_kaprekar(n):\n    if n < 1:\n        return False\n    # compute square\n    sq = n * n\n    # count digits of n without converting to string\n    d = 0\n    tmp = n\n    while tmp:\n        d += 1\n        tmp //= 10\n    # split square into left and right parts\n    divisor = 10 ** d\n    left, right = divmod(sq, divisor)\n    return left + right == n"
  },
  {
    "task": "Longest Binary Ones Run",
    "input": "Non-negative integer",
    "output": "Integer length of the longest run of consecutive '1's in its binary representation",
    "function_name": "longest_binary_ones_run",
    "code_1": "def longest_binary_ones_run(n):\n    b = bin(n)[2:]\n    return max(len(s) for s in b.split('0'))",
    "code_2": "def longest_binary_ones_run(n):\n    max_run = current = 0\n    while n > 0:\n        if n & 1:\n            current += 1\n            if current > max_run:\n                max_run = current\n        else:\n            current = 0\n        n >>= 1\n    return max_run"
  },
  {
    "task": "Sum at Prime Indices",
    "input": "list of integers",
    "output": "integer sum of elements at prime indices (0-based)",
    "function_name": "sum_at_prime_indices",
    "code_1": "def sum_at_prime_indices(nums):\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    total = 0\n    for i, val in enumerate(nums):\n        if is_prime(i):\n            total += val\n    return total",
    "code_2": "def sum_at_prime_indices(nums):\n    n = len(nums)\n    # Sieve of Eratosthenes to mark prime indices\n    if n < 3:\n        return 0\n    sieve = [True] * n\n    sieve[0] = sieve[1] = False\n    for p in range(2, int(n**0.5) + 1):\n        if sieve[p]:\n            for multiple in range(p*p, n, p):\n                sieve[multiple] = False\n    # Sum values at indices marked prime\n    return sum(val for idx, val in enumerate(nums) if sieve[idx])"
  },
  {
    "task": "Max Parentheses Depth",
    "input": "string containing parentheses",
    "output": "integer representing maximum nesting depth of parentheses",
    "function_name": "max_parentheses_depth",
    "code_1": "def max_parentheses_depth(s):\n    \"\"\"\n    Calculate the maximum nesting depth of parentheses in the input string s.\n    Returns an integer representing the deepest level of nested parentheses.\n    \"\"\"\n    depth = 0\n    max_depth = 0\n    for char in s:\n        if char == '(':\n            depth += 1\n            if depth > max_depth:\n                max_depth = depth\n        elif char == ')':\n            if depth > 0:\n                depth -= 1\n    return max_depth",
    "code_2": "def max_parentheses_depth(s):\n    import re\n    depth = 0\n    temp = s\n    while True:\n        new_s = re.sub(r'\\([^()]*\\)', '', temp)\n        if new_s == temp:\n            break\n        depth += 1\n        temp = new_s\n    return depth"
  },
  {
    "task": "Partition List by Pivot",
    "input": "list of integers, integer pivot",
    "output": "three lists: elements less than, equal to, and greater than the pivot",
    "function_name": "partition_list",
    "code_1": "def partition_list(nums, pivot):\n    \"\"\"\n    Partition a list of integers into three lists: less than, equal to, and greater than the pivot.\n\n    Args:\n        nums (list of int): The list of integers to partition.\n        pivot (int): The pivot value to partition around.\n\n    Returns:\n        tuple: A tuple containing three lists:\n            - list of ints less than pivot\n            - list of ints equal to pivot\n            - list of ints greater than pivot\n    \"\"\"\n    less = []\n    equal = []\n    greater = []\n\n    for num in nums:\n        if num < pivot:\n            less.append(num)\n        elif num == pivot:\n            equal.append(num)\n        else:\n            greater.append(num)\n\n    return less, equal, greater",
    "code_2": "def partition_list(nums, pivot):\n    # Use filter to separate values in one-line calls\n    less = list(filter(lambda x: x < pivot, nums))\n    equal = list(filter(lambda x: x == pivot, nums))\n    greater = list(filter(lambda x: x > pivot, nums))\n    return less, equal, greater"
  },
  {
    "task": "Pi Approximation (Leibniz)",
    "input": "integer terms",
    "output": "float approximation of \u03c0 using given number of terms in the Leibniz series",
    "function_name": "approximate_pi_leibniz",
    "code_1": "def approximate_pi_leibniz(terms):\n    \"\"\"\n    Approximate \u03c0 using the Leibniz series with the given number of terms.\n    :param terms: Number of terms to include in the series (integer)\n    :return: Approximation of \u03c0 as a float\n    \"\"\"\n    total = 0.0\n    for k in range(terms):\n        total += ((-1) ** k) / (2 * k + 1)\n    return 4 * total",
    "code_2": "def approximate_pi_leibniz(terms):\n    import itertools\n    signs = itertools.cycle((1.0, -1.0))\n    total = 0.0\n    for sign, k in zip(signs, range(terms)):\n        total += sign / (2 * k + 1)\n    return 4 * total"
  },
  {
    "task": "Bit Swap",
    "input": "integer n, integer i, integer j (bit positions)",
    "output": "integer result after swapping the i-th and j-th bits of n",
    "function_name": "swap_bits",
    "code_1": "def swap_bits(n, i, j):\n    # Get the i-th and j-th bits\n    bit_i = (n >> i) & 1\n    bit_j = (n >> j) & 1\n    # If bits differ, flip both\n    if bit_i != bit_j:\n        n ^= (1 << i) | (1 << j)\n    return n",
    "code_2": "def swap_bits(n, i, j):\n    # Convert to binary string and pad\n    b = bin(n)[2:]\n    length = max(i, j) + 1\n    if len(b) < length:\n        b = b.zfill(length)\n    # Swap characters at positions from the right\n    bits = list(b)\n    pi = len(bits) - 1 - i\n    pj = len(bits) - 1 - j\n    bits[pi], bits[pj] = bits[pj], bits[pi]\n    # Reconstruct integer\n    return int(''.join(bits), 2)"
  },
  {
    "task": "Sum of Multiples of K",
    "input": "Two integers n and k",
    "output": "Integer sum of all positive integers \u2264 n that are divisible by k",
    "function_name": "sum_of_multiples",
    "code_1": "def sum_of_multiples(n, k):\n    \"\"\"\n    Return the sum of all positive integers less than or equal to n that are divisible by k.\n    \"\"\"\n    # Number of multiples of k up to n\n    m = n // k\n    # Sum of first m multiples of k: k * (1 + 2 + ... + m) = k * m * (m + 1) // 2\n    return k * m * (m + 1) // 2",
    "code_2": "def sum_of_multiples(n, k):\n    \"\"\"Return the sum of all positive integers \u2264 n that are divisible by k.\"\"\"\n    return sum(range(k, n+1, k))"
  },
  {
    "task": "Spiral Matrix Generator",
    "input": "integer n",
    "output": "n\u00d7n matrix (list of lists) filled in spiral order from 1 to n\u00b2",
    "function_name": "generate_spiral_matrix",
    "code_1": "def generate_spiral_matrix(n):\n    matrix = [[0] * n for _ in range(n)]\n    top, bottom, left, right = 0, n - 1, 0, n - 1\n    num = 1\n    while num <= n * n:\n        for col in range(left, right + 1):\n            matrix[top][col] = num\n            num += 1\n        top += 1\n        for row in range(top, bottom + 1):\n            matrix[row][right] = num\n            num += 1\n        right -= 1\n        if top <= bottom:\n            for col in range(right, left - 1, -1):\n                matrix[bottom][col] = num\n                num += 1\n            bottom -= 1\n        if left <= right:\n            for row in range(bottom, top - 1, -1):\n                matrix[row][left] = num\n                num += 1\n            left += 1\n    return matrix",
    "code_2": "def generate_spiral_matrix(n):\n    matrix = [[0] * n for _ in range(n)]\n    # directions: right, down, left, up\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    d = 0  # current direction index\n    x = y = 0\n    for num in range(1, n * n + 1):\n        matrix[x][y] = num\n        dx, dy = dirs[d]\n        nx, ny = x + dx, y + dy\n        # change direction if next cell is out of bounds or already filled\n        if not (0 <= nx < n and 0 <= ny < n and matrix[nx][ny] == 0):\n            d = (d + 1) % 4\n            dx, dy = dirs[d]\n            nx, ny = x + dx, y + dy\n        x, y = nx, ny\n    return matrix"
  },
  {
    "task": "Distance From Point to Line",
    "input": "Five floats x, y, a, b, c representing point (x,y) and line ax + by + c = 0",
    "output": "Float distance from the point to the line",
    "function_name": "distance_point_to_line",
    "code_1": "def distance_point_to_line(x, y, a, b, c):\n    import math\n    \"\"\"\n    Calculate the distance from point (x, y) to the line ax + by + c = 0.\n    \"\"\"\n    return abs(a * x + b * y + c) / math.sqrt(a * a + b * b)",
    "code_2": "def distance_point_to_line(x, y, a, b, c):\n    \"\"\"\n    Calculate the perpendicular distance from point (x, y) to the line ax + by + c = 0.\n    \"\"\"\n    # Use tuple unpacking and inline power for sqrt\n    normal = (a, b)\n    point = (x, y)\n    # dot product of normal and point, then add c\n    dot_val = normal[0] * point[0] + normal[1] * point[1]\n    num = abs(dot_val + c)\n    # length of the normal vector via exponentiation\n    den = (normal[0]**2 + normal[1]**2) ** 0.5\n    return num / den"
  },
  {
    "task": "Insert Into Sorted List",
    "input": "A list of integers sorted in ascending order and an integer value",
    "output": "A new list with the value inserted, maintaining sorted order",
    "function_name": "insert_into_sorted",
    "code_1": "def insert_into_sorted(lst, value):\n    left, right = 0, len(lst)\n    while left < right:\n        mid = (left + right) // 2\n        if lst[mid] < value:\n            left = mid + 1\n        else:\n            right = mid\n    return lst[:left] + [value] + lst[left:]",
    "code_2": "def insert_into_sorted(lst, value):\n    result = []\n    inserted = False\n    for x in lst:\n        if not inserted and x >= value:\n            result.append(value)\n            inserted = True\n        result.append(x)\n    if not inserted:\n        result.append(value)\n    return result"
  },
  {
    "task": "Number to English Words",
    "input": "integer n (0 \u2264 n < 1000000)",
    "output": "string with the English words representation of n",
    "function_name": "number_to_words",
    "code_1": "def number_to_words(n):\n    if n < 0 or n >= 1000000:\n        raise ValueError('Input out of range (0 <= n < 1000000)')\n    if n == 0:\n        return 'zero'\n    ones = {1: 'one', 2: 'two', 3: 'three', 4: 'four', 5: 'five', 6: 'six', 7: 'seven', 8: 'eight', 9: 'nine'}\n    teens = {10: 'ten', 11: 'eleven', 12: 'twelve', 13: 'thirteen', 14: 'fourteen', 15: 'fifteen', 16: 'sixteen', 17: 'seventeen', 18: 'eighteen', 19: 'nineteen'}\n    tens = {20: 'twenty', 30: 'thirty', 40: 'forty', 50: 'fifty', 60: 'sixty', 70: 'seventy', 80: 'eighty', 90: 'ninety'}\n\n    def helper(num):\n        parts = []\n        if num >= 100:\n            parts.append(ones[num // 100] + ' hundred')\n            num %= 100\n        if num >= 20:\n            t = (num // 10) * 10\n            if num % 10:\n                parts.append(tens[t] + '-' + ones[num % 10])\n            else:\n                parts.append(tens[t])\n        elif num >= 10:\n            parts.append(teens[num])\n        elif num > 0:\n            parts.append(ones[num])\n        return ' '.join(parts)\n\n    parts = []\n    thousands = n // 1000\n    remainder = n % 1000\n    if thousands:\n        parts.append(helper(thousands) + ' thousand')\n    if remainder:\n        parts.append(helper(remainder))\n    return ' '.join(parts)",
    "code_2": "def number_to_words(n):\n    if not isinstance(n, int) or n < 0 or n >= 1000000:\n        raise ValueError('Input out of range (0 <= n < 1000000)')\n    if n == 0:\n        return 'zero'\n    units = ['', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine']\n    teens = ['ten', 'eleven', 'twelve', 'thirteen', 'fourteen', 'fifteen', 'sixteen', 'seventeen', 'eighteen', 'nineteen']\n    tens_names = ['', '', 'twenty', 'thirty', 'forty', 'fifty', 'sixty', 'seventy', 'eighty', 'ninety']\n    def words(num):\n        if num < 10:\n            return units[num]\n        if num < 20:\n            return teens[num-10]\n        if num < 100:\n            q, r = divmod(num, 10)\n            return tens_names[q] + ('' if r == 0 else '-' + units[r])\n        if num < 1000:\n            q, r = divmod(num, 100)\n            return units[q] + ' hundred' + ('' if r == 0 else ' ' + words(r))\n        q, r = divmod(num, 1000)\n        return words(q) + ' thousand' + ('' if r == 0 else ' ' + words(r))\n    return words(n)"
  },
  {
    "task": "Count Words Ending with Vowel",
    "input": "A string containing one or more words separated by spaces",
    "output": "Integer count of words that end with a vowel (a, e, i, o, u, case\u2010insensitive)",
    "function_name": "count_words_ending_with_vowel",
    "code_1": "def count_words_ending_with_vowel(s):\n    \"\"\"\n    Count the number of words in the input string that end with a vowel (a, e, i, o, u), case-insensitive.\n    Words are separated by whitespace.\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    count = 0\n    for word in s.split():\n        if word and word[-1] in vowels:\n            count += 1\n    return count",
    "code_2": "import re\n\ndef count_words_ending_with_vowel(s):\n    \"\"\"Count words ending with a vowel using regex\"\"\"\n    # Find sequences of non-whitespace characters ending with a vowel at a word boundary\n    return len(re.findall(r\"\\b\\S*[aeiouAEIOU]\\b\", s))"
  },
  {
    "task": "Prime Ones Check",
    "input": "An integer n",
    "output": "Boolean indicating whether the count of '1's in the binary representation of n is a prime number",
    "function_name": "prime_ones_check",
    "code_1": "def prime_ones_check(n):\n    # Helper function to determine if a number is prime\n    def is_prime(k):\n        if k < 2:\n            return False\n        if k == 2:\n            return True\n        if k % 2 == 0:\n            return False\n        i = 3\n        while i * i <= k:\n            if k % i == 0:\n                return False\n            i += 2\n        return True\n\n    # Count the number of '1's in the binary representation of n\n    count_ones = bin(n).count('1')\n    # Return True if the count is prime, False otherwise\n    return is_prime(count_ones)",
    "code_2": "def prime_ones_check(n):\n    # Count '1' bits using built-in bit_count (Python 3.8+)\n    ones = n.bit_count()\n    # 0 and 1 are not prime, so fail fast\n    if ones < 2:\n        return False\n    # Check divisibility from 2 up to sqrt(ones)\n    return all(ones % i for i in range(2, int(ones**0.5) + 1))"
  },
  {
    "task": "Next Power of Two",
    "input": "An integer n",
    "output": "The smallest power of two greater than or equal to n",
    "function_name": "next_power_of_two",
    "code_1": "def next_power_of_two(n):\n    if n <= 1:\n        return 1\n    return 1 << (n - 1).bit_length()",
    "code_2": "def next_power_of_two(n):\n    p = 1\n    while p < n:\n        p <<= 1\n    return p"
  },
  {
    "task": "Word Occurrence Positions",
    "input": "A string of words separated by spaces",
    "output": "A dictionary mapping each word to a list of its 1-based positions in the string",
    "function_name": "word_occurrence_positions",
    "code_1": "def word_occurrence_positions(text):\n    positions = {}\n    for idx, word in enumerate(text.split(), start=1):\n        positions.setdefault(word, []).append(idx)\n    return positions",
    "code_2": "def word_occurrence_positions(text):\n    words = text.split()\n    return {w: [i+1 for i, x in enumerate(words) if x == w] for w in set(words)}"
  },
  {
    "task": "Scrabble Score",
    "input": "A single word string",
    "output": "Integer total score based on standard English Scrabble letter values",
    "function_name": "scrabble_score",
    "code_1": "def scrabble_score(word):\n    \"\"\"\n    Calculate the Scrabble score for a given word using standard English letter values.\n    :param word: str, a single word\n    :return: int, total Scrabble score\n    \"\"\"\n    values = {\n        'A': 1, 'E': 1, 'I': 1, 'O': 1, 'U': 1, 'L': 1, 'N': 1, 'S': 1, 'T': 1, 'R': 1,\n        'D': 2, 'G': 2,\n        'B': 3, 'C': 3, 'M': 3, 'P': 3,\n        'F': 4, 'H': 4, 'V': 4, 'W': 4, 'Y': 4,\n        'K': 5,\n        'J': 8, 'X': 8,\n        'Q': 10, 'Z': 10\n    }\n    return sum(values.get(ch.upper(), 0) for ch in word)",
    "code_2": "def scrabble_score(word):\n    \"\"\"Compute Scrabble score using a fixed 26-length score list.\"\"\"\n    scores = [1, 3, 3, 2, 1, 4, 2, 4, 1, 8, 5, 1, 3, 1, 1, 3, 10, 1, 1, 1, 1, 4, 4, 8, 4, 10]\n    total = 0\n    for ch in word.upper():\n        idx = ord(ch) - ord('A')\n        if 0 <= idx < 26:\n            total += scores[idx]\n    return total"
  },
  {
    "task": "Longest Binary Zero Run",
    "input": "integer n",
    "output": "integer length of the longest consecutive run of zeros in the binary representation of n",
    "function_name": "longest_zero_run",
    "code_1": "def longest_zero_run(n):\n    # Get binary representation without prefix and sign\n    if n < 0:\n        rep = bin(n)[3:]\n    else:\n        rep = bin(n)[2:]\n    max_run = 0\n    current = 0\n    # Count consecutive zeros\n    for ch in rep:\n        if ch == '0':\n            current += 1\n            if current > max_run:\n                max_run = current\n        else:\n            current = 0\n    return max_run",
    "code_2": "def longest_zero_run(n):\n    import itertools\n    # get magnitude binary without prefix\n    bits = format(abs(n), 'b')\n    # group consecutive bits and count zeros\n    return max((sum(1 for _ in grp) for bit, grp in itertools.groupby(bits) if bit == '0'), default=0)"
  },
  {
    "task": "Ones Complement",
    "input": "A binary string containing only '0' and '1'",
    "output": "A binary string where each bit is inverted (0\u21921, 1\u21920)",
    "function_name": "ones_complement",
    "code_1": "def ones_complement(binary_str):\n    \"\"\"\n    Return the ones' complement of a binary string (invert each bit).\n    Args:\n        binary_str (str): A string containing only '0' and '1'.\n    Returns:\n        str: A binary string where each bit is inverted (0->1, 1->0).\n    \"\"\"\n    # Validate input\n    if not all(c in '01' for c in binary_str):\n        raise ValueError(\"Input must be a binary string containing only '0' and '1'.\")\n    # Invert each bit\n    return ''.join('1' if c == '0' else '0' for c in binary_str)",
    "code_2": "import re\n\ndef ones_complement(binary_str):\n    \"\"\"\n    Return the ones' complement of a binary string by translating bits.\n    Args:\n        binary_str (str): A string containing only '0' and '1'.\n    Returns:\n        str: Inverted binary string (0\u21921, 1\u21920).\n    \"\"\"\n    # Validate input using regex\n    if re.search(r'[^01]', binary_str):\n        raise ValueError(\"Input must be a binary string containing only '0' and '1'.\")\n    # Use str.translate with a translation table\n    table = str.maketrans('01', '10')\n    return binary_str.translate(table)"
  },
  {
    "task": "Compare Version Numbers",
    "input": "Two version strings (e.g., \"1.2.10\", \"1.3\")",
    "output": "Integer -1 if first < second, 0 if equal, 1 if first > second",
    "function_name": "compare_versions",
    "code_1": "def compare_versions(v1, v2):\n    parts1 = [int(x) for x in v1.split('.')]\n    parts2 = [int(x) for x in v2.split('.')]\n    max_len = max(len(parts1), len(parts2))\n    parts1 += [0] * (max_len - len(parts1))\n    parts2 += [0] * (max_len - len(parts2))\n    for p1, p2 in zip(parts1, parts2):\n        if p1 < p2:\n            return -1\n        elif p1 > p2:\n            return 1\n    return 0",
    "code_2": "def compare_versions(v1, v2):\n    nums1 = list(map(int, v1.split('.')))\n    nums2 = list(map(int, v2.split('.')))\n    # Strip trailing zeros for accurate comparison\n    while nums1 and nums1[-1] == 0:\n        nums1.pop()\n    while nums2 and nums2[-1] == 0:\n        nums2.pop()\n    # Compare lexicographically\n    if nums1 < nums2:\n        return -1\n    if nums1 > nums2:\n        return 1\n    return 0"
  },
  {
    "task": "Triangle Type Finder",
    "input": "Three numbers representing the lengths of the sides",
    "output": "A string: \u201cEquilateral\u201d, \u201cIsosceles\u201d, \u201cScalene\u201d or \u201cNot a triangle\u201d",
    "function_name": "triangle_type",
    "code_1": "def triangle_type(a, b, c):\n    # Check for positive side lengths\n    if a <= 0 or b <= 0 or c <= 0:\n        return \"Not a triangle\"\n    # Check triangle inequality\n    if a + b <= c or a + c <= b or b + c <= a:\n        return \"Not a triangle\"\n    # Determine type\n    if a == b == c:\n        return \"Equilateral\"\n    if a == b or b == c or a == c:\n        return \"Isosceles\"\n    return \"Scalene\"",
    "code_2": "def triangle_type(a, b, c):\n    # Sort sides to simplify checks\n    x, y, z = sorted((a, b, c))\n    # Must be positive and satisfy triangle inequality\n    if x <= 0 or x + y <= z:\n        return \"Not a triangle\"\n    # Use set to count distinct lengths\n    kinds = {a, b, c}\n    if len(kinds) == 1:\n        return \"Equilateral\"\n    if len(kinds) == 2:\n        return \"Isosceles\"\n    return \"Scalene\""
  },
  {
    "task": "Centroid of Points",
    "input": "A list of tuples, each tuple containing two numbers (x, y)",
    "output": "A tuple of two floats representing the centroid coordinates (x\u0304, \u0233)",
    "function_name": "compute_centroid",
    "code_1": "def compute_centroid(points):\n    # Compute the centroid of a list of (x, y) tuples\n    if not points:\n        raise ValueError(\"The list of points is empty\")\n    xs, ys = zip(*points)\n    x_bar = sum(xs) / len(xs)\n    y_bar = sum(ys) / len(ys)\n    return (x_bar, y_bar)",
    "code_2": "def compute_centroid(points):\n    # Compute the centroid of a list of (x, y) tuples using a single-pass accumulation\n    if not points:\n        raise ValueError(\"The list of points is empty\")\n    x_sum, y_sum = 0.0, 0.0\n    for x, y in points:\n        x_sum += x\n        y_sum += y\n    count = len(points)\n    return x_sum / count, y_sum / count"
  },
  {
    "task": "Spiral Matrix Traversal",
    "input": "A 2D list of numbers (matrix)",
    "output": "A list of numbers in the order they appear in a clockwise spiral traversal",
    "function_name": "spiral_traversal",
    "code_1": "def spiral_traversal(matrix):\n    result = []\n    if not matrix or not matrix[0]:\n        return result\n    top, bottom = 0, len(matrix) - 1\n    left, right = 0, len(matrix[0]) - 1\n    while top <= bottom and left <= right:\n        # Traverse from left to right on the top row\n        for col in range(left, right + 1):\n            result.append(matrix[top][col])\n        top += 1\n        # Traverse from top to bottom on the right column\n        for row in range(top, bottom + 1):\n            result.append(matrix[row][right])\n        right -= 1\n        # Traverse from right to left on the bottom row\n        if top <= bottom:\n            for col in range(right, left - 1, -1):\n                result.append(matrix[bottom][col])\n            bottom -= 1\n        # Traverse from bottom to top on the left column\n        if left <= right:\n            for row in range(bottom, top - 1, -1):\n                result.append(matrix[row][left])\n            left += 1\n    return result",
    "code_2": "def spiral_traversal(matrix):\n    result = []\n    # Work on a copy to avoid mutating the input\n    m = [row[:] for row in matrix]\n    while m:\n        # Take the first row\n        result.extend(m.pop(0))\n        if not m:\n            break\n        # Rotate the remaining matrix counter-clockwise\n        m = [list(col) for col in zip(*m)][::-1]\n    return result"
  },
  {
    "task": "RGB to Hex Converter",
    "input": "Three integers (R, G, B), each in the range 0\u2013255",
    "output": "A string representing the color in hexadecimal format, e.g., \u201c#4A73B2\u201d",
    "function_name": "rgb_to_hex",
    "code_1": "def rgb_to_hex(r, g, b):\n    '''Convert RGB values to a hex color string.'''\n    if not all(isinstance(v, int) and 0 <= v <= 255 for v in (r, g, b)):\n        raise ValueError('Each component must be an integer in the range 0-255')\n    return '#{0:02X}{1:02X}{2:02X}'.format(r, g, b)",
    "code_2": "def rgb_to_hex(r, g, b):\n    # Validate each component\n    for v in (r, g, b):\n        if not isinstance(v, int) or not 0 <= v <= 255:\n            raise ValueError('Each component must be an integer in the range 0-255')\n    # Convert to hex, strip '0x', pad, uppercase\n    parts = [hex(v)[2:].zfill(2).upper() for v in (r, g, b)]\n    return '#' + ''.join(parts)\n"
  },
  {
    "task": "Initials Extractor",
    "input": "A string containing a person\u2019s full name (words separated by spaces)",
    "output": "A string of the uppercase initials concatenated",
    "function_name": "extract_initials",
    "code_1": "def extract_initials(name):\n    \"\"\"\n    Extracts and returns the uppercase initials from a full name string.\n    :param name: str - A person's full name (words separated by spaces)\n    :return: str - Concatenated uppercase initials\n    \"\"\"\n    # Strip leading/trailing whitespace and split the name into words\n    words = name.strip().split()\n    # Extract the first character of each word, convert to uppercase, and concatenate\n    initials = ''.join(word[0].upper() for word in words if word)\n    return initials",
    "code_2": "def extract_initials(name):\n    import re\n    # Find characters at the start or right after a space\n    initials = re.findall(r'(?<=^|\\s)(\\S)', name.strip())\n    # Uppercase and concatenate\n    return ''.join(map(str.upper, initials))"
  },
  {
    "task": "Permutation Check",
    "input": "Two lists of elements",
    "output": "A boolean indicating whether one list is a permutation of the other",
    "function_name": "is_permutation",
    "code_1": "def is_permutation(list1, list2):\n    from collections import Counter\n    if len(list1) != len(list2):\n        return False\n    return Counter(list1) == Counter(list2)",
    "code_2": "def is_permutation(list1, list2):\n    # Quick fail if lengths differ\n    if len(list1) != len(list2):\n        return False\n    # Compare sorted lists\n    return sorted(list1) == sorted(list2)\n"
  },
  {
    "task": "Longest Consecutive Character",
    "input": "A string",
    "output": "A tuple containing the character with the longest consecutive run and its run length (char, count)",
    "function_name": "longest_consecutive_character",
    "code_1": "def longest_consecutive_character(s):\n    # Handle empty string\n    if not s:\n        return (None, 0)\n    max_char = s[0]\n    max_count = 1\n    current_char = s[0]\n    current_count = 1\n    # Iterate over the string starting from the second character\n    for c in s[1:]:\n        if c == current_char:\n            current_count += 1\n        else:\n            # Update max if current run is longer\n            if current_count > max_count:\n                max_count = current_count\n                max_char = current_char\n            # Reset for new character\n            current_char = c\n            current_count = 1\n    # Final check after loop\n    if current_count > max_count:\n        max_count = current_count\n        max_char = current_char\n    return (max_char, max_count)",
    "code_2": "def longest_consecutive_character(s):\n    import itertools\n    # Early exit for empty input\n    if not s:\n        return (None, 0)\n    # Create a generator of (char, run_length) tuples\n    runs = ((ch, sum(1 for _ in grp)) for ch, grp in itertools.groupby(s))\n    # max by the run length\n    return max(runs, key=lambda item: item[1])"
  },
  {
    "task": "Diagonal Difference",
    "input": "A square 2D list of numbers (n x n matrix)",
    "output": "An integer equal to the absolute difference between the sums of its two diagonals",
    "function_name": "diagonal_difference",
    "code_1": "def diagonal_difference(matrix):\n    \"\"\"\n    Calculate the absolute difference between the sums of the two diagonals of a square matrix.\n    :param matrix: List[List[int]] - a square 2D list of numbers\n    :return: int - absolute difference between primary and secondary diagonal sums\n    \"\"\"\n    n = len(matrix)\n    primary_sum = sum(matrix[i][i] for i in range(n))\n    secondary_sum = sum(matrix[i][n - 1 - i] for i in range(n))\n    return abs(primary_sum - secondary_sum)",
    "code_2": "def diagonal_difference(matrix):\n    # Compute both diagonals in one pass using enumerate and bitwise complement\n    primary_sum = 0\n    secondary_sum = 0\n    for i, row in enumerate(matrix):\n        primary_sum += row[i]\n        secondary_sum += row[~i]\n    return abs(primary_sum - secondary_sum)"
  },
  {
    "task": "Polygon Interior Angle Sum",
    "input": "An integer n (>2) representing the number of sides of a polygon",
    "output": "An integer equal to the sum of the interior angles in degrees",
    "function_name": "polygon_interior_angle_sum",
    "code_1": "def polygon_interior_angle_sum(n):\n    '''Return the sum of interior angles of an n-sided polygon.'''\n    return (n - 2) * 180",
    "code_2": "def polygon_interior_angle_sum(n):\n    \"\"\"Return the sum of interior angles of an n-sided polygon.\"\"\"\n    # Sum 180 degrees for each triangle formed by dividing the polygon\n    return sum(180 for _ in range(n - 2))"
  },
  {
    "task": "Next Date Calculator",
    "input": "Three integers: day, month, year",
    "output": "A string in format \u201cYYYY-MM-DD\u201d representing the next calendar date",
    "function_name": "next_date",
    "code_1": "def next_date(day, month, year):\n    \"\"\"Return the next date as a string in 'YYYY-MM-DD' format.\"\"\"\n    # Determine days in the current month\n    if month == 2:\n        # Leap year check\n        if (year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)):\n            days_in_month = 29\n        else:\n            days_in_month = 28\n    elif month in [1, 3, 5, 7, 8, 10, 12]:\n        days_in_month = 31\n    else:\n        days_in_month = 30\n    # Move to the next day\n    if day < days_in_month:\n        day += 1\n    else:\n        day = 1\n        if month == 12:\n            month = 1\n            year += 1\n        else:\n            month += 1\n    # Return formatted date\n    return f\"{year:04d}-{month:02d}-{day:02d}\"",
    "code_2": "import datetime\n\ndef next_date(day, month, year):\n    # Use datetime for date arithmetic\n    current = datetime.date(year, month, day)\n    next_day = current + datetime.timedelta(days=1)\n    return next_day.strftime('%Y-%m-%d')"
  },
  {
    "task": "Extract Prime-Position Elements",
    "input": "list of integers",
    "output": "list of elements whose positions (1-based) are prime numbers",
    "function_name": "extract_prime_position_elements",
    "code_1": "def extract_prime_position_elements(lst):\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    return [val for idx, val in enumerate(lst, start=1) if is_prime(idx)]",
    "code_2": "def extract_prime_position_elements(lst):\n    # Use Sieve of Eratosthenes to find prime positions up to len(lst)\n    n = len(lst)\n    if n < 2:\n        return []\n    sieve = [True] * (n + 1)\n    sieve[0] = sieve[1] = False\n    for p in range(2, int(n**0.5) + 1):\n        if sieve[p]:\n            for multiple in range(p*p, n + 1, p):\n                sieve[multiple] = False\n    # Collect elements at prime (1-based) indices\n    return [lst[i-1] for i, is_p in enumerate(sieve) if is_p]\n"
  },
  {
    "task": "Swap List Halves",
    "input": "list of elements",
    "output": "list of elements with the first half and second half swapped",
    "function_name": "swap_list_halves",
    "code_1": "def swap_list_halves(lst):\n    mid = len(lst) // 2\n    return lst[mid:] + lst[:mid]",
    "code_2": "from collections import deque\n\ndef swap_list_halves(lst):\n    d = deque(lst)\n    mid = len(lst) // 2\n    d.rotate(-mid)\n    return list(d)"
  },
  {
    "task": "Largest Successive Gap",
    "input": "list of integers",
    "output": "maximum difference between successive elements after sorting the list",
    "function_name": "largest_successive_gap",
    "code_1": "def largest_successive_gap(nums):\n    \"\"\"\n    Return the maximum difference between successive elements after sorting the list.\n    If the list has fewer than 2 elements, returns 0.\n    \"\"\"\n    if len(nums) < 2:\n        return 0\n    nums_sorted = sorted(nums)\n    max_gap = 0\n    for i in range(1, len(nums_sorted)):\n        gap = nums_sorted[i] - nums_sorted[i - 1]\n        if gap > max_gap:\n            max_gap = gap\n    return max_gap",
    "code_2": "def largest_successive_gap(nums):\n    if len(nums) < 2:\n        return 0\n    s = sorted(nums)\n    return max(b - a for a, b in zip(s, s[1:]))\n"
  },
  {
    "task": "Shortest Word Finder",
    "input": "string representing a sentence",
    "output": "the shortest word in the sentence",
    "function_name": "find_shortest_word",
    "code_1": "def find_shortest_word(sentence):\n    \"\"\"Return the shortest word in the given sentence. If the sentence is empty, return an empty string.\"\"\"\n    # Split the sentence into words based on whitespace\n    words = sentence.split()\n    # If there are no words, return an empty string\n    if not words:\n        return \"\"\n    # Return the shortest word using the min function with key=len\n    return min(words, key=len)",
    "code_2": "from functools import reduce\n\ndef find_shortest_word(sentence):\n    '''Return the shortest word in the given sentence. If the sentence is empty, return an empty string.'''\n    words = sentence.split()\n    if not words:\n        return ''\n    return reduce(lambda shortest, word: shortest if len(shortest) <= len(word) else word, words)\n"
  },
  {
    "task": "Time Format Validation",
    "input": "string in \"HH:MM:SS\" format",
    "output": "boolean indicating whether it represents a valid time (00\u2264HH<24, 00\u2264MM<60, 00\u2264SS<60)",
    "function_name": "is_valid_time",
    "code_1": "def is_valid_time(time_str):\n    parts = time_str.split(':')\n    if len(parts) != 3:\n        return False\n    hh, mm, ss = parts\n    if not (hh.isdigit() and mm.isdigit() and ss.isdigit()):\n        return False\n    if not (len(hh) == 2 and len(mm) == 2 and len(ss) == 2):\n        return False\n    h, m, s = int(hh), int(mm), int(ss)\n    return 0 <= h < 24 and 0 <= m < 60 and 0 <= s < 60",
    "code_2": "def is_valid_time(time_str):\n    import re\n    return bool(re.fullmatch(r'(?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d', time_str))"
  },
  {
    "task": "Identify List Duplicates",
    "input": "list of elements",
    "output": "list of elements that appear more than once (each duplicate listed once)",
    "function_name": "find_duplicates",
    "code_1": "def find_duplicates(lst):\n    seen = set()\n    duplicates = set()\n    for item in lst:\n        if item in seen:\n            duplicates.add(item)\n        else:\n            seen.add(item)\n    return list(duplicates)",
    "code_2": "def find_duplicates(lst):\n    from collections import Counter\n    return [item for item, count in Counter(lst).items() if count > 1]"
  },
  {
    "task": "Next Perfect Square",
    "input": "positive integer",
    "output": "the smallest perfect square strictly greater than the input",
    "function_name": "next_perfect_square",
    "code_1": "def next_perfect_square(n):\n    import math\n    # Compute the integer square root and add one to get the next candidate\n    k = math.isqrt(n) + 1\n    # Return its square, which is strictly greater than n\n    return k * k",
    "code_2": "def next_perfect_square(n):\n    k = 1\n    # Increment k until its square exceeds n\n    while k * k <= n:\n        k += 1\n    return k * k"
  },
  {
    "task": "Line Lengths",
    "input": "multiline string",
    "output": "list of integers representing the length of each line",
    "function_name": "line_lengths",
    "code_1": "def line_lengths(s):\n    \"\"\"Return a list of lengths for each line in the multiline string s.\"\"\"\n    # splitlines() handles different newline characters without retaining them\n    return [len(line) for line in s.splitlines()]",
    "code_2": "def line_lengths(s):\n    import re\n    # Split on any newline variant without keeping delimiters\n    lines = re.split(r'\\r\\n?|\\n', s)\n    # Drop the trailing empty string if s ends with a newline\n    if lines and lines[-1] == '':\n        lines.pop()\n    # Map each line to its length\n    return list(map(len, lines))"
  },
  {
    "task": "Check List Rotation",
    "input": "two lists of integers",
    "output": "boolean indicating if one list is a rotation of the other",
    "function_name": "is_rotation",
    "code_1": "def is_rotation(list1, list2):\n    # Check if two lists are rotations of each other\n    if len(list1) != len(list2):\n        return False\n    # Empty lists are rotations of each other\n    if not list1:\n        return True\n    # Duplicate the first list to cover all rotations\n    doubled = list1 * 2\n    n = len(list2)\n    # Check each possible rotation\n    for i in range(len(list1)):\n        if doubled[i:i+n] == list2:\n            return True\n    return False",
    "code_2": "def is_rotation(list1, list2):\n    # Quick length check\n    if len(list1) != len(list2):\n        return False\n    n = len(list1)\n    # Both empty lists\n    if n == 0:\n        return True\n    # Try every possible rotation offset using modulo arithmetic\n    return any(\n        all(list1[(i + offset) % n] == list2[i] for i in range(n))\n        for offset in range(n)\n    )"
  },
  {
    "task": "Snake to Pascal Case",
    "input": "string in snake_case",
    "output": "string converted to PascalCase",
    "function_name": "snake_to_pascal_case",
    "code_1": "def snake_to_pascal_case(s):\n    parts = s.split('_')\n    return ''.join(word.capitalize() for word in parts if word)",
    "code_2": "def snake_to_pascal_case(s):\n    # Build the PascalCase string by iterating characters\n    result_chars = []\n    capitalize_next = True\n    for ch in s:\n        if ch == '_':\n            # Next alphabetic character should be uppercase\n            capitalize_next = True\n        else:\n            if capitalize_next:\n                result_chars.append(ch.upper())\n                capitalize_next = False\n            else:\n                result_chars.append(ch)\n    return ''.join(result_chars)"
  },
  {
    "task": "Case-Insensitive Sort",
    "input": "list of strings",
    "output": "list of strings sorted alphabetically ignoring case",
    "function_name": "case_insensitive_sort",
    "code_1": "def case_insensitive_sort(strings):\n    \"\"\"Return a new list of strings sorted alphabetically, ignoring case.\"\"\"\n    return sorted(strings, key=str.lower)",
    "code_2": "def case_insensitive_sort(strings):\n    \"\"\"Return a new list of strings sorted alphabetically, ignoring case.\"\"\"\n    # Decorate with casefold, sort, then undecorate\n    decorated = [(s.casefold(), s) for s in strings]\n    decorated.sort()\n    return [original for _, original in decorated]"
  },
  {
    "task": "Line Word Counts",
    "input": "multiline string",
    "output": "list of integers representing the word count of each line",
    "function_name": "line_word_counts",
    "code_1": "def line_word_counts(text):\n    lines = text.splitlines()\n    counts = []\n    for line in lines:\n        words = line.split()\n        counts.append(len(words))\n    return counts",
    "code_2": "def line_word_counts(text):\n    import re\n    pattern = re.compile(r'\\S+')\n    return [len(pattern.findall(line)) for line in text.split('\\n')]"
  },
  {
    "task": "Matrix Rotate 180",
    "input": "square matrix as a list of lists",
    "output": "matrix rotated by 180 degrees",
    "function_name": "rotate_matrix_180",
    "code_1": "def rotate_matrix_180(matrix):\n    \"\"\"\n    Rotate a square matrix by 180 degrees.\n    :param matrix: List of lists representing the square matrix\n    :return: New matrix rotated by 180 degrees\n    \"\"\"\n    # Reverse the order of rows and reverse each row\n    return [row[::-1] for row in matrix[::-1]]",
    "code_2": "def rotate_matrix_180(matrix):\n    \"\"\"\n    Rotate a square matrix by 180 degrees using index mapping.\n    :param matrix: List of lists representing the square matrix\n    :return: New matrix rotated by 180 degrees\n    \"\"\"\n    n = len(matrix)\n    # Prepare an empty n x n matrix\n    rotated = [[None for _ in range(n)] for _ in range(n)]\n    # Map each element to its 180-degree rotated position\n    for i in range(n):\n        for j in range(n):\n            rotated[n - 1 - i][n - 1 - j] = matrix[i][j]\n    return rotated\n"
  },
  {
    "task": "Fibonacci Sequence",
    "input": "integer n",
    "output": "list of the first n Fibonacci numbers",
    "function_name": "fibonacci_sequence",
    "code_1": "def fibonacci_sequence(n):\n    if n <= 0:\n        return []\n    seq = [0, 1]\n    while len(seq) < n:\n        seq.append(seq[-1] + seq[-2])\n    return seq[:n]",
    "code_2": "def fibonacci_sequence(n):\n    import itertools\n    def gen():\n        a, b = 0, 1\n        for _ in itertools.count():\n            yield a\n            a, b = b, a + b\n    # islice will handle n <= 0 by returning an empty list\n    return list(itertools.islice(gen(), n))"
  },
  {
    "task": "Trim List",
    "input": "list and integer n",
    "output": "list containing the first n elements (or the whole list if shorter)",
    "function_name": "trim_list",
    "code_1": "def trim_list(lst, n):\n    \"\"\"Return the first n elements of lst, or the whole list if it has fewer than n elements.\"\"\"\n    return lst[:n]",
    "code_2": "def trim_list(lst, n):\n    \"\"\"Return the first n elements of lst, or the whole list if it is shorter.\"\"\"\n    result = []\n    for idx, element in enumerate(lst):\n        if idx >= n:\n            break\n        result.append(element)\n    return result"
  },
  {
    "task": "Remove Digits",
    "input": "string",
    "output": "string with all digit characters removed",
    "function_name": "remove_digits",
    "code_1": "def remove_digits(s):\n    \"\"\"Remove all digit characters from the input string.\"\"\"\n    return ''.join(ch for ch in s if not ch.isdigit())",
    "code_2": "def remove_digits(s):\n    \"\"\"Remove all digit characters from the input string.\"\"\"\n    # Use str.translate with a mapping that drops digits\n    tbl = str.maketrans('', '', '0123456789')\n    return s.translate(tbl)"
  },
  {
    "task": "Remove Items by Index",
    "input": "list and list of integer indices",
    "output": "list after removing elements at the given indices",
    "function_name": "remove_items_by_index",
    "code_1": "def remove_items_by_index(lst, indices):\n    \"\"\"\n    Remove elements from lst at the specified indices.\n    :param lst: list of elements\n    :param indices: list of integer indices to remove\n    :return: new list with specified elements removed\n    \"\"\"\n    indices_set = set(indices)\n    return [v for i, v in enumerate(lst) if i not in indices_set]",
    "code_2": "def remove_items_by_index(lst, indices):\n    \"\"\"\n    Remove elements from lst at the specified indices by popping in reverse order.\n    \"\"\"\n    # Work on a shallow copy to avoid mutating the original list\n    items = lst.copy()\n    # Sort indices descending so removals don't shift earlier items\n    for idx in sorted(indices, reverse=True):\n        if 0 <= idx < len(items):\n            items.pop(idx)\n    return items"
  },
  {
    "task": "Rectangle Perimeter Calculator",
    "input": "Two floats representing length and width",
    "output": "Float representing the perimeter",
    "function_name": "calculate_rectangle_perimeter",
    "code_1": "def calculate_rectangle_perimeter(length, width):\n    \"\"\"Calculate the perimeter of a rectangle given its length and width.\"\"\"\n    return 2 * (length + width)",
    "code_2": "def calculate_rectangle_perimeter(length, width):\n    \"\"\"Compute the perimeter by summing all four sides stored in a tuple.\"\"\"\n    sides = (length, width) * 2\n    return sum(sides)\n"
  },
  {
    "task": "Sieve of Eratosthenes",
    "input": "Integer n",
    "output": "List of prime numbers up to n",
    "function_name": "sieve_of_eratosthenes",
    "code_1": "def sieve_of_eratosthenes(n):\n    if n < 2:\n        return []\n    sieve = [True] * (n + 1)\n    sieve[0], sieve[1] = False, False\n    p = 2\n    while p * p <= n:\n        if sieve[p]:\n            for multiple in range(p * p, n + 1, p):\n                sieve[multiple] = False\n        p += 1\n    return [i for i, is_prime in enumerate(sieve) if is_prime]",
    "code_2": "def sieve_of_eratosthenes(n):\n    # Use a set to hold candidates and eliminate multiples in bulk\n    if n < 2:\n        return []\n    nums = set(range(2, n+1))\n    limit = int(n**0.5)\n    for p in range(2, limit+1):\n        if p in nums:\n            # Remove all multiples of p starting from p*p\n            nums -= set(range(p*p, n+1, p))\n    # Return the remaining numbers sorted\n    return sorted(nums)"
  },
  {
    "task": "Weighted Random Choice",
    "input": "list of items and a list of numeric weights of the same length",
    "output": "one item randomly chosen according to the given weights",
    "function_name": "weighted_random_choice",
    "code_1": "def weighted_random_choice(items, weights):\n    import random\n    if len(items) != len(weights):\n        raise ValueError('Items and weights must be of same length')\n    total = sum(weights)\n    if total <= 0:\n        raise ValueError('Sum of weights must be positive')\n    r = random.random() * total\n    cum = 0\n    for item, w in zip(items, weights):\n        cum += w\n        if r < cum:\n            return item\n    return items[-1]",
    "code_2": "def weighted_random_choice(items, weights):\n    import itertools, bisect, random\n    if len(items) != len(weights):\n        raise ValueError('Items and weights must be of same length')\n    cum_weights = list(itertools.accumulate(weights))\n    total = cum_weights[-1] if cum_weights else 0\n    if total <= 0:\n        raise ValueError('Sum of weights must be positive')\n    r = random.random() * total\n    idx = bisect.bisect_right(cum_weights, r)\n    return items[idx]"
  },
  {
    "task": "Credit Card Masking",
    "input": "String representing a credit card number",
    "output": "String with all but the last four digits replaced by \u2018*\u2019",
    "function_name": "mask_credit_card",
    "code_1": "def mask_credit_card(cc_number):\n    \"\"\"Return the credit card number masked except for the last four digits.\"\"\"\n    # If the input is shorter than or equal to 4 characters, no masking needed\n    if len(cc_number) <= 4:\n        return cc_number\n    # Replace all but the last four characters with asterisks\n    masked_part = '*' * (len(cc_number) - 4)\n    return masked_part + cc_number[-4:]",
    "code_2": "import re\n\ndef mask_credit_card(cc_number):\n    \"\"\"Mask all but the last four characters of the credit card number.\"\"\"\n    # Use a regex to replace any character that has exactly four characters following it\n    return re.sub(r'.(?=.{4})', '*', cc_number)\n"
  },
  {
    "task": "Bubble Sort Algorithm",
    "input": "List of integers",
    "output": "List of integers sorted in ascending order",
    "function_name": "bubble_sort",
    "code_1": "def bubble_sort(lst):\n    n = len(lst)\n    for i in range(n):\n        # Last i elements are already in place\n        for j in range(0, n - i - 1):\n            if lst[j] > lst[j + 1]:\n                # swap\n                lst[j], lst[j + 1] = lst[j + 1], lst[j]\n    return lst",
    "code_2": "def bubble_sort(lst):\n    # Make a copy to avoid mutating the original list\n    arr = lst[:]\n    n = len(arr)\n    # Continue passes until no swaps occur\n    swapped = True\n    while swapped:\n        swapped = False\n        # Traverse the list and bubble up the largest element\n        for i in range(1, n):\n            if arr[i-1] > arr[i]:\n                arr[i-1], arr[i] = arr[i], arr[i-1]\n                swapped = True\n        # After each full pass, the last element is in place\n        n -= 1\n    return arr"
  },
  {
    "task": "Fahrenheit to Celsius List",
    "input": "List of floats (temperatures in Fahrenheit)",
    "output": "List of floats (temperatures in Celsius)",
    "function_name": "fahrenheit_to_celsius_list",
    "code_1": "def fahrenheit_to_celsius_list(f_temps):\n    return [(f - 32) * 5/9 for f in f_temps]",
    "code_2": "def fahrenheit_to_celsius_list(f_temps):\n    return list(map(lambda f: (f - 32) * 5/9, f_temps))"
  },
  {
    "task": "Selection Sort Algorithm",
    "input": "List of integers",
    "output": "List of integers sorted in ascending order",
    "function_name": "selection_sort",
    "code_1": "def selection_sort(arr):\n    \"\"\"Sorts a list of integers in ascending order using selection sort.\"\"\"\n    n = len(arr)\n    for i in range(n):\n        # Find the index of the minimum element in the unsorted portion\n        min_idx = i\n        for j in range(i + 1, n):\n            if arr[j] < arr[min_idx]:\n                min_idx = j\n        # Swap the found minimum element with the first unsorted element\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\n    return arr",
    "code_2": "def selection_sort(arr):\n    '''Sorts a list of integers in ascending order using a non-in-place selection strategy.'''\n    temp = arr[:]  # make a shallow copy to preserve original list\n    sorted_list = []\n    for _ in range(len(temp)):\n        # find index and value of the smallest element\n        idx, val = min(enumerate(temp), key=lambda x: x[1])\n        sorted_list.append(val)\n        temp.pop(idx)  # remove the extracted minimum\n    return sorted_list"
  },
  {
    "task": "Leet Speak Converter",
    "input": "String",
    "output": "String with characters converted to leet equivalents (e.g., A\u21924, E\u21923)",
    "function_name": "to_leet_speak",
    "code_1": "def to_leet_speak(s: str) -> str:\n    mapping = {'A': '4', 'a': '4', 'E': '3', 'e': '3', 'I': '1', 'i': '1', 'O': '0', 'o': '0', 'S': '5', 's': '5', 'T': '7', 't': '7', 'B': '8', 'b': '8', 'G': '6', 'g': '6'}\n    return ''.join(mapping.get(c, c) for c in s)",
    "code_2": "def to_leet_speak(s: str) -> str:\n    # Build a translation table for uppercase and lowercase letters\n    leet_table = str.maketrans(\n        'AEIOSTBGaeiostbg',  # characters to replace\n        '4310578643105786'   # leet equivalents\n    )\n    # Translate the entire string at once\n    return s.translate(leet_table)"
  },
  {
    "task": "Most Frequent Adjacent Pair",
    "input": "List of integers",
    "output": "Tuple representing the adjacent pair that occurs most frequently",
    "function_name": "most_frequent_adjacent_pair",
    "code_1": "def most_frequent_adjacent_pair(nums):\n    from collections import Counter\n    # If fewer than 2 elements, no adjacent pairs\n    if len(nums) < 2:\n        return None\n    # Build counts of each adjacent pair\n    pairs = zip(nums, nums[1:])\n    counter = Counter(pairs)\n    # Return the pair with the highest count\n    return max(counter, key=counter.get)",
    "code_2": "def most_frequent_adjacent_pair(nums):\n    if len(nums) < 2:\n        return None\n    freq = {}\n    for i in range(len(nums) - 1):\n        pair = (nums[i], nums[i + 1])\n        freq[pair] = freq.get(pair, 0) + 1\n    best_pair, _ = max(freq.items(), key=lambda item: item[1])\n    return best_pair"
  },
  {
    "task": "Hex to RGB Converter",
    "input": "String representing a hexadecimal color code_1 (e.g., \"#FFA500\")",
    "output": "Tuple of three integers representing the RGB values",
    "function_name": "hex_to_rgb",
    "code_1": "def hex_to_rgb(hex_str):\n    \"\"\"\n    Convert a hexadecimal color code_1 to an RGB tuple.\n\n    Args:\n        hex_str (str): A string representing a hex color (e.g., \"#FFA500\" or \"FFA500\").\n\n    Returns:\n        tuple: A tuple of three integers corresponding to the RGB values.\n\n    Raises:\n        ValueError: If the input is not a valid 6-digit hex code_1.\n    \"\"\"\n    # Remove leading '#' if present\n    if hex_str.startswith('#'):\n        hex_str = hex_str[1:]\n    # Validate length\n    if len(hex_str) != 6:\n        raise ValueError(f\"Invalid hex color code_1: '{hex_str}'\")\n    # Parse the components\n    r = int(hex_str[0:2], 16)\n    g = int(hex_str[2:4], 16)\n    b = int(hex_str[4:6], 16)\n    return (r, g, b)",
    "code_2": "def hex_to_rgb(hex_str):\n    \"\"\"\n    Convert a hexadecimal color code to an RGB tuple using bit operations.\n\n    Args:\n        hex_str (str): A string representing a hex color (e.g., \"#FFA500\" or \"FFA500\").\n\n    Returns:\n        tuple: A tuple of three integers corresponding to the RGB values.\n\n    Raises:\n        ValueError: If the input is not a valid 6-digit hex code.\n    \"\"\"\n    # Clean input\n    h = hex_str.strip()\n    if h.startswith('#'):\n        h = h[1:]\n    # Validate\n    if len(h) != 6 or any(ch not in '0123456789abcdefABCDEF' for ch in h):\n        raise ValueError(f\"Invalid hex color code: '{hex_str}'\")\n    # Convert to integer and extract components\n    val = int(h, 16)\n    r = (val >> 16) & 0xFF\n    g = (val >> 8) & 0xFF\n    b = val & 0xFF\n    return (r, g, b)"
  },
  {
    "task": "Lucky Ticket Check",
    "input": "a six-digit integer",
    "output": "True if the sum of the first three digits equals the sum of the last three digits, otherwise False",
    "function_name": "is_lucky_ticket",
    "code_1": "def is_lucky_ticket(n):\n    s = str(n)\n    if len(s) != 6:\n        return False\n    return sum(int(d) for d in s[:3]) == sum(int(d) for d in s[3:])",
    "code_2": "def is_lucky_ticket(n):\n    # Reject anything that's not a six-digit integer\n    if not isinstance(n, int) or n < 100000 or n > 999999:\n        return False\n    # Sum last three and first three digits via arithmetic\n    s_first = 0\n    s_last = 0\n    x = n\n    for i in range(6):\n        digit = x % 10\n        if i < 3:\n            s_last += digit\n        else:\n            s_first += digit\n        x //= 10\n    return s_first == s_last"
  },
  {
    "task": "Seconds to DHMS",
    "input": "Integer number of seconds",
    "output": "Tuple of four integers (days, hours, minutes, seconds)",
    "function_name": "seconds_to_dhms",
    "code_1": "def seconds_to_dhms(total_seconds):\n    days = total_seconds // 86400\n    remaining_seconds = total_seconds % 86400\n    hours = remaining_seconds // 3600\n    remaining_seconds %= 3600\n    minutes = remaining_seconds // 60\n    seconds = remaining_seconds % 60\n    return (days, hours, minutes, seconds)",
    "code_2": "def seconds_to_dhms(total_seconds):\n    # Use divmod for stepwise division\n    days, rem = divmod(total_seconds, 86400)\n    hours, rem = divmod(rem, 3600)\n    minutes, seconds = divmod(rem, 60)\n    return days, hours, minutes, seconds"
  },
  {
    "task": "Words by Initial Count",
    "input": "a string representing a sentence",
    "output": "a dictionary mapping each starting letter to the count of words that begin with that letter",
    "function_name": "words_by_initial_count",
    "code_1": "def words_by_initial_count(sentence):\n    counts = {}\n    for word in sentence.split():\n        if not word:\n            continue\n        initial = word[0].lower()\n        counts[initial] = counts.get(initial, 0) + 1\n    return counts",
    "code_2": "import re\nfrom collections import Counter\n\ndef words_by_initial_count(sentence):\n    # extract first letter of each word in lowercase\n    initials = re.findall(r'\\b\\w', sentence.lower())\n    # tally counts\n    return dict(Counter(initials))"
  },
  {
    "task": "Next Power of Three",
    "input": "a positive integer n",
    "output": "the smallest power of 3 that is greater than or equal to n",
    "function_name": "next_power_of_three",
    "code_1": "def next_power_of_three(n):\n    \"\"\"\n    Return the smallest power of 3 that is greater than or equal to n.\n    \"\"\"\n    power = 1\n    while power < n:\n        power *= 3\n    return power",
    "code_2": "def next_power_of_three(n):\n    import math\n    # Compute the exponent as the ceiling of the log base 3 of n\n    exp = math.ceil(math.log(n, 3))\n    # Return 3 raised to that exponent\n    return 3 ** exp"
  },
  {
    "task": "Simplify Fraction",
    "input": "two integers (numerator and denominator)",
    "output": "a tuple of two integers representing the simplified numerator and denominator",
    "function_name": "simplify_fraction",
    "code_1": "def simplify_fraction(numerator, denominator):\n    if denominator == 0:\n        raise ValueError(\"Denominator cannot be zero\")\n    from math import gcd\n    common = gcd(numerator, denominator)\n    numerator //= common\n    denominator //= common\n    if denominator < 0:\n        numerator = -numerator\n        denominator = -denominator\n    return numerator, denominator",
    "code_2": "def simplify_fraction(numerator, denominator):\n    if denominator == 0:\n        raise ValueError(\"Denominator cannot be zero\")\n    from fractions import Fraction\n    frac = Fraction(numerator, denominator)\n    return frac.numerator, frac.denominator"
  },
  {
    "task": "Carry Operations Counter",
    "input": "two non-negative integers",
    "output": "the number of carry operations that occur when adding the two integers digit by digit",
    "function_name": "count_carry_operations",
    "code_1": "def count_carry_operations(a, b):\n    carry = 0\n    count = 0\n    while a > 0 or b > 0:\n        total = (a % 10) + (b % 10) + carry\n        if total >= 10:\n            carry = 1\n            count += 1\n        else:\n            carry = 0\n        a //= 10\n        b //= 10\n    return count",
    "code_2": "def count_carry_operations(a, b):\n    from itertools import zip_longest\n    carry = 0\n    count = 0\n    # reverse string digits to align least significant first\n    for da, db in zip_longest(str(a)[::-1], str(b)[::-1], fillvalue='0'):\n        if int(da) + int(db) + carry >= 10:\n            carry = 1\n            count += 1\n        else:\n            carry = 0\n    return count"
  },
  {
    "task": "Remove Every Nth Element",
    "input": "a list and an integer n",
    "output": "a new list with every nth element removed from the original list",
    "function_name": "remove_every_nth",
    "code_1": "def remove_every_nth(lst, n):\n    \"\"\"Return a new list with every nth element removed from the original list.\"\"\"\n    if n <= 0:\n        return lst[:]\n    return [item for i, item in enumerate(lst, 1) if i % n != 0]",
    "code_2": "def remove_every_nth(lst, n):\n    if n <= 0:\n        return lst[:]\n    result = []\n    for start in range(0, len(lst), n):\n        end = start + n - 1\n        result.extend(lst[start:end])\n    return result"
  },
  {
    "task": "Upper Triangle Sum",
    "input": "a square matrix represented as a list of lists of numbers",
    "output": "the sum of all elements in the upper triangle of the matrix (including the main diagonal)",
    "function_name": "upper_triangle_sum",
    "code_1": "def upper_triangle_sum(matrix):\n    \"\"\"\n    Calculate the sum of the upper triangle (including diagonal) of a square matrix.\n    :param matrix: list of lists of numbers (square matrix)\n    :return: sum of elements on and above the main diagonal\n    \"\"\"\n    total = 0\n    n = len(matrix)\n    for i in range(n):\n        for j in range(i, n):\n            total += matrix[i][j]\n    return total",
    "code_2": "def upper_triangle_sum(matrix):\n    \"\"\"\n    Calculate the sum of the upper triangle (including diagonal) of a square matrix.\n    \"\"\"\n    return sum(val for i, row in enumerate(matrix) for j, val in enumerate(row) if j >= i)"
  },
  {
    "task": "Extract Domain",
    "input": "a string representing a URL",
    "output": "the domain part of the URL as a string",
    "function_name": "extract_domain",
    "code_1": "def extract_domain(url):\n    from urllib.parse import urlparse\n    parsed = urlparse(url)\n    domain = parsed.netloc\n    if not domain:\n        # Handle URLs without scheme\n        parsed = urlparse('//' + url)\n        domain = parsed.netloc\n    return domain",
    "code_2": "def extract_domain(url):\n    # Strip off any scheme\n    parts = url.split('://', 1)\n    tail = parts[1] if len(parts) == 2 else parts[0]\n    # Handle protocol-relative URLs\n    if tail.startswith('//'):\n        tail = tail[2:]\n    # Domain is up to the first slash, question mark, or hash\n    for sep in '/?#':\n        idx = tail.find(sep)\n        if idx != -1:\n            tail = tail[:idx]\n            break\n    return tail\n"
  },
  {
    "task": "Geometric Sequence Check",
    "input": "a list of numbers",
    "output": "True if the numbers form a geometric sequence, otherwise False",
    "function_name": "is_geometric_sequence",
    "code_1": "def is_geometric_sequence(seq):\n    # Sequences of length 0, 1, or 2 are always geometric\n    if len(seq) < 3:\n        return True\n    # Handle case where first term is zero\n    if seq[0] == 0:\n        # It's geometric only if all terms are zero\n        return all(x == 0 for x in seq)\n    # Compute common ratio\n    ratio = seq[1] / seq[0]\n    # Check that each term equals previous term multiplied by ratio\n    for prev, curr in zip(seq, seq[1:]):\n        if prev * ratio != curr:\n            return False\n    return True",
    "code_2": "def is_geometric_sequence(seq):\n    # Sequences with fewer than 3 items are always geometric\n    if len(seq) < 3:\n        return True\n    # Collect ratios between consecutive non-zero terms\n    ratios = set()\n    for a, b in zip(seq, seq[1:]):\n        if a == 0:\n            # if a is zero, b must also be zero to maintain geometric property\n            if b != 0:\n                return False\n        else:\n            ratios.add(b / a)\n    # If all non-zero pairs share one ratio (or there were none), it's geometric\n    return len(ratios) <= 1"
  },
  {
    "task": "Mask Phone Number",
    "input": "a string representing a phone number",
    "output": "the phone number string with all digits replaced by \u2018*\u2019 except the last four digits",
    "function_name": "mask_phone_number",
    "code_1": "def mask_phone_number(phone):\n    # Count total digits in the phone number\n    total_digits = sum(c.isdigit() for c in phone)\n    # Determine how many digits to mask (all but the last four)\n    digits_to_mask = max(total_digits - 4, 0)\n    masked_count = 0\n    result = []\n    for c in phone:\n        if c.isdigit() and masked_count < digits_to_mask:\n            result.append('*')\n            masked_count += 1\n        else:\n            result.append(c)\n    return ''.join(result)",
    "code_2": "import re\n\ndef mask_phone_number(phone):\n    # Replace every digit that has at least four digits following it\n    pattern = r\"\\d(?=(?:.*\\d){4})\"\n    return re.sub(pattern, \"*\", phone)\n"
  },
  {
    "task": "Peak Indices",
    "input": "list of integers",
    "output": "list of integer indices where each element is strictly greater than its immediate neighbors",
    "function_name": "find_peak_indices",
    "code_1": "def find_peak_indices(arr):\n    peaks = []\n    # Iterate over each element except the first and last\n    for i in range(1, len(arr) - 1):\n        # Check if current element is strictly greater than neighbors\n        if arr[i] > arr[i - 1] and arr[i] > arr[i + 1]:\n            peaks.append(i)\n    return peaks",
    "code_2": "def find_peak_indices(arr):\n    # Use sliding windows via zip and list comprehension\n    if len(arr) < 3:\n        return []\n    return [i+1 for i, (a, b, c) in enumerate(zip(arr, arr[1:], arr[2:])) if b > a and b > c]\n"
  },
  {
    "task": "Top N Frequent Elements",
    "input": "list of hashable items, integer N",
    "output": "list of the N most frequent items in descending frequency order",
    "function_name": "top_n_frequent",
    "code_1": "def top_n_frequent(items, N):\n    from collections import Counter\n    # Count the frequency of each item\n    counter = Counter(items)\n    # Get the N most common elements\n    most_common = counter.most_common(N)\n    # Return only the items in descending frequency order\n    return [item for item, count in most_common]",
    "code_2": "def top_n_frequent(items, N):\n    # Build a frequency dictionary\n    freq = {}\n    for elem in items:\n        freq[elem] = freq.get(elem, 0) + 1\n    # Use a heap to find the top N keys by frequency\n    import heapq\n    # heapq.nlargest returns items sorted by the provided key in descending order\n    top_items = heapq.nlargest(N, freq, key=freq.get)\n    return top_items"
  },
  {
    "task": "Element-wise Subtraction",
    "input": "two lists of numbers of equal length",
    "output": "list of numbers where each element is the difference of corresponding elements (first minus second)",
    "function_name": "elementwise_subtraction",
    "code_1": "def elementwise_subtraction(list1, list2):\n    \"\"\"Subtracts elements of list2 from list1 element-wise.\"\"\"\n    if len(list1) != len(list2):\n        raise ValueError(\"Both lists must have the same length\")\n    return [a - b for a, b in zip(list1, list2)]",
    "code_2": "def elementwise_subtraction(list1, list2):\n    \"\"\"Subtracts elements of list2 from list1 element-wise using a functional approach.\"\"\"\n    if len(list1) != len(list2):\n        raise ValueError(\"Both lists must have the same length\")\n    import operator\n    return list(map(operator.sub, list1, list2))\n"
  },
  {
    "task": "Translate Characters",
    "input": "string, dictionary mapping single characters to replacement characters",
    "output": "new string with characters replaced according to the mapping",
    "function_name": "translate_characters",
    "code_1": "def translate_characters(s, mapping):\n    \"\"\"Replace characters in string s according to the mapping dict.\"\"\"\n    return ''.join(mapping.get(ch, ch) for ch in s)",
    "code_2": "def translate_characters(s, mapping):\n    \"\"\"Replace characters in string s according to the mapping dict using str.translate.\"\"\"\n    # Build a translation table from the mapping dict\n    table = str.maketrans(mapping)\n    # Apply the translation table to the string\n    return s.translate(table)"
  },
  {
    "task": "Round List Values",
    "input": "list of floats, integer number of decimal places",
    "output": "list of floats each rounded to the specified number of decimal places",
    "function_name": "round_list_values",
    "code_1": "def round_list_values(values, decimal_places):\n    \"\"\"Round each float in the list to the specified number of decimal places.\"\"\"\n    return [round(v, decimal_places) for v in values]",
    "code_2": "def round_list_values(values, decimal_places): fmt = f\"{{:.{decimal_places}f}}\"; return list(map(lambda v: float(fmt.format(v)), values))"
  },
  {
    "task": "Insert Element at Positions",
    "input": "list of elements, single element, list of integer positions",
    "output": "new list with the element inserted at each specified position in the original order",
    "function_name": "insert_element_at_positions",
    "code_1": "def insert_element_at_positions(lst, element, positions):\n    \"\"\"\n    Return a new list with `element` inserted into `lst` at each index in `positions`.\n    Insertions are based on the original positions, so we sort them to adjust offsets correctly.\n    \"\"\"\n    new_lst = lst.copy()\n    offset = 0\n    for pos in sorted(positions):\n        # Compute insertion index accounting for prior insertions\n        idx = pos + offset\n        # Clamp to valid range\n        if idx < 0:\n            idx = 0\n        elif idx > len(new_lst):\n            idx = len(new_lst)\n        new_lst.insert(idx, element)\n        offset += 1\n    return new_lst",
    "code_2": "def insert_element_at_positions(lst, element, positions):\n    from collections import Counter\n    n = len(lst)\n    # clamp each position to [0, n]\n    clamped = [min(max(p, 0), n) for p in positions]\n    counts = Counter(clamped)\n    result = []\n    # insert before each original element\n    for i, item in enumerate(lst):\n        result.extend([element] * counts.get(i, 0))\n        result.append(item)\n    # insert any remaining at the end\n    result.extend([element] * counts.get(n, 0))\n    return result"
  },
  {
    "task": "Average of Unique Values",
    "input": "list of numbers",
    "output": "float representing the average of only the unique numbers in the list",
    "function_name": "average_unique",
    "code_1": "def average_unique(numbers):\n    \"\"\"Return the average of unique numbers in the list. If the list is empty, return 0.0.\"\"\"\n    unique_numbers = set(numbers)\n    if not unique_numbers:\n        return 0.0\n    return sum(unique_numbers) / len(unique_numbers)",
    "code_2": "def average_unique(numbers):\n    from statistics import mean, StatisticsError\n    try:\n        return mean(set(numbers))\n    except StatisticsError:\n        return 0.0"
  },
  {
    "task": "Snake Case to Title Case",
    "input": "string in snake_case",
    "output": "string converted to Title Case (spaces and capitalized words)",
    "function_name": "snake_to_title",
    "code_1": "def snake_to_title(snake_str):\n    parts = snake_str.split('_')\n    title_parts = [word.capitalize() for word in parts if word]\n    return ' '.join(title_parts)",
    "code_2": "def snake_to_title(snake_str):\n    import re\n    # remove leading/trailing underscores and collapse multiples into one space\n    spaced = re.sub(r'_+', ' ', snake_str.strip('_'))\n    # title-case the result\n    return spaced.title()\n"
  },
  {
    "task": "Byte Size Formatter",
    "input": "integer (number of bytes)",
    "output": "string representing size in appropriate unit (B, KB, MB, GB) with one decimal",
    "function_name": "format_byte_size",
    "code_1": "def format_byte_size(num_bytes):\n    \"\"\"Convert a byte value to human-readable format with one decimal place (B, KB, MB, GB).\"\"\"\n    thresholds = [(1<<30, 'GB'), (1<<20, 'MB'), (1<<10, 'KB'), (1, 'B')]\n    for factor, suffix in thresholds:\n        if num_bytes >= factor:\n            value = num_bytes / factor\n            return f'{value:.1f}{suffix}'\n    return '0.0B'",
    "code_2": "def format_byte_size(num_bytes):\n    import math\n    if num_bytes <= 0:\n        return '0.0B'\n    units = ['B', 'KB', 'MB', 'GB']\n    exp = min(int(math.log(num_bytes, 1024)), len(units) - 1)\n    value = num_bytes / (1024 ** exp)\n    return f\"{value:.1f}{units[exp]}\""
  },
  {
    "task": "Unique Char Count",
    "input": "list of strings",
    "output": "dictionary mapping each input string to the count of unique characters it contains",
    "function_name": "unique_char_count",
    "code_1": "def unique_char_count(strings):\n    \"\"\"Return a dictionary mapping each string to its count of unique characters.\"\"\"\n    return {s: len(set(s)) for s in strings}",
    "code_2": "def unique_char_count(strings):\n    result = {}\n    for s in strings:\n        seen = {}\n        for ch in s:\n            seen[ch] = True\n        result[s] = len(seen)\n    return result\n"
  },
  {
    "task": "Max Consecutive Vowels",
    "input": "string",
    "output": "integer",
    "function_name": "max_consecutive_vowels",
    "code_1": "def max_consecutive_vowels(s):\n    vowels = set('aeiouAEIOU')\n    max_count = 0\n    count = 0\n    for char in s:\n        if char in vowels:\n            count += 1\n            if count > max_count:\n                max_count = count\n        else:\n            count = 0\n    return max_count",
    "code_2": "import re\n\ndef max_consecutive_vowels(s):\n    # find all contiguous vowel sequences\n    sequences = re.findall(r\"[aeiouAEIOU]+\", s)\n    # return the length of the longest sequence, or 0 if none\n    return max((len(seq) for seq in sequences), default=0)"
  },
  {
    "task": "Binary List to Integer",
    "input": "list of integers (each 0 or 1)",
    "output": "integer",
    "function_name": "binary_list_to_int",
    "code_1": "def binary_list_to_int(bin_list):\n    result = 0\n    for bit in bin_list:\n        result = (result << 1) | bit\n    return result",
    "code_2": "def binary_list_to_int(bin_list):\n    # Compute value by shifting each bit according to its position\n    return sum(bit << (len(bin_list) - i - 1) for i, bit in enumerate(bin_list))"
  },
  {
    "task": "Remove Palindromes",
    "input": "list of strings",
    "output": "list of strings",
    "function_name": "remove_palindromes",
    "code_1": "def remove_palindromes(strings):\n    \"\"\"Return a list with all palindromic strings removed.\"\"\"\n    return [s for s in strings if s != s[::-1]]",
    "code_2": "def remove_palindromes(strings):\n    def is_palindrome(s):\n        # check characters from both ends moving inward\n        for i in range(len(s) // 2):\n            if s[i] != s[-i-1]:\n                return False\n        return True\n\n    # filter out palindromic strings\n    return list(filter(lambda s: not is_palindrome(s), strings))"
  },
  {
    "task": "Alternate Case Conversion",
    "input": "string",
    "output": "string",
    "function_name": "alternate_case_conversion",
    "code_1": "def alternate_case_conversion(s):\n    \"\"\"Convert the input string to alternating case: characters at even indices are uppercase, odd indices lowercase.\"\"\"\n    result = []\n    for i, c in enumerate(s):\n        if i % 2 == 0:\n            result.append(c.upper())\n        else:\n            result.append(c.lower())\n    return ''.join(result)",
    "code_2": "def alternate_case_conversion(s):\n    import itertools\n    casers = itertools.cycle([str.upper, str.lower])\n    return ''.join(fn(ch) for fn, ch in zip(casers, s))"
  },
  {
    "task": "Reverse Word Order",
    "input": "string (words separated by spaces)",
    "output": "string",
    "function_name": "reverse_words",
    "code_1": "def reverse_words(s):\n    \"\"\"Reverse the order of words in a string separated by spaces.\"\"\"\n    return ' '.join(s.split()[::-1])",
    "code_2": "def reverse_words(s):\n    import collections\n    dq = collections.deque()\n    word = ''\n    for ch in s:\n        if ch == ' ':\n            if word:\n                dq.appendleft(word)\n                word = ''\n        else:\n            word += ch\n    if word:\n        dq.appendleft(word)\n    return ' '.join(dq)"
  },
  {
    "task": "Sum of Unique Elements",
    "input": "list of integers",
    "output": "integer",
    "function_name": "sum_unique_elements",
    "code_1": "def sum_unique_elements(nums):\n    from collections import Counter\n    cnt = Counter(nums)\n    return sum(val for val, c in cnt.items() if c == 1)",
    "code_2": "def sum_unique_elements(nums):\n    seen = set()\n    dupes = set()\n    for num in nums:\n        if num in seen:\n            dupes.add(num)\n        else:\n            seen.add(num)\n    # unique elements are those seen once\n    return sum(seen - dupes)"
  },
  {
    "task": "Move Zeros to End",
    "input": "list of integers",
    "output": "list of integers",
    "function_name": "move_zeros_to_end",
    "code_1": "def move_zeros_to_end(nums):\n    non_zero = [x for x in nums if x != 0]\n    zeros = [0] * (len(nums) - len(non_zero))\n    return non_zero + zeros",
    "code_2": "def move_zeros_to_end(nums):\n    # Use sorting with a boolean key to push zeros to the end, preserving relative order\n    return sorted(nums, key=lambda x: x == 0)"
  },
  {
    "task": "Digit to Word Conversion",
    "input": "string (may contain digits)",
    "output": "string",
    "function_name": "convert_digits_to_words",
    "code_1": "def convert_digits_to_words(s):\n    \"\"\"Replace every digit in the input string with its word equivalent.\"\"\"\n    digit_map = {\n        '0': 'zero',\n        '1': 'one',\n        '2': 'two',\n        '3': 'three',\n        '4': 'four',\n        '5': 'five',\n        '6': 'six',\n        '7': 'seven',\n        '8': 'eight',\n        '9': 'nine'\n    }\n    import re\n    return re.sub(r\"\\d\", lambda m: digit_map[m.group()], s)",
    "code_2": "def convert_digits_to_words(s):\n    words = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine']\n    return ''.join(words[ord(ch) - ord('0')] if '0' <= ch <= '9' else ch for ch in s)"
  },
  {
    "task": "Move Vowels to Front",
    "input": "a string",
    "output": "a string with all vowels moved to the front, preserving original order",
    "function_name": "move_vowels_to_front",
    "code_1": "def move_vowels_to_front(s):\n    vowels = []\n    others = []\n    for c in s:\n        if c in 'aeiouAEIOU':\n            vowels.append(c)\n        else:\n            others.append(c)\n    return ''.join(vowels + others)",
    "code_2": "import re\n\ndef move_vowels_to_front(s):\n    # Find all vowels in order\n    vowels = ''.join(re.findall(r'[aeiouAEIOU]', s))\n    # Remove vowels from original string\n    others = re.sub(r'[aeiouAEIOU]', '', s)\n    return vowels + others"
  },
  {
    "task": "First Repeated Character",
    "input": "string",
    "output": "single character (or empty if none)",
    "function_name": "first_repeated_character",
    "code_1": "def first_repeated_character(s):\n    \"\"\"Return the first character in the string that repeats. If none, return an empty string.\"\"\"\n    seen = set()\n    for c in s:\n        if c in seen:\n            return c\n        seen.add(c)\n    return \"\"",
    "code_2": "def first_repeated_character(s):\n    for i, c in enumerate(s):\n        if s.find(c, i+1) != -1:\n            return c\n    return \"\""
  },
  {
    "task": "Longest Consecutive Run",
    "input": "list of integers",
    "output": "integer",
    "function_name": "longest_consecutive_run",
    "code_1": "def longest_consecutive_run(nums):\n    \"\"\"\n    Returns the length of the longest run of consecutive integers in the list nums.\n    \"\"\"\n    num_set = set(nums)\n    longest = 0\n    for num in num_set:\n        # only start counting if 'num' is the start of a sequence\n        if num - 1 not in num_set:\n            current = num\n            length = 1\n            # extend the sequence\n            while current + 1 in num_set:\n                current += 1\n                length += 1\n            longest = max(longest, length)\n    return longest",
    "code_2": "def longest_consecutive_run(nums):\n    if not nums:\n        return 0\n    # sort unique values and scan for runs\n    sorted_vals = sorted(set(nums))\n    longest = curr = 1\n    for prev, curr_val in zip(sorted_vals, sorted_vals[1:]):\n        if curr_val == prev + 1:\n            curr += 1\n        else:\n            longest = max(longest, curr)\n            curr = 1\n    return max(longest, curr)"
  },
  {
    "task": "Kth Largest Unique Element",
    "input": "a list of numbers and an integer k",
    "output": "the kth largest unique number or None if there are fewer than k unique numbers",
    "function_name": "kth_largest_unique",
    "code_1": "def kth_largest_unique(nums, k):\n    \"\"\"\n    Return the k-th largest unique element from nums, or None if fewer than k unique elements.\n    \"\"\"\n    # Get unique numbers\n    unique_nums = list(set(nums))\n    # Sort in descending order\n    unique_nums.sort(reverse=True)\n    # Check if we have enough unique elements\n    if k <= len(unique_nums):\n        return unique_nums[k-1]\n    return None",
    "code_2": "def kth_largest_unique(nums, k):\n    import heapq\n    # Use a heap to get the k largest unique values\n    unique_vals = set(nums)\n    top_k = heapq.nlargest(k, unique_vals)\n    # If we have k elements, the last in the list is the k-th largest\n    return top_k[-1] if len(top_k) == k else None"
  },
  {
    "task": "Validate US Phone Number",
    "input": "a string",
    "output": "a boolean indicating whether it\u2019s a valid US phone number (e.g., \u201c(123) 456-7890\u201d, \u201c123-456-7890\u201d or \u201c1234567890\u201d)",
    "function_name": "is_valid_us_phone_number",
    "code_1": "def is_valid_us_phone_number(s: str) -> bool:\n    import re\n    pattern = r\"^(?:\\(\\d{3}\\)\\s?\\d{3}-\\d{4}|\\d{3}-\\d{3}-\\d{4}|\\d{10})$\"\n    return bool(re.fullmatch(pattern, s))",
    "code_2": "def is_valid_us_phone_number(s: str) -> bool:\n    # Plain 10 digits\n    if s.isdigit():\n        return len(s) == 10\n\n    # Format with parentheses: (123) 456-7890 or (123)456-7890\n    if s.startswith('(') and ')' in s:\n        # Exactly one pair of parentheses in correct positions\n        if s.count('(') != 1 or s.count(')') != 1 or s[4] != ')':\n            return False\n        # Slice off the area code\n        tail = s[5:]\n        # Optional space after ')'\n        if tail.startswith(' '):\n            tail = tail[1:]\n        # Expect 3 digits, a hyphen, then 4 digits\n        return len(tail) == 8 and tail[3] == '-' and tail[:3].isdigit() and tail[4:].isdigit()\n\n    # Format with hyphens only: 123-456-7890\n    parts = s.split('-')\n    if len(parts) == 3 and all(p.isdigit() for p in parts):\n        return len(parts[0]) == 3 and len(parts[1]) == 3 and len(parts[2]) == 4\n\n    return False"
  },
  {
    "task": "Pair Sum Closest to Zero",
    "input": "a list of integers",
    "output": "a tuple of two integers whose sum is closest to zero",
    "function_name": "pair_sum_closest_to_zero",
    "code_1": "def pair_sum_closest_to_zero(nums):\n    \"\"\"\n    Given a list of integers, return a tuple of two integers whose sum is closest to zero.\n    If the list has fewer than 2 elements, return None.\n    \"\"\"\n    if len(nums) < 2:\n        return None\n    nums_sorted = sorted(nums)\n    left, right = 0, len(nums_sorted) - 1\n    closest_sum = float('inf')\n    result = (nums_sorted[left], nums_sorted[right])\n    while left < right:\n        current_sum = nums_sorted[left] + nums_sorted[right]\n        # Update closest pair if needed\n        if abs(current_sum) < abs(closest_sum):\n            closest_sum = current_sum\n            result = (nums_sorted[left], nums_sorted[right])\n        # Move pointers\n        if current_sum > 0:\n            right -= 1\n        else:\n            left += 1\n    return result",
    "code_2": "def pair_sum_closest_to_zero(nums):\n    import itertools\n    if len(nums) < 2:\n        return None\n    # Find the pair with the minimum absolute sum using combinations\n    return min(itertools.combinations(nums, 2), key=lambda p: abs(p[0] + p[1]))"
  },
  {
    "task": "Max Depth of Nested List",
    "input": "a list that may contain nested lists",
    "output": "an integer representing the maximum depth of nesting",
    "function_name": "max_depth",
    "code_1": "def max_depth(nested_list):\n    \"\"\"Return the maximum depth of nesting in a list.\"\"\"\n    # Base depth is 1 for the outermost list\n    max_d = 1\n    for element in nested_list:\n        if isinstance(element, list):\n            # Compute depth of this element and add 1 for the current level\n            d = max_depth(element) + 1\n            if d > max_d:\n                max_d = d\n    return max_d",
    "code_2": "def max_depth(nested_list):\n    max_d = 1\n    stack = [(nested_list, 1)]\n    while stack:\n        current, depth = stack.pop()\n        if depth > max_d:\n            max_d = depth\n        for elem in current:\n            if isinstance(elem, list):\n                stack.append((elem, depth + 1))\n    return max_d"
  },
  {
    "task": "Remove Falsy Values",
    "input": "a list of values",
    "output": "a list with all falsy values (e.g., 0, \"\", None, False) removed",
    "function_name": "remove_falsy_values",
    "code_1": "def remove_falsy_values(values):\n    \"\"\"Remove all falsy values (0, \"\", None, False) from the input list.\"\"\"\n    return [v for v in values if v]",
    "code_2": "def remove_falsy_values(values):\n    \"\"\"Filter out all falsy elements (e.g., 0, '', None, False) using built-in filter.\"\"\"\n    return list(filter(bool, values))"
  },
  {
    "task": "Alternating Positive/Negative Check",
    "input": "a list of integers",
    "output": "a boolean indicating whether the sign of the numbers alternates (positive/negative) throughout the list",
    "function_name": "is_alternating_signs",
    "code_1": "def is_alternating_signs(nums):\n    \"\"\"Return True if the list nums alternates between positive and negative values.\"\"\"\n    if not nums:\n        return True\n    prev = nums[0]\n    # zero is considered invalid for alternation\n    if prev == 0:\n        return False\n    for num in nums[1:]:\n        if num == 0:\n            return False\n        # check if signs are the same: both positive or both negative\n        if (num > 0) == (prev > 0):\n            return False\n        prev = num\n    return True",
    "code_2": "def is_alternating_signs(nums):\n    # zeros invalidate alternation immediately\n    if any(n == 0 for n in nums):\n        return False\n    # check that each adjacent pair has opposite signs\n    return all((a > 0) != (b > 0) for a, b in zip(nums, nums[1:]))"
  },
  {
    "task": "First N Happy Numbers",
    "input": "an integer n",
    "output": "a list of the first n happy numbers",
    "function_name": "first_n_happy_numbers",
    "code_1": "def first_n_happy_numbers(n):\n    def is_happy(num):\n        seen = set()\n        while num != 1 and num not in seen:\n            seen.add(num)\n            num = sum(int(d) ** 2 for d in str(num))\n        return num == 1\n\n    result = []\n    current = 1\n    while len(result) < n:\n        if is_happy(current):\n            result.append(current)\n        current += 1\n    return result",
    "code_2": "def first_n_happy_numbers(n):\n    import itertools\n\n    def digit_square_sum(x):\n        return sum(int(d) ** 2 for d in str(x))\n\n    def is_happy(num):\n        # Floyd's cycle-finding algorithm\n        slow = digit_square_sum(num)\n        fast = digit_square_sum(digit_square_sum(num))\n        while slow != fast:\n            slow = digit_square_sum(slow)\n            fast = digit_square_sum(digit_square_sum(fast))\n        return slow == 1\n\n    # Generate happy numbers lazily and take the first n\n    gen = (i for i in itertools.count(1) if is_happy(i))\n    return list(itertools.islice(gen, n))"
  },
  {
    "task": "Alternate Merge Lists",
    "input": "two lists of equal length",
    "output": "a single list with elements alternating from each input list",
    "function_name": "alternate_merge_lists",
    "code_1": "def alternate_merge_lists(list1, list2):\n    \"\"\"\n    Merge two lists of equal length by alternating their elements.\n    Args:\n        list1 (list): First input list.\n        list2 (list): Second input list.\n    Returns:\n        list: A new list with elements alternating from list1 and list2.\n    \"\"\"\n    merged = []\n    for a, b in zip(list1, list2):\n        merged.append(a)\n        merged.append(b)\n    return merged",
    "code_2": "def alternate_merge_lists(list1, list2):\n    from itertools import chain\n    return list(chain.from_iterable(zip(list1, list2)))"
  },
  {
    "task": "Binary Gap",
    "input": "an integer",
    "output": "an integer representing the length of the longest sequence of consecutive zeros surrounded by ones in its binary representation",
    "function_name": "binary_gap",
    "code_1": "def binary_gap(n):\n    bin_str = bin(n)[2:]\n    max_gap = 0\n    current_gap = 0\n    for char in bin_str:\n        if char == '0':\n            current_gap += 1\n        else:\n            if current_gap > max_gap:\n                max_gap = current_gap\n            current_gap = 0\n    return max_gap",
    "code_2": "import re\n\ndef binary_gap(n):\n    b = bin(n)[2:]\n    # find all zero-sequences between ones using regex\n    gaps = re.findall(r'(?<=1)(0+)(?=1)', b)\n    # return the length of the longest gap or 0 if none\n    return max((len(g) for g in gaps), default=0)"
  },
  {
    "task": "Count Numeric Substrings",
    "input": "a string",
    "output": "an integer representing the number of contiguous digit substrings",
    "function_name": "count_numeric_substrings",
    "code_1": "def count_numeric_substrings(s):\n    count = 0\n    in_num = False\n    for ch in s:\n        if ch.isdigit():\n            if not in_num:\n                count += 1\n                in_num = True\n        else:\n            in_num = False\n    return count",
    "code_2": "from itertools import groupby\n\ndef count_numeric_substrings(s):\n    return sum(1 for is_digit, _ in groupby(s, key=str.isdigit) if is_digit)"
  },
  {
    "task": "Largest Square \u2264 N",
    "input": "an integer n",
    "output": "the largest perfect square integer less than or equal to n",
    "function_name": "largest_square_leq",
    "code_1": "import math\n\ndef largest_square_leq(n):\n    \"\"\"\n    Return the largest perfect square integer less than or equal to n.\n    If n is negative, returns None.\n    \"\"\"\n    if n < 0:\n        return None\n    return math.isqrt(n) ** 2",
    "code_2": "def largest_square_leq(n):\n    \"\"\"\n    Return the largest perfect square integer less than or equal to n.\n    If n is negative, returns None.\n    Uses a binary search approach to find the integer square root.\n    \"\"\"\n    if n < 0:\n        return None\n    low, high = 0, n\n    best = 0\n    while low <= high:\n        mid = (low + high) // 2\n        sq = mid * mid\n        if sq <= n:\n            best = mid\n            low = mid + 1\n        else:\n            high = mid - 1\n    return best * best"
  },
  {
    "task": "DNA to RNA Transcription",
    "input": "a DNA string composed of characters A, T, C, G",
    "output": "a string with all T characters replaced by U",
    "function_name": "dna_to_rna",
    "code_1": "def dna_to_rna(dna):\n    return dna.replace('T', 'U')",
    "code_2": "def dna_to_rna(dna):\n    # Build the RNA string by replacing T with U on the fly\n    return ''.join('U' if nucleotide == 'T' else nucleotide for nucleotide in dna)"
  },
  {
    "task": "Double Letter Words Finder",
    "input": "a sentence (string)",
    "output": "a list of words containing at least one repeated letter consecutively",
    "function_name": "find_double_letter_words",
    "code_1": "def find_double_letter_words(sentence):\n    import re\n    # Extract words (alphanumeric sequences)\n    words = re.findall(r\"\\b\\w+\\b\", sentence)\n    # Filter words with at least one repeated consecutive letter\n    result = [word for word in words if re.search(r\"(.)\\1\", word, re.IGNORECASE)]\n    return result",
    "code_2": "def find_double_letter_words(sentence):\n    import itertools, string\n    # Split on whitespace and strip common punctuation\n    result = []\n    for raw in sentence.split():\n        word = raw.strip(string.punctuation)\n        if not word:\n            continue\n        # Check for any consecutive identical letters (case-insensitive)\n        lower = word.lower()\n        if any(len(list(group)) > 1 for _, group in itertools.groupby(lower)):\n            result.append(word)\n    return result"
  },
  {
    "task": "Vowel Count per Word",
    "input": "a sentence (string)",
    "output": "a dictionary mapping each word to its count of vowels",
    "function_name": "vowel_count_per_word",
    "code_1": "def vowel_count_per_word(sentence):\n    words = sentence.split()\n    vowels = set(\"aeiouAEIOU\")\n    vowel_counts = {}\n    for word in words:\n        count = sum(1 for char in word if char in vowels)\n        vowel_counts[word] = count\n    return vowel_counts",
    "code_2": "def vowel_count_per_word(sentence):\n    import re\n    vowel_pattern = re.compile(r\"[aeiou]\", re.IGNORECASE)\n    return {word: len(vowel_pattern.findall(word)) for word in sentence.split()}"
  },
  {
    "task": "Fixed-Width Binary Conversion",
    "input": "an integer and a width (integer)",
    "output": "a binary string of the given width representing the integer (padded with leading zeros)",
    "function_name": "fixed_width_binary",
    "code_1": "def fixed_width_binary(value, width):\n    \"\"\"Return a binary string of the given width, padded with leading zeros.\"\"\"\n    if value < 0:\n        raise ValueError(\"Negative values not supported\")\n    return format(value, 'b').zfill(width)",
    "code_2": "def fixed_width_binary(value, width):\n    if value < 0:\n        raise ValueError('Negative values not supported')\n    bits = ''\n    v = value\n    if v == 0:\n        bits = '0'\n    else:\n        while v:\n            bits = ('1' if (v & 1) else '0') + bits\n            v >>= 1\n    if len(bits) < width:\n        bits = '0' * (width - len(bits)) + bits\n    return bits"
  },
  {
    "task": "Sliding Window Range",
    "input": "a list of numbers and an integer window size",
    "output": "a list of ranges (max\u2212min) for each sliding window",
    "function_name": "sliding_window_range",
    "code_1": "def sliding_window_range(nums, k):\n    from collections import deque\n    if k <= 0:\n        raise ValueError(\"Window size must be positive\")\n    n = len(nums)\n    if k > n:\n        return []\n    max_dq = deque()\n    min_dq = deque()\n    result = []\n    for i in range(n):\n        # Remove indices outside the current window\n        while max_dq and max_dq[0] <= i - k:\n            max_dq.popleft()\n        while min_dq and min_dq[0] <= i - k:\n            min_dq.popleft()\n        # Maintain decreasing deque for max\n        while max_dq and nums[max_dq[-1]] < nums[i]:\n            max_dq.pop()\n        max_dq.append(i)\n        # Maintain increasing deque for min\n        while min_dq and nums[min_dq[-1]] > nums[i]:\n            min_dq.pop()\n        min_dq.append(i)\n        # Record the range when the first full window is reached\n        if i >= k - 1:\n            result.append(nums[max_dq[0]] - nums[min_dq[0]])\n    return result",
    "code_2": "def sliding_window_range(nums, k):\n    if k <= 0:\n        raise ValueError(\"Window size must be positive\")\n    n = len(nums)\n    if k > n:\n        return []\n    from bisect import bisect_left, insort\n    # Start with a sorted window of the first k elements\n    window = sorted(nums[:k])\n    result = [window[-1] - window[0]]\n    # Slide the window through the rest of nums\n    for i in range(k, n):\n        # Remove the element that slides out\n        outgoing = nums[i - k]\n        idx = bisect_left(window, outgoing)\n        window.pop(idx)\n        # Insert the new element in sorted order\n        insort(window, nums[i])\n        # Record current range\n        result.append(window[-1] - window[0])\n    return result"
  },
  {
    "task": "Toeplitz Matrix Check",
    "input": "a matrix represented as a list of lists",
    "output": "a boolean indicating whether each descending diagonal left-to-right is constant",
    "function_name": "is_toeplitz_matrix",
    "code_1": "def is_toeplitz_matrix(matrix):\n    if not matrix or not matrix[0]:\n        return True\n    rows, cols = len(matrix), len(matrix[0])\n    for i in range(1, rows):\n        for j in range(1, cols):\n            if matrix[i][j] != matrix[i-1][j-1]:\n                return False\n    return True",
    "code_2": "def is_toeplitz_matrix(matrix):\n    seen = {}\n    for i, row in enumerate(matrix):\n        for j, val in enumerate(row):\n            key = i - j\n            if key in seen:\n                if seen[key] != val:\n                    return False\n            else:\n                seen[key] = val\n    return True\n"
  },
  {
    "task": "Ordinal Suffix",
    "input": "integer n",
    "output": "string representing n with its ordinal suffix (e.g., \"1st\", \"2nd\", \"3rd\")",
    "function_name": "ordinal_suffix",
    "code_1": "def ordinal_suffix(n):\n    # Determine the ordinal suffix for an integer\n    if 11 <= n % 100 <= 13:\n        suffix = \"th\"\n    else:\n        suffix = {1: \"st\", 2: \"nd\", 3: \"rd\"}.get(n % 10, \"th\")\n    return f\"{n}{suffix}\"",
    "code_2": "def ordinal_suffix(n):\n    # Build a lookup list for last-digit suffixes\n    suffixes = ['th', 'st', 'nd', 'rd'] + ['th'] * 6\n    # 'teens' always use 'th'\n    if n % 100 in (11, 12, 13):\n        suf = 'th'\n    else:\n        suf = suffixes[n % 10]\n    return f\"{n}{suf}\""
  },
  {
    "task": "Move Uppercase to Front",
    "input": "string",
    "output": "string with all uppercase letters moved to the front in their original order, followed by the remaining characters in original order",
    "function_name": "move_uppercase_to_front",
    "code_1": "def move_uppercase_to_front(s):\n    \"\"\"\n    Move all uppercase letters in the string s to the front, preserving their relative order,\n    followed by the remaining characters in their original order.\n    \"\"\"\n    uppercase_chars = []\n    other_chars = []\n    for ch in s:\n        if ch.isupper():\n            uppercase_chars.append(ch)\n        else:\n            other_chars.append(ch)\n    return ''.join(uppercase_chars + other_chars)",
    "code_2": "import re\n\ndef move_uppercase_to_front(s):\n    # Extract uppercase letters and the rest using regex\n    uppers = re.findall(r\"[A-Z]\", s)\n    rest = re.sub(r\"[A-Z]\", \"\", s)\n    return ''.join(uppers) + rest"
  },
  {
    "task": "Remove URLs",
    "input": "a string containing words and URLs starting with 'http://' or 'https://'",
    "output": "the string with all URLs removed",
    "function_name": "remove_urls",
    "code_1": "import re\n\ndef remove_urls(text):\n    \"\"\"Remove all URLs starting with http:// or https:// from the input string.\"\"\"\n    return re.sub(r'https?://\\S+', '', text)",
    "code_2": "def remove_urls(text):\n    result = []\n    i = 0\n    n = len(text)\n    while i < n:\n        if text.startswith('http://', i) or text.startswith('https://', i):\n            # Skip the URL until the next whitespace\n            j = i\n            while j < n and not text[j].isspace():\n                j += 1\n            i = j\n        else:\n            result.append(text[i])\n            i += 1\n    return ''.join(result)"
  },
  {
    "task": "Capitalize Sentences",
    "input": "a paragraph string with sentences ending in '.', '!' or '?'",
    "output": "the string with the first letter of each sentence capitalized",
    "function_name": "capitalize_sentences",
    "code_1": "def capitalize_sentences(text):\n    import re\n    def repl(match):\n        return match.group(1) + match.group(2).upper()\n    return re.sub(r'(^|(?<=[\\.\\!\\?]\\s*))([a-z])', repl, text)",
    "code_2": "def capitalize_sentences(text):\n    result = []\n    cap_next = True\n    for ch in text:\n        if cap_next and ch.isalpha():\n            result.append(ch.upper())\n            cap_next = False\n        else:\n            result.append(ch)\n        if ch in '.!?':\n            cap_next = True\n    return ''.join(result)"
  },
  {
    "task": "Balanced Brackets",
    "input": "string containing characters '(', ')', '{', '}', '[' and ']'",
    "output": "boolean indicating whether the brackets in the string are properly balanced and nested",
    "function_name": "is_balanced_brackets",
    "code_1": "def is_balanced_brackets(s):\n    stack = []\n    mapping = {')': '(', '}': '{', ']': '['}\n    for char in s:\n        if char in mapping.values():\n            stack.append(char)\n        elif char in mapping:\n            if not stack or stack.pop() != mapping[char]:\n                return False\n    return not stack",
    "code_2": "def is_balanced_brackets(s):\n    prev = None\n    while prev != s:\n        prev = s\n        for pair in ['()', '[]', '{}']:\n            s = s.replace(pair, '')\n    return s == ''\n"
  },
  {
    "task": "String Prefixes",
    "input": "string",
    "output": "list of all prefixes of the input string, from the first character up to the full string",
    "function_name": "get_prefixes",
    "code_1": "def get_prefixes(s):\n    \"\"\"Return a list of all prefixes of the input string.\"\"\"\n    return [s[:i] for i in range(1, len(s) + 1)]",
    "code_2": "def get_prefixes(s):\n    from itertools import accumulate\n    # Use accumulate to build prefixes by concatenating characters\n    return list(accumulate(s, lambda a, b: a + b))"
  },
  {
    "task": "Arithmetic Sequence Check",
    "input": "list of numbers",
    "output": "boolean indicating whether the numbers form an arithmetic sequence (constant difference)",
    "function_name": "is_arithmetic_sequence",
    "code_1": "def is_arithmetic_sequence(seq):\n    \"\"\"Return True if the list of numbers forms an arithmetic sequence.\"\"\"\n    if len(seq) < 2:\n        return True\n    diff = seq[1] - seq[0]\n    for i in range(2, len(seq)):\n        if seq[i] - seq[i-1] != diff:\n            return False\n    return True",
    "code_2": "def is_arithmetic_sequence(seq):\n    \"\"\"Return True if the list of numbers forms an arithmetic sequence.\"\"\"\n    if len(seq) < 2:\n        return True\n    # compute all consecutive differences\n    diffs = [b - a for a, b in zip(seq, seq[1:])]\n    # it's arithmetic if there's only one unique difference\n    return len(set(diffs)) == 1"
  },
  {
    "task": "Highlight Repeats",
    "input": "string",
    "output": "string where each character occurring after its first appearance is replaced by '*'",
    "function_name": "highlight_repeats",
    "code_1": "def highlight_repeats(s):\n    seen = set()\n    result = []\n    for char in s:\n        if char in seen:\n            result.append('*')\n        else:\n            seen.add(char)\n            result.append(char)\n    return ''.join(result)",
    "code_2": "def highlight_repeats(s):\n    return ''.join(c if s.index(c) == i else '*' for i, c in enumerate(s))"
  },
  {
    "task": "Days in Month",
    "input": "two integers month (1\u201312) and year",
    "output": "integer number of days in that month accounting for leap years",
    "function_name": "days_in_month",
    "code_1": "def days_in_month(month, year):\n    \"\"\"\n    Return the number of days in a given month and year, accounting for leap years.\n    month: integer from 1 to 12\n    year: integer year\n    \"\"\"\n    if month == 2:\n        # Leap year if divisible by 4, but not by 100 unless also by 400\n        if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):\n            return 29\n        else:\n            return 28\n    # Months with 31 days\n    if month in [1, 3, 5, 7, 8, 10, 12]:\n        return 31\n    # Months with 30 days\n    if month in [4, 6, 9, 11]:\n        return 30\n    # Invalid month\n    raise ValueError('Invalid month')",
    "code_2": "import calendar\n\ndef days_in_month(month, year):\n    # Use calendar.monthrange to get the number of days in the month\n    try:\n        _, days = calendar.monthrange(year, month)\n        return days\n    except calendar.IllegalMonthError:\n        raise ValueError('Invalid month')\n"
  },
  {
    "task": "Consecutive Number Runs",
    "input": "list of integers",
    "output": "list of lists, each sublist being a maximal run of consecutive integers (difference of 1) from the original list",
    "function_name": "find_consecutive_runs",
    "code_1": "def find_consecutive_runs(nums):\n    \"\"\"\n    Given a list of integers, return a list of maximal runs of consecutive integers.\n    Each run is a sublist where each element differs by 1 from the previous.\n    \"\"\"\n    runs = []\n    if not nums:\n        return runs\n    current_run = [nums[0]]\n    for n in nums[1:]:\n        if n == current_run[-1] + 1:\n            current_run.append(n)\n        else:\n            runs.append(current_run)\n            current_run = [n]\n    runs.append(current_run)\n    return runs",
    "code_2": "from itertools import groupby\n\ndef find_consecutive_runs(nums):\n    \"\"\"\n    Given a list of integers, return maximal runs of consecutive numbers.\n    Uses grouping by the difference between value and its index.\n    \"\"\"\n    return [ [n for _, n in grp] for _, grp in groupby(enumerate(nums), key=lambda x: x[1] - x[0]) ]"
  },
  {
    "task": "Acronym Generator",
    "input": "A string containing multiple words",
    "output": "A string of uppercase initials of each word",
    "function_name": "generate_acronym",
    "code_1": "def generate_acronym(input_string):\n    \"\"\"\n    Generate an acronym by taking the uppercase initial of each word in the input string.\n    :param input_string: A string containing multiple words\n    :return: A string of uppercase initials\n    \"\"\"\n    # Split the string on whitespace to get words\n    words = input_string.split()\n    # Get the first character of each word, uppercase it, and join them\n    acronym = ''.join(word[0].upper() for word in words if word)\n    return acronym",
    "code_2": "import re\n\ndef generate_acronym(input_string):\n    \"\"\"\n    Generate an acronym by capturing the first letter of each word using regex word boundaries.\n    :param input_string: A string containing multiple words\n    :return: A string of uppercase initials\n    \"\"\"\n    # Find all word-initial characters via regex\n    initials = re.findall(r'\\b\\w', input_string)\n    # Uppercase and concatenate\n    return ''.join(letter.upper() for letter in initials)"
  },
  {
    "task": "Time Interval Overlap",
    "input": "two strings in the format \"HH:MM-HH:MM\" representing two time intervals",
    "output": "boolean indicating whether the two time intervals overlap",
    "function_name": "intervals_overlap",
    "code_1": "def intervals_overlap(interval1, interval2):\n    def to_minutes(t):\n        h, m = map(int, t.split(':'))\n        return h * 60 + m\n\n    start1_str, end1_str = interval1.split('-')\n    start2_str, end2_str = interval2.split('-')\n\n    start1 = to_minutes(start1_str)\n    end1 = to_minutes(end1_str)\n    start2 = to_minutes(start2_str)\n    end2 = to_minutes(end2_str)\n\n    return start1 <= end2 and start2 <= end1",
    "code_2": "def intervals_overlap(interval1, interval2):\n    from datetime import datetime\n    fmt = '%H:%M'\n    s1, e1 = [datetime.strptime(t, fmt) for t in interval1.split('-')]\n    s2, e2 = [datetime.strptime(t, fmt) for t in interval2.split('-')]\n    return max(s1, s2) <= min(e1, e2)"
  },
  {
    "task": "Next Permutation",
    "input": "list of integers",
    "output": "list of integers representing the next lexicographical permutation of the input list; if none exists, return the list sorted in ascending order",
    "function_name": "next_permutation",
    "code_1": "def next_permutation(nums):\n    arr = nums[:]\n    n = len(arr)\n    if n < 2:\n        return arr\n    # Step 1: find the largest index i such that arr[i] < arr[i+1]\n    i = n - 2\n    while i >= 0 and arr[i] >= arr[i+1]:\n        i -= 1\n    # If no such index, this is the last permutation\n    if i < 0:\n        return sorted(arr)\n    # Step 2: find the largest index j > i such that arr[j] > arr[i]\n    j = n - 1\n    while arr[j] <= arr[i]:\n        j -= 1\n    # Step 3: swap arr[i] and arr[j]\n    arr[i], arr[j] = arr[j], arr[i]\n    # Step 4: reverse the suffix starting at i+1\n    arr[i+1:] = reversed(arr[i+1:])\n    return arr",
    "code_2": "def next_permutation(nums):\n    arr = nums[:]\n    # scan from right to find pivot\n    for i in range(len(arr) - 2, -1, -1):\n        if arr[i] < arr[i + 1]:\n            pivot = arr[i]\n            # build a list of elements to the right plus pivot\n            suffix = arr[i + 1:] + [pivot]\n            suffix.sort()\n            # pick the smallest element > pivot\n            for cand in suffix:\n                if cand > pivot:\n                    next_val = cand\n                    break\n            # remove the chosen candidate\n            suffix.remove(next_val)\n            # assemble the next permutation\n            return arr[:i] + [next_val] + suffix\n    # if no pivot, return the lowest permutation\n    return sorted(arr)"
  },
  {
    "task": "Top K Longest Words",
    "input": "A string of words and an integer k",
    "output": "A list of k longest words in descending order of length",
    "function_name": "top_k_longest_words",
    "code_1": "def top_k_longest_words(s, k):\n    \"\"\"\n    Return the k longest words from the input string s, in descending order of length.\n    If there are fewer than k words, return all of them sorted by length.\n    \"\"\"\n    # Split the string into words based on whitespace\n    words = s.split()\n    # Sort words by length in descending order\n    sorted_words = sorted(words, key=len, reverse=True)\n    # Return the top k words\n    return sorted_words[:k]",
    "code_2": "import heapq\n\ndef top_k_longest_words(s, k):\n    \"\"\"\n    Return the k longest words from the input string s, in descending order of length.\n    If there are fewer than k words, return all of them sorted by length.\n    \"\"\"\n    words = s.split()\n    # Use a heap to efficiently find the k largest by length\n    return heapq.nlargest(k, words, key=len)\n"
  },
  {
    "task": "Cumulative String Concatenation",
    "input": "A list of strings",
    "output": "A list where each element is the concatenation of all strings from the start up to that position",
    "function_name": "cumulative_concat",
    "code_1": "def cumulative_concat(strings):\n    result = []\n    current = \"\"\n    for s in strings:\n        current += s\n        result.append(current)\n    return result",
    "code_2": "def cumulative_concat(strings):\n    from itertools import accumulate\n    from operator import add\n    return list(accumulate(strings, add))"
  },
  {
    "task": "Neighbor Product List",
    "input": "A list of integers",
    "output": "A list where each element (except first and last) is the product of its immediate neighbors in the original list; first and last remain unchanged",
    "function_name": "neighbor_product_list",
    "code_1": "def neighbor_product_list(lst):\n    # If list has two or fewer elements, return a copy unchanged\n    if len(lst) <= 2:\n        return lst[:]\n    # Initialize result with the first element unchanged\n    result = [lst[0]]\n    # Compute the product of neighbors for interior elements\n    for i in range(1, len(lst) - 1):\n        result.append(lst[i - 1] * lst[i + 1])\n    # Append the last element unchanged\n    result.append(lst[-1])\n    return result",
    "code_2": "def neighbor_product_list(lst):\n    # For lists too short to have inner neighbors, return a shallow copy\n    if len(lst) <= 2:\n        return lst.copy()\n    # Use slicing and zip to compute neighbor products for inner elements\n    middle = [left * right for left, right in zip(lst, lst[2:])]\n    # First and last elements remain unchanged\n    return [lst[0]] + middle + [lst[-1]]"
  },
  {
    "task": "Sum of Even Numbers at Odd Indices",
    "input": "A list of integers",
    "output": "An integer sum of elements that are even and located at odd indices",
    "function_name": "sum_even_at_odd_indices",
    "code_1": "def sum_even_at_odd_indices(nums):\n    total = 0\n    for idx, num in enumerate(nums):\n        if idx % 2 == 1 and num % 2 == 0:\n            total += num\n    return total",
    "code_2": "def sum_even_at_odd_indices(nums):\n    \"\"\"Sum even numbers located at odd indices using slicing and filter.\"\"\"\n    return sum(filter(lambda x: x % 2 == 0, nums[1::2]))"
  },
  {
    "task": "Interleave Two Strings",
    "input": "Two strings",
    "output": "A single string formed by alternating characters from each string, with leftovers appended",
    "function_name": "interleave_strings",
    "code_1": "def interleave_strings(s1, s2):\n    interwoven = ''.join(a + b for a, b in zip(s1, s2))\n    return interwoven + s1[len(s2):] + s2[len(s1):]",
    "code_2": "def interleave_strings(s1, s2):\n    result = []\n    i, j = 0, 0\n    len1, len2 = len(s1), len(s2)\n    while i < len1 or j < len2:\n        if i < len1:\n            result.append(s1[i])\n            i += 1\n        if j < len2:\n            result.append(s2[j])\n            j += 1\n    return ''.join(result)"
  },
  {
    "task": "Sum of Element Occurrence Indices",
    "input": "A list and a target element",
    "output": "An integer sum of all indices where the target element appears",
    "function_name": "sum_of_element_indices",
    "code_1": "def sum_of_element_indices(lst, target):\n    total = 0\n    for idx, val in enumerate(lst):\n        if val == target:\n            total += idx\n    return total",
    "code_2": "def sum_of_element_indices(lst, target):\n    total = 0\n    start = 0\n    while True:\n        try:\n            idx = lst.index(target, start)\n            total += idx\n            start = idx + 1\n        except ValueError:\n            break\n    return total"
  },
  {
    "task": "Sort List by Modulo",
    "input": "A list of integers and an integer m",
    "output": "The list sorted by each element\u2019s value modulo m",
    "function_name": "sort_by_modulo",
    "code_1": "def sort_by_modulo(lst, m):\n    \"\"\"\n    Sorts a list of integers by their value modulo m.\n\n    Parameters:\n    lst (list of int): The list to sort.\n    m (int): The modulus to use for sorting.\n\n    Returns:\n    list of int: The list sorted by x % m.\n    \"\"\"\n    return sorted(lst, key=lambda x: x % m)",
    "code_2": "def sort_by_modulo(lst, m):\n    \"\"\"\n    Sorts a list of integers by their value modulo m using bucket grouping.\n\n    Parameters:\n    lst (list of int): The list to sort.\n    m (int): The modulus to use for sorting.\n\n    Returns:\n    list of int: The list sorted by x % m.\n    \"\"\"\n    from collections import defaultdict\n\n    # Group elements into buckets keyed by their modulo value\n    buckets = defaultdict(list)\n    for x in lst:\n        buckets[x % m].append(x)\n\n    # Iterate through buckets in ascending order of key and flatten\n    sorted_list = []\n    for mod_val in sorted(buckets):\n        sorted_list.extend(buckets[mod_val])\n\n    return sorted_list\n"
  },
  {
    "task": "Row Sum of Matrix",
    "input": "A 2D list of numbers",
    "output": "A list of sums, one for each row in the matrix",
    "function_name": "row_sum",
    "code_1": "def row_sum(matrix):\n    \"\"\"Return a list containing the sum of each row in the given 2D list.\"\"\"\n    return [sum(row) for row in matrix]",
    "code_2": "def row_sum(matrix):\n    from functools import reduce\n    import operator\n    # Use reduce to accumulate each row's values\n    return list(map(lambda row: reduce(operator.add, row, 0), matrix))"
  },
  {
    "task": "Sum Without Extremes",
    "input": "list of integers",
    "output": "integer sum excluding the smallest and largest values once",
    "function_name": "sum_without_extremes",
    "code_1": "def sum_without_extremes(nums):\n    # If there are two or fewer elements, removal of extremes leaves nothing\n    if len(nums) <= 2:\n        return 0\n    # Sort the list to identify the smallest and largest\n    sorted_nums = sorted(nums)\n    # Sum all elements except the first (smallest) and last (largest)\n    return sum(sorted_nums[1:-1])",
    "code_2": "def sum_without_extremes(nums):\n    if len(nums) <= 2:\n        return 0\n    total = min_val = max_val = nums[0]\n    for n in nums[1:]:\n        total += n\n        if n < min_val:\n            min_val = n\n        if n > max_val:\n            max_val = n\n    return total - min_val - max_val"
  },
  {
    "task": "Substring Replacement",
    "input": "string text, string old, string new",
    "output": "string with all occurrences of old replaced by new",
    "function_name": "replace_substring",
    "code_1": "def replace_substring(text, old, new):\n    return text.replace(old, new)",
    "code_2": "def replace_substring(text, old, new):\n    parts = text.split(old)\n    return new.join(parts)"
  },
  {
    "task": "Count Even and Odd",
    "input": "list of integers",
    "output": "tuple of two integers (even_count, odd_count)",
    "function_name": "count_even_odd",
    "code_1": "def count_even_odd(numbers):\n    \"\"\"\n    Count the number of even and odd integers in a list.\n\n    Args:\n        numbers (list of int): The list of integers to analyze.\n\n    Returns:\n        tuple: A tuple (even_count, odd_count).\n    \"\"\"\n    even_count = 0\n    odd_count = 0\n    for num in numbers:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    return even_count, odd_count",
    "code_2": "def count_even_odd(numbers):\n    \"\"\"\n    Count the number of even and odd integers in a list using generator expressions.\n\n    Args:\n        numbers (list of int): The list of integers to analyze.\n\n    Returns:\n        tuple: A tuple (even_count, odd_count).\n    \"\"\"\n    even_count = sum(1 for n in numbers if n % 2 == 0)\n    odd_count = len(numbers) - even_count\n    return even_count, odd_count"
  },
  {
    "task": "Abbreviate Words",
    "input": "A string containing multiple words",
    "output": "A string where each word is abbreviated as first letter + count of middle letters + last letter",
    "function_name": "abbreviate_words",
    "code_1": "def abbreviate_words(s):\n    def abbr(word):\n        if len(word) <= 2:\n            return word\n        return word[0] + str(len(word) - 2) + word[-1]\n    return ' '.join(abbr(word) for word in s.split())",
    "code_2": "def abbreviate_words(s):\n    import re\n    return re.sub(r\"\\b\\w{3,}\\b\", lambda m: f\"{m.group()[0]}{len(m.group())-2}{m.group()[-1]}\", s)"
  },
  {
    "task": "Disjoint List Check",
    "input": "two lists",
    "output": "boolean indicating whether they share no common elements",
    "function_name": "are_disjoint",
    "code_1": "def are_disjoint(list1, list2):\n    \"\"\"\n    Return True if list1 and list2 share no common elements, False otherwise.\n    \"\"\"\n    return set(list1).isdisjoint(list2)",
    "code_2": "def are_disjoint(list1, list2):\n    \"\"\"\n    Return True if list1 and list2 share no common elements, False otherwise.\n    \"\"\"\n    set2 = set(list2)\n    for item in list1:\n        if item in set2:\n            return False\n    return True"
  },
  {
    "task": "Pair Product Finder",
    "input": "list of integers, integer target",
    "output": "list of tuples of two integers whose product equals the target",
    "function_name": "find_product_pairs",
    "code_1": "def find_product_pairs(nums, target):\n    \"\"\"\n    Find all pairs of integers in nums whose product equals target.\n    Returns a list of tuples (a, b).\n    \"\"\"\n    result = []\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if nums[i] * nums[j] == target:\n                result.append((nums[i], nums[j]))\n    return result",
    "code_2": "def find_product_pairs(nums, target):\n    from itertools import combinations\n    \"\"\"\n    Find all pairs of integers in nums whose product equals target.\n    Returns a list of tuples (a, b).\n    \"\"\"\n    return [(a, b) for a, b in combinations(nums, 2) if a * b == target]"
  },
  {
    "task": "Matrix Element-wise Sum",
    "input": "two matrices as lists of lists of numbers (same dimensions)",
    "output": "matrix (list of lists) with each element the sum of corresponding elements",
    "function_name": "matrix_elementwise_sum",
    "code_1": "def matrix_elementwise_sum(A, B):\n    \"\"\"\n    Return the element-wise sum of two matrices A and B.\n    Both A and B must be lists of lists of the same dimensions.\n    \"\"\"\n    # Validate dimensions\n    if len(A) != len(B) or any(len(rowA) != len(rowB) for rowA, rowB in zip(A, B)):\n        raise ValueError(\"Matrices must have the same dimensions\")\n    # Compute element-wise sum\n    return [[a + b for a, b in zip(rowA, rowB)] for rowA, rowB in zip(A, B)]",
    "code_2": "def matrix_elementwise_sum(A, B):\n    # Ensure matrices share dimensions\n    if len(A) != len(B) or any(len(A[i]) != len(B[i]) for i in range(len(A))):\n        raise ValueError('Matrices must have the same dimensions')\n    # Flatten both matrices into single lists\n    flatA = [elem for row in A for elem in row]\n    flatB = [elem for row in B for elem in row]\n    # Compute element-wise sums on flattened lists\n    flat_sum = [x + y for x, y in zip(flatA, flatB)]\n    # Reconstruct the summed matrix\n    cols = len(A[0]) if A else 0\n    return [flat_sum[i * cols:(i + 1) * cols] for i in range(len(A))]"
  },
  {
    "task": "Group by Digit Sum",
    "input": "list of non-negative integers",
    "output": "dictionary mapping each digit sum to a list of numbers with that sum",
    "function_name": "group_by_digit_sum",
    "code_1": "def group_by_digit_sum(nums):\n    \"\"\"\n    Group numbers by the sum of their digits.\n\n    Args:\n        nums (list of int): List of non-negative integers.\n\n    Returns:\n        dict: A mapping from digit sum to list of numbers with that sum.\n    \"\"\"\n    result = {}\n    for num in nums:\n        # Compute sum of digits\n        digit_sum = sum(int(d) for d in str(num))\n        # Append the number to the corresponding list\n        if digit_sum not in result:\n            result[digit_sum] = []\n        result[digit_sum].append(num)\n    return result",
    "code_2": "def group_by_digit_sum(nums):\n    \"\"\"\n    Group numbers by the sum of their digits using sorting and itertools.groupby.\n    \"\"\"\n    from itertools import groupby\n    # Define a key function for digit sum\n    key_func = lambda x: sum(int(ch) for ch in str(x))\n    # Sort numbers so that groupby can collect same-digit-sum runs\n    sorted_nums = sorted(nums, key=key_func)\n    # Build the result dict via comprehension\n    return {digit_sum: list(group) for digit_sum, group in groupby(sorted_nums, key=key_func)}"
  },
  {
    "task": "Max Identical Run",
    "input": "list of integers",
    "output": "tuple (value, length of the longest consecutive run of that value)",
    "function_name": "max_identical_run",
    "code_1": "def max_identical_run(lst):\n    if not lst:\n        return None, 0\n    max_val = lst[0]\n    max_len = 1\n    current_val = lst[0]\n    current_len = 1\n    for x in lst[1:]:\n        if x == current_val:\n            current_len += 1\n        else:\n            if current_len > max_len:\n                max_len = current_len\n                max_val = current_val\n            current_val = x\n            current_len = 1\n    if current_len > max_len:\n        max_len = current_len\n        max_val = current_val\n    return max_val, max_len",
    "code_2": "import itertools\n\ndef max_identical_run(lst):\n    best_val, best_len = None, 0\n    for val, group in itertools.groupby(lst):\n        run_len = sum(1 for _ in group)\n        if run_len > best_len:\n            best_val, best_len = val, run_len\n    return best_val, best_len"
  },
  {
    "task": "Convert Minutes to Hours and Minutes",
    "input": "integer total_minutes",
    "output": "tuple (hours, minutes)",
    "function_name": "convert_minutes_to_hours",
    "code_1": "def convert_minutes_to_hours(total_minutes):\n    \"\"\"\n    Convert a total number of minutes into hours and minutes.\n\n    Args:\n        total_minutes (int): Total minutes to convert.\n\n    Returns:\n        tuple: A tuple (hours, minutes).\n    \"\"\"\n    hours = total_minutes // 60\n    minutes = total_minutes % 60\n    return hours, minutes",
    "code_2": "def convert_minutes_to_hours(total_minutes):\n    \"\"\"\n    Split a total number of minutes into hours and leftover minutes.\n\n    Args:\n        total_minutes (int): The total minutes to split.\n\n    Returns:\n        tuple: (hours, minutes) after conversion.\n    \"\"\"\n    hours, minutes = divmod(total_minutes, 60)\n    return hours, minutes"
  },
  {
    "task": "List Divisors",
    "input": "integer n",
    "output": "list of all positive divisors of n",
    "function_name": "list_divisors",
    "code_1": "def list_divisors(n):\n    \"\"\"Return a sorted list of all positive divisors of n.\"\"\"\n    divisors = []\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    return sorted(divisors)",
    "code_2": "def list_divisors(n):\n    import math, itertools\n    # Factor n into its prime powers\n    temp = n\n    factors = {}\n    f = 2\n    while f * f <= temp:\n        while temp % f == 0:\n            factors[f] = factors.get(f, 0) + 1\n            temp //= f\n        f += 1 if f == 2 else 2\n    if temp > 1:\n        factors[temp] = factors.get(temp, 0) + 1\n    # Build lists of p^0, p^1, ... for each prime\n    exponents = [[p**e for e in range(exp+1)] for p, exp in factors.items()]\n    # If n == 1, there are no primes, so only divisor is 1\n    if not exponents:\n        return [1]\n    # Take the cartesian product of exponent lists and multiply\n    return sorted(math.prod(combo) for combo in itertools.product(*exponents))"
  },
  {
    "task": "Sort Names by Last Name",
    "input": "A list of strings, each \u201cFirst Last\u201d",
    "output": "A list of the same strings sorted alphabetically by last name",
    "function_name": "sort_by_last_name",
    "code_1": "def sort_by_last_name(names):\n    \"\"\"\n    Sort a list of full names by last name.\n    :param names: List of strings, each in the format \"First Last\"\n    :return: List of strings sorted by last name\n    \"\"\"\n    return sorted(names, key=lambda name: name.split()[-1])",
    "code_2": "def sort_by_last_name(names):\n    \"\"\"\n    Sort a list of full names by last name using the decorate-sort-undecorate pattern.\n    :param names: List of strings in the format \"First Last\"\n    :return: New list of names sorted by last name\n    \"\"\"\n    # Create pairs of (last_name, full_name)\n    decorated = [(full_name.split()[-1], full_name) for full_name in names]\n    # Sort by the last_name element of each tuple\n    decorated.sort(key=lambda pair: pair[0])\n    # Extract the full names in sorted order\n    return [full_name for _, full_name in decorated]"
  },
  {
    "task": "Extract Longest Number Sequence",
    "input": "A single string",
    "output": "The longest contiguous substring consisting only of digits",
    "function_name": "extract_longest_number_sequence",
    "code_1": "def extract_longest_number_sequence(s):\n    import re\n    # Find all contiguous digit sequences\n    matches = re.findall(r'\\d+', s)\n    # Return the longest sequence or an empty string if none found\n    return max(matches, key=len) if matches else ''",
    "code_2": "def extract_longest_number_sequence(s):\n    from itertools import groupby\n    longest = ''\n    for is_digit, grp in groupby(s, key=str.isdigit):\n        if is_digit:\n            seq = ''.join(grp)\n            if len(seq) > len(longest):\n                longest = seq\n    return longest"
  },
  {
    "task": "Characters at Prime Indices",
    "input": "A single string",
    "output": "A string of characters from the input whose 0-based index is a prime number",
    "function_name": "prime_index_chars",
    "code_1": "def prime_index_chars(s):\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    return ''.join(s[i] for i in range(len(s)) if is_prime(i))",
    "code_2": "def prime_index_chars(s):\n    n = len(s)\n    sieve = [False, False] + [True] * (n - 2)\n    for p in range(2, int(n**0.5) + 1):\n        if sieve[p]:\n            for multiple in range(p * p, n, p):\n                sieve[multiple] = False\n    return ''.join(ch for ch, is_p in zip(s, sieve) if is_p)"
  },
  {
    "task": "Island Count in Grid",
    "input": "A 2D list of integers (0s and 1s)",
    "output": "An integer count of \u201cislands,\u201d groups of adjacent 1s connected horizontally or vertically",
    "function_name": "count_islands",
    "code_1": "def count_islands(grid):\n    if not grid:\n        return 0\n    rows, cols = len(grid), len(grid[0])\n    visited = set()\n    def dfs(i, j):\n        stack = [(i, j)]\n        visited.add((i, j))\n        while stack:\n            x, y = stack.pop()\n            for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 1 and (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    stack.append((nx, ny))\n    count = 0\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1 and (i, j) not in visited:\n                dfs(i, j)\n                count += 1\n    return count",
    "code_2": "def count_islands(grid):\n    if not grid or not grid[0]:\n        return 0\n    rows, cols = len(grid), len(grid[0])\n    parent = {}\n\n    def find(x):\n        # path compression\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(a, b):\n        ra, rb = find(a), find(b)\n        if ra != rb:\n            parent[rb] = ra\n\n    # initialize each land cell as its own set\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1:\n                idx = i * cols + j\n                parent[idx] = idx\n\n    # union adjacent lands (only right and down to avoid duplicates)\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1:\n                idx = i * cols + j\n                for di, dj in ((1, 0), (0, 1)):\n                    ni, nj = i + di, j + dj\n                    if 0 <= ni < rows and 0 <= nj < cols and grid[ni][nj] == 1:\n                        union(idx, ni * cols + nj)\n\n    # count unique roots\n    return len({find(x) for x in parent})"
  },
  {
    "task": "Matrix Row Cumulative Sum",
    "input": "A list of lists of integers (matrix)",
    "output": "A new list of lists where each row is replaced by its cumulative sum list",
    "function_name": "row_cumulative_sum",
    "code_1": "def row_cumulative_sum(matrix):\n    result = []\n    for row in matrix:\n        cum = 0\n        new_row = []\n        for val in row:\n            cum += val\n            new_row.append(cum)\n        result.append(new_row)\n    return result",
    "code_2": "def row_cumulative_sum(matrix):\n    return [[sum(row[:i+1]) for i in range(len(row))] for row in matrix]"
  },
  {
    "task": "Day of Week Resolver",
    "input": "A string in \u201cYYYY-MM-DD\u201d format",
    "output": "The weekday name for that date (e.g., \u201cMonday\u201d)",
    "function_name": "get_weekday",
    "code_1": "def get_weekday(date_str):\n    from datetime import datetime\n    try:\n        dt = datetime.strptime(date_str, \"%Y-%m-%d\")\n    except ValueError:\n        raise ValueError(\"Invalid date format, expected YYYY-MM-DD\")\n    return dt.strftime(\"%A\")",
    "code_2": "def get_weekday(date_str):\n    # Zeller's congruence with manual validation\n    parts = date_str.split('-')\n    if len(parts) != 3:\n        raise ValueError(\"Invalid date format, expected YYYY-MM-DD\")\n    y_s, m_s, d_s = parts\n    try:\n        year = int(y_s)\n        month = int(m_s)\n        day = int(d_s)\n    except ValueError:\n        raise ValueError(\"Invalid date format, expected YYYY-MM-DD\")\n    # Validate month\n    if month < 1 or month > 12:\n        raise ValueError(\"Invalid date format, expected YYYY-MM-DD\")\n    # Determine days in month\n    if month == 2:\n        leap = (year % 400 == 0) or (year % 4 == 0 and year % 100 != 0)\n        max_day = 29 if leap else 28\n    elif month in (4, 6, 9, 11):\n        max_day = 30\n    else:\n        max_day = 31\n    if day < 1 or day > max_day:\n        raise ValueError(\"Invalid date format, expected YYYY-MM-DD\")\n    # Apply Zeller's congruence (Gregorian)\n    q = day\n    m = month\n    y = year\n    if m <= 2:\n        m += 12\n        y -= 1\n    K = y % 100\n    J = y // 100\n    h = (q + (13 * (m + 1) // 5) + K + (K // 4) + (J // 4) + 5 * J) % 7\n    names = [\"Saturday\", \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\"]\n    return names[h]"
  },
  {
    "task": "Count Smileys",
    "input": "A single string",
    "output": "An integer count of occurrences of \u201c:)\u201d or \u201c:-)\u201d",
    "function_name": "count_smileys",
    "code_1": "def count_smileys(s):\n    count = 0\n    for i in range(len(s)):\n        if s[i:i+2] == ':)':\n            count += 1\n        elif s[i:i+3] == ':-)':\n            count += 1\n    return count",
    "code_2": "import re\n\ndef count_smileys(s):\n    # use regex to match both \":)\" and \":-)\"\n    return len(re.findall(r':-?\\)', s))"
  },
  {
    "task": "Expand Character Ranges",
    "input": "A single string containing ranges like \u201ca-d\u201d or \u201c3-6\u201d",
    "output": "A string with each range replaced by its full sequence (e.g., \u201ca-d\u201d \u2192 \u201cabcd\u201d)",
    "function_name": "expand_ranges",
    "code_1": "def expand_ranges(s):\n    import re\n    def repl(match):\n        start, end = match.group(1), match.group(2)\n        if (start.isdigit() and end.isdigit()) or (start.isalpha() and end.isalpha()):\n            step = 1 if ord(start) <= ord(end) else -1\n            return ''.join(chr(c) for c in range(ord(start), ord(end) + step, step))\n        return match.group(0)\n    return re.sub(r'([A-Za-z0-9])-([A-Za-z0-9])', repl, s)",
    "code_2": "def expand_ranges(s):\n    result = []\n    i = 0\n    n = len(s)\n    while i < n:\n        # check for a pattern like x-y\n        if i + 2 < n and s[i+1] == '-' and (\n            (s[i].isdigit() and s[i+2].isdigit()) or\n            (s[i].isalpha() and s[i+2].isalpha())\n        ):\n            start, end = s[i], s[i+2]\n            step = 1 if ord(start) <= ord(end) else -1\n            for code in range(ord(start), ord(end) + step, step):\n                result.append(chr(code))\n            i += 3\n        else:\n            result.append(s[i])\n            i += 1\n    return ''.join(result)"
  },
  {
    "task": "Digit to Word Converter",
    "input": "A single string containing digit characters",
    "output": "A string where each digit is replaced by its English word (e.g., \u201c1\u201d \u2192 \u201cone\u201d)",
    "function_name": "convert_digits_to_words",
    "code_1": "def convert_digits_to_words(s):\n    \"\"\"Convert each digit in the input string to its English word, separated by spaces.\"\"\"\n    mapping = {\n        '0': 'zero', '1': 'one', '2': 'two', '3': 'three', '4': 'four',\n        '5': 'five', '6': 'six', '7': 'seven', '8': 'eight', '9': 'nine'\n    }\n    return ' '.join(mapping[d] for d in s)",
    "code_2": "from functools import reduce\n\ndef convert_digits_to_words(s):\n    mapping = {'0': 'zero', '1': 'one', '2': 'two', '3': 'three', '4': 'four',\n               '5': 'five', '6': 'six', '7': 'seven', '8': 'eight', '9': 'nine'}\n    return reduce(lambda acc, ch: f'{acc} {mapping[ch]}' if acc else mapping[ch], s, '')"
  },
  {
    "task": "Swap Rows in Matrix",
    "input": "list of lists (matrix), two integers (row indices)",
    "output": "list of lists (matrix with the two rows swapped)",
    "function_name": "swap_rows",
    "code_1": "def swap_rows(matrix, i, j):\n    # Swap row i with row j in the given matrix\n    matrix[i], matrix[j] = matrix[j], matrix[i]\n    return matrix",
    "code_2": "def swap_rows(matrix, i, j):\n    return [matrix[j] if idx == i else matrix[i] if idx == j else row for idx, row in enumerate(matrix)]"
  },
  {
    "task": "Common Substring Finder",
    "input": "Two strings and an integer k",
    "output": "A boolean indicating if there is any common substring of length k",
    "function_name": "has_common_substring",
    "code_1": "def has_common_substring(s1, s2, k):\n    \"\"\"\n    Return True if there is any common substring of length k in s1 and s2.\n    \"\"\"\n    # Edge cases\n    if k <= 0:\n        return False\n    if k > len(s1) or k > len(s2):\n        return False\n\n    # Collect all substrings of length k from s1\n    substrings = set()\n    for i in range(len(s1) - k + 1):\n        substrings.add(s1[i:i+k])\n\n    # Check each substring of length k in s2\n    for j in range(len(s2) - k + 1):\n        if s2[j:j+k] in substrings:\n            return True\n\n    return False",
    "code_2": "def has_common_substring(s1, s2, k):\n    \"\"\"\n    Return True if there is any common substring of length k in s1 and s2.\n    \"\"\"\n    # edge conditions\n    if k <= 0 or k > len(s1) or k > len(s2):\n        return False\n    # check each k-length slice of s1 against s2 using built-in substring search\n    return any(s1[i:i+k] in s2 for i in range(len(s1) - k + 1))"
  },
  {
    "task": "Missing Vowels",
    "input": "string",
    "output": "list of characters (vowels not present in the string)",
    "function_name": "missing_vowels",
    "code_1": "def missing_vowels(s):\n    \"\"\"Return a list of vowels not present in the input string.\"\"\"\n    vowels = set('aeiou')\n    present = set(s.lower())\n    # Compute vowels missing from the string\n    missing = vowels - present\n    # Return as a sorted list for consistency\n    return sorted(missing)\n",
    "code_2": "def missing_vowels(s):\n    \"\"\"Return a list of vowels not present in the input string.\"\"\"\n    s_lower = s.lower()\n    # Check each vowel in order and collect those not found\n    return [v for v in 'aeiou' if v not in s_lower]"
  },
  {
    "task": "Max Nested List Depth",
    "input": "nested list (elements may be lists or non-lists)",
    "output": "integer (maximum depth of nesting)",
    "function_name": "max_nested_list_depth",
    "code_1": "def max_nested_list_depth(lst):\n    \"\"\"\n    Calculate the maximum depth of nesting in a list.\n    Non-list elements contribute depth 0.\n    The root list contributes depth 1.\n    \"\"\"\n    if not isinstance(lst, list):\n        return 0\n    # Compute the max depth among sublists\n    max_sub = 0\n    for item in lst:\n        if isinstance(item, list):\n            depth = max_nested_list_depth(item)\n            if depth > max_sub:\n                max_sub = depth\n    return 1 + max_sub",
    "code_2": "def max_nested_list_depth(lst):\n    \"\"\"\n    Calculate the maximum depth of nesting in a list.\n    Non-list elements contribute depth 0. The root list contributes depth 1.\n    \"\"\"\n    if not isinstance(lst, list):\n        return 0\n    # Use max over a generator of sublist depths, with default=0 when there are no sublists\n    return 1 + max((max_nested_list_depth(item) for item in lst if isinstance(item, list)), default=0)\n"
  },
  {
    "task": "Sum Numbers in String",
    "input": "string (contains integers amidst other characters)",
    "output": "integer (sum of all integers found in the string)",
    "function_name": "sum_numbers_in_string",
    "code_1": "def sum_numbers_in_string(s):\n    import re\n    # Find all integer numbers, including negatives\n    numbers = re.findall(r'-?\\d+', s)\n    # Convert found strings to integers and sum them\n    return sum(int(num) for num in numbers)",
    "code_2": "def sum_numbers_in_string(s):\n    total = 0\n    num = ''\n    sign = 1\n    i = 0\n    while i < len(s):\n        ch = s[i]\n        # Detect negative number start\n        if ch == '-' and i + 1 < len(s) and s[i+1].isdigit():\n            # If a number was being built, add it first\n            if num:\n                total += sign * int(num)\n                num = ''\n            sign = -1\n            i += 1\n            # Collect all following digits\n            while i < len(s) and s[i].isdigit():\n                num += s[i]\n                i += 1\n            total += sign * int(num)\n            # Reset for next number\n            num = ''\n            sign = 1\n            continue\n        elif ch.isdigit():\n            num += ch\n        else:\n            if num:\n                total += sign * int(num)\n                num = ''\n                sign = 1\n        i += 1\n    # Add any trailing number\n    if num:\n        total += sign * int(num)\n    return total"
  },
  {
    "task": "Convert Milliseconds to Time",
    "input": "integer (milliseconds)",
    "output": "string in the format \"H:M:S:MS\"",
    "function_name": "convert_milliseconds_to_time",
    "code_1": "def convert_milliseconds_to_time(milliseconds):\n    # Calculate hours\n    hours = milliseconds // 3600000\n    milliseconds %= 3600000\n\n    # Calculate minutes\n    minutes = milliseconds // 60000\n    milliseconds %= 60000\n\n    # Calculate seconds\n    seconds = milliseconds // 1000\n\n    # Remaining milliseconds\n    ms = milliseconds % 1000\n\n    # Return formatted time string H:M:S:MS\n    return f\"{hours}:{minutes}:{seconds}:{ms}\"",
    "code_2": "from datetime import timedelta\n\ndef convert_milliseconds_to_time(milliseconds):\n    td = timedelta(milliseconds=milliseconds)\n    total_seconds = int(td.total_seconds())\n    hours, rem = divmod(total_seconds, 3600)\n    minutes, seconds = divmod(rem, 60)\n    ms = td.microseconds // 1000\n    return f\"{hours}:{minutes}:{seconds}:{ms}\""
  },
  {
    "task": "Check Sum of Squares Perfect Square",
    "input": "list of numbers",
    "output": "boolean (True if the sum of their squares is a perfect square, otherwise False)",
    "function_name": "is_sum_of_squares_perfect_square",
    "code_1": "import math\ndef is_sum_of_squares_perfect_square(nums):\n    \"\"\"\n    Check if the sum of squares of the list of numbers is a perfect square.\n    \"\"\"\n    total = sum(x * x for x in nums)\n    root = math.isqrt(total)\n    return root * root == total",
    "code_2": "def is_sum_of_squares_perfect_square(nums):\n    # compute sum of squares without built-ins\n    total = 0\n    for n in nums:\n        total += n * n\n    # binary search for integer square root\n    low, high = 0, total\n    while low <= high:\n        mid = (low + high) // 2\n        sq = mid * mid\n        if sq == total:\n            return True\n        if sq < total:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return False"
  },
  {
    "task": "Cumulative Minimum List",
    "input": "list of numbers",
    "output": "list of numbers where each element is the minimum from the start up to that index",
    "function_name": "cumulative_min_list",
    "code_1": "def cumulative_min_list(numbers):\n    '''Return a list of cumulative minimums of the input list.'''\n    result = []\n    current_min = float('inf')\n    for num in numbers:\n        if num < current_min:\n            current_min = num\n        result.append(current_min)\n    return result",
    "code_2": "def cumulative_min_list(numbers):\n    \"\"\"Return a list of cumulative minimums of the input list using itertools.accumulate.\"\"\"\n    from itertools import accumulate\n    return list(accumulate(numbers, min))"
  },
  {
    "task": "Find Two Missing Numbers",
    "input": "list of unique integers from 1 to n with two missing",
    "output": "tuple of two integers (the missing numbers, sorted)",
    "function_name": "find_two_missing",
    "code_1": "import math\n\ndef find_two_missing(nums):\n    # nums: list of unique integers from 1 to n with two missing\n    n = len(nums) + 2\n    # sum of 1..n and sum of squares 1^2..n^2\n    total_sum = n * (n + 1) // 2\n    total_sq = n * (n + 1) * (2 * n + 1) // 6\n\n    # sums from the list\n    sum_nums = sum(nums)\n    sum_sq_nums = sum(x * x for x in nums)\n\n    # a + b and a^2 + b^2\n    sum_ab = total_sum - sum_nums\n    sum_sq_ab = total_sq - sum_sq_nums\n\n    # compute ab\n    ab = (sum_ab * sum_ab - sum_sq_ab) // 2\n\n    # solve x^2 - sum_ab*x + ab = 0\n    D = sum_ab * sum_ab - 4 * ab\n    sqrtD = math.isqrt(D)\n\n    a = (sum_ab + sqrtD) // 2\n    b = (sum_ab - sqrtD) // 2\n    return tuple(sorted((a, b)))",
    "code_2": "def find_two_missing(nums):\n    n = len(nums) + 2\n    missing = set(range(1, n + 1)) - set(nums)\n    return tuple(sorted(missing))"
  },
  {
    "task": "Replace Words with Positions",
    "input": "string (sentence)",
    "output": "string (each word replaced by its 1-based position in the sentence)",
    "function_name": "replace_words_with_positions",
    "code_1": "def replace_words_with_positions(sentence):\n    # Split the sentence into words based on whitespace\n    words = sentence.split()\n    # Generate a list of position strings (1-based index)\n    positions = [str(i + 1) for i in range(len(words))]\n    # Join back into a single string with spaces\n    return \" \".join(positions)",
    "code_2": "def replace_words_with_positions(sentence):\n    import re\n    # Extract words via regex, then enumerate to get 1-based positions\n    return ' '.join(str(idx) for idx, _ in enumerate(re.findall(r'\\S+', sentence), 1))"
  },
  {
    "task": "Substring Extractor",
    "input": "string, integer start index, integer end index",
    "output": "substring from start index up to (but not including) end index",
    "function_name": "extract_substring",
    "code_1": "def extract_substring(s, start, end):\n    \"\"\"Return the substring of s from index start up to (but not including) end.\"\"\"\n    return s[start:end]",
    "code_2": "import itertools\n\ndef extract_substring(s, start, end):\n    \"\"\"Return the substring of s from index start up to (but not including) end using itertools.\"\"\"\n    return ''.join(itertools.islice(s, start, end))"
  },
  {
    "task": "Alternating Sum",
    "input": "list of numbers",
    "output": "single number equal to a[0] - a[1] + a[2] - a[3] \u2026",
    "function_name": "alternating_sum",
    "code_1": "def alternating_sum(numbers):\n    total = 0\n    for i, num in enumerate(numbers):\n        if i % 2 == 0:\n            total += num\n        else:\n            total -= num\n    return total",
    "code_2": "def alternating_sum(numbers):\n    # Sum elements at even indices and subtract sum at odd indices\n    return sum(numbers[0::2]) - sum(numbers[1::2])"
  },
  {
    "task": "Swap Min and Max in List",
    "input": "list of integers",
    "output": "list of integers with the minimum and maximum values swapped",
    "function_name": "swap_min_max",
    "code_1": "def swap_min_max(lst):\n    if not lst:\n        return lst\n    min_val = min(lst)\n    max_val = max(lst)\n    min_idx = lst.index(min_val)\n    max_idx = lst.index(max_val)\n    lst[min_idx], lst[max_idx] = lst[max_idx], lst[min_idx]\n    return lst",
    "code_2": "def swap_min_max(lst):\n    n = len(lst)\n    if n < 2:\n        return lst\n    min_idx = max_idx = 0\n    for i, val in enumerate(lst):\n        if val < lst[min_idx]:\n            min_idx = i\n        if val > lst[max_idx]:\n            max_idx = i\n    lst[min_idx], lst[max_idx] = lst[max_idx], lst[min_idx]\n    return lst"
  },
  {
    "task": "Prefix Product List",
    "input": "list of numbers",
    "output": "list where each element is the product of all elements up to that index",
    "function_name": "prefix_product_list",
    "code_1": "def prefix_product_list(nums):\n    \"\"\"Return a list where each element is the product of all elements up to that index.\"\"\"\n    products = []\n    current = 1\n    for num in nums:\n        current *= num\n        products.append(current)\n    return products",
    "code_2": "import itertools, operator\n\ndef prefix_product_list(nums):\n    # Compute running products using itertools.accumulate\n    return list(itertools.accumulate(nums, operator.mul))"
  },
  {
    "task": "Replace Character",
    "input": "string, integer index, single character",
    "output": "new string with the character at the given index replaced",
    "function_name": "replace_char_at",
    "code_1": "def replace_char_at(s, index, new_char):\n    \"\"\"Replace the character at the given index in the string with new_char.\"\"\"\n    if not (0 <= index < len(s)):\n        raise IndexError(\"Index out of range\")\n    if len(new_char) != 1:\n        raise ValueError(\"new_char must be a single character\")\n    return s[:index] + new_char + s[index+1:]",
    "code_2": "def replace_char_at(s, index, new_char):\n    # Ensure new_char is exactly one character\n    if len(new_char) != 1:\n        raise ValueError('new_char must be a single character')\n    # Check index bounds\n    if index < 0 or index >= len(s):\n        raise IndexError('Index out of range')\n    # Build a new string by replacing at the target index\n    return ''.join(new_char if i == index else ch for i, ch in enumerate(s))"
  },
  {
    "task": "Sum Divisible by K",
    "input": "list of integers, integer k",
    "output": "integer sum of all list elements divisible by k",
    "function_name": "sum_divisible_by_k",
    "code_1": "def sum_divisible_by_k(nums, k):\n    \"\"\"Return the sum of numbers in nums divisible by k.\"\"\"\n    return sum(num for num in nums if num % k == 0)",
    "code_2": "from functools import reduce\n\ndef sum_divisible_by_k(nums, k):\n    \"\"\"Return the sum of numbers in nums divisible by k using reduce.\"\"\"\n    return reduce(lambda acc, x: acc + x if x % k == 0 else acc, nums, 0)"
  },
  {
    "task": "Count Prime Length Words",
    "input": "string (sentence)",
    "output": "integer (number of words whose length is a prime number)",
    "function_name": "count_prime_length_words",
    "code_1": "def count_prime_length_words(s):\n    import string\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        if n == 2:\n            return True\n        if n % 2 == 0:\n            return False\n        for i in range(3, int(n ** 0.5) + 1, 2):\n            if n % i == 0:\n                return False\n        return True\n\n    count = 0\n    for w in s.split():\n        word = w.strip(string.punctuation)\n        if is_prime(len(word)):\n            count += 1\n\n    return count",
    "code_2": "def count_prime_length_words(s):\n    import re\n\n    # Extract candidate words (keeping internal apostrophes, hyphens, underscores)\n    words = re.findall(r\"[\\w'-]+\", s)\n    lengths = [len(w) for w in words]\n    if not lengths:\n        return 0\n\n    # Build a sieve of primes up to the maximum word length\n    max_len = max(lengths)\n    sieve = [False, False] + [True] * (max_len - 1)\n    for p in range(2, int(max_len ** 0.5) + 1):\n        if sieve[p]:\n            sieve[p * p : max_len + 1 : p] = [False] * (((max_len - p * p) // p) + 1)\n\n    # Count how many word lengths are prime\n    return sum(1 for L in lengths if sieve[L])"
  },
  {
    "task": "Count Divisors",
    "input": "positive integer",
    "output": "integer count of its positive divisors",
    "function_name": "count_divisors",
    "code_1": "def count_divisors(n):\n    \"\"\"Return the number of positive divisors of n.\"\"\"\n    count = 0\n    # Iterate up to sqrt(n) and count divisor pairs\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count",
    "code_2": "def count_divisors(n):\n    factors = {}\n    temp = n\n    i = 2\n    # factorize n into its prime components\n    while i * i <= temp:\n        while temp % i == 0:\n            factors[i] = factors.get(i, 0) + 1\n            temp //= i\n        i += 1\n    # if there's a remaining prime factor\n    if temp > 1:\n        factors[temp] = factors.get(temp, 0) + 1\n    # the total count is the product of (exponent+1) for each prime\n    count = 1\n    for exp in factors.values():\n        count *= (exp + 1)\n    return count"
  },
  {
    "task": "Alternating Case String",
    "input": "string",
    "output": "new string with characters in alternating uppercase and lowercase starting with uppercase",
    "function_name": "alternating_case",
    "code_1": "def alternating_case(s):\n    \"\"\"\n    Return a new string with characters in alternating uppercase and lowercase, starting with uppercase.\n    \"\"\"\n    result = []\n    upper = True\n    for c in s:\n        if upper:\n            result.append(c.upper())\n        else:\n            result.append(c.lower())\n        upper = not upper\n    return ''.join(result)",
    "code_2": "def alternating_case(s):\n    '''\n    Return a new string with characters in alternating uppercase and lowercase, starting with uppercase.\n    '''\n    from itertools import cycle\n    funcs = cycle((str.upper, str.lower))\n    return ''.join(next(funcs)(c) for c in s)"
  },
  {
    "task": "Mirror Number",
    "input": "non-negative integer",
    "output": "integer formed by appending the reverse of its digits to the original number",
    "function_name": "mirror_number",
    "code_1": "def mirror_number(n):\n    s = str(n)\n    rev = s[::-1]\n    return int(s + rev)",
    "code_2": "def mirror_number(n):\n    # Build the numeric reverse of n\n    rev = 0\n    temp = n\n    while temp > 0:\n        rev = rev * 10 + (temp % 10)\n        temp //= 10\n\n    # Determine how many digits n has (zero has 1 digit)\n    digits = 0\n    temp2 = n\n    while temp2 > 0:\n        digits += 1\n        temp2 //= 10\n    if digits == 0:\n        digits = 1\n\n    # Shift n left by its digit count and add rev\n    return n * (10 ** digits) + rev\n"
  },
  {
    "task": "Zip Longest",
    "input": "first list, second list",
    "output": "list of tuples pairing elements by index, using None where one list is shorter",
    "function_name": "zip_longest",
    "code_1": "def zip_longest(first, second):\n    \"\"\"\n    Pair elements from two lists by index, using None when one list is shorter.\n\n    Args:\n        first (list): The first list.\n        second (list): The second list.\n\n    Returns:\n        list of tuple: Each tuple contains an element from first and second (or None).\n    \"\"\"\n    max_len = max(len(first), len(second))\n    result = []\n    for i in range(max_len):\n        a = first[i] if i < len(first) else None\n        b = second[i] if i < len(second) else None\n        result.append((a, b))\n    return result",
    "code_2": "def zip_longest(first, second):\n    # Pad the shorter list with None and zip\n    n = max(len(first), len(second))\n    padded_first = first + [None] * (n - len(first))\n    padded_second = second + [None] * (n - len(second))\n    return list(zip(padded_first, padded_second))"
  },
  {
    "task": "Max Digit Sequence Length",
    "input": "string",
    "output": "integer representing the length of the longest run of consecutive digits",
    "function_name": "max_digit_sequence_length",
    "code_1": "def max_digit_sequence_length(s):\n    \"\"\"\n    Returns the length of the longest run of consecutive digits in the input string s.\n    \"\"\"\n    max_len = 0\n    curr_len = 0\n    for ch in s:\n        if ch.isdigit():\n            curr_len += 1\n            if curr_len > max_len:\n                max_len = curr_len\n        else:\n            curr_len = 0\n    return max_len",
    "code_2": "import re\n\ndef max_digit_sequence_length(s):\n    # Find all sequences of digits and return the length of the longest one\n    sequences = re.findall(r\"\\d+\", s)\n    if not sequences:\n        return 0\n    return max(len(seq) for seq in sequences)"
  },
  {
    "task": "Fibonacci Membership Check",
    "input": "integer n",
    "output": "boolean indicating whether n is a Fibonacci number",
    "function_name": "is_fibonacci",
    "code_1": "def is_fibonacci(n):\n    import math\n    if n < 0:\n        return False\n    def is_perfect_square(x):\n        s = int(math.sqrt(x))\n        return s * s == x\n    return is_perfect_square(5 * n * n + 4) or is_perfect_square(5 * n * n - 4)",
    "code_2": "def is_fibonacci(n):\n    if not isinstance(n, int) or n < 0:\n        return False\n    a, b = 0, 1\n    while a < n:\n        a, b = b, a + b\n    return a == n"
  },
  {
    "task": "Apply Discount",
    "input": "list of numbers (prices), number (discount percentage)",
    "output": "list of discounted prices",
    "function_name": "apply_discount",
    "code_1": "def apply_discount(prices, discount):\n    \"\"\"Apply a percentage discount to a list of prices.\n\n    Args:\n        prices (list of numbers): Original prices.\n        discount (number): Discount percentage (e.g., 20 for 20%).\n\n    Returns:\n        list of floats: Discounted prices.\n    \"\"\"\n    return [price * (1 - discount / 100) for price in prices]\n",
    "code_2": "def apply_discount(prices, discount):\n    \"\"\"Apply a percentage discount to a list of prices using map and lambda.\"\"\"\n    factor = (100 - discount) / 100.0\n    return list(map(lambda price: price * factor, prices))"
  },
  {
    "task": "Title Words Extractor",
    "input": "string (sentence)",
    "output": "list of words starting with an uppercase letter",
    "function_name": "extract_title_words",
    "code_1": "def extract_title_words(sentence):\n    import re\n    # Find all words that start with an uppercase letter\n    return re.findall(r'\\b[A-Z][a-zA-Z]*\\b', sentence)",
    "code_2": "def extract_title_words(sentence):\n    import string\n    result = []\n    for token in sentence.split():\n        word = token.strip(string.punctuation)\n        if word[:1].isupper() and (len(word) == 1 or word[1:].isalpha()):\n            result.append(word)\n    return result"
  },
  {
    "task": "Loan Payment Calculator",
    "input": "principal (float), annual interest rate (percentage as float), loan term (years as int)",
    "output": "monthly payment amount (float)",
    "function_name": "calculate_monthly_payment",
    "code_1": "def calculate_monthly_payment(principal, annual_interest_rate, years):\n    monthly_rate = annual_interest_rate / 100 / 12\n    total_payments = years * 12\n    if monthly_rate == 0:\n        return principal / total_payments\n    return (principal * monthly_rate * (1 + monthly_rate) ** total_payments) / ((1 + monthly_rate) ** total_payments - 1)",
    "code_2": "def calculate_monthly_payment(principal, annual_interest_rate, years):\n    \"\"\"\n    Calculate the fixed monthly payment by finding the root of the amortization balance\n    using a bisection search, rather than directly using the closed-form formula.\n    \"\"\"\n    # Convert annual rate percentage to a monthly decimal rate\n    monthly_rate = annual_interest_rate / 100.0 / 12.0\n    total_payments = years * 12\n\n    # If there's no interest, it's just principal divided by months\n    if monthly_rate == 0:\n        return principal / total_payments\n\n    # Define a function that returns the remaining balance after paying `payment`\n    def remaining_balance(payment):\n        balance = principal\n        for _ in range(total_payments):\n            # accumulate interest then subtract a payment\n            balance = balance * (1 + monthly_rate) - payment\n        return balance\n\n    # Use the closed-form payment as a guide for an upper bound, then double it for safety\n    # (so we guarantee the true root lies in [0, hi])\n    estimate = (principal * monthly_rate * (1 + monthly_rate) ** total_payments) / (\n        (1 + monthly_rate) ** total_payments - 1\n    )\n    lo, hi = 0.0, estimate * 2\n\n    # Bisection loop to drive the remaining balance toward zero\n    for _ in range(60):\n        mid = (lo + hi) / 2.0\n        if remaining_balance(mid) > 0:\n            # Balance is still positive: payment too small, raise the lower bound\n            lo = mid\n        else:\n            # Balance went negative or zero: payment too large, lower the upper bound\n            hi = mid\n\n    # The midpoint is our monthly payment approximation\n    return (lo + hi) / 2.0"
  },
  {
    "task": "Remove Vowels",
    "input": "string",
    "output": "string with all vowels (a, e, i, o, u, both cases) removed",
    "function_name": "remove_vowels",
    "code_1": "def remove_vowels(s):\n    vowels = set('aeiouAEIOU')\n    return ''.join(ch for ch in s if ch not in vowels)",
    "code_2": "def remove_vowels(s):\n    trans = str.maketrans('', '', 'aeiouAEIOU')\n    return s.translate(trans)"
  },
  {
    "task": "Password Masker",
    "input": "string (password)",
    "output": "string where all characters except the last two are replaced by '*'",
    "function_name": "mask_password",
    "code_1": "def mask_password(password):\n    \"\"\"Return the password with all but the last two characters masked with '*'\"\"\"\n    return '*' * max(len(password) - 2, 0) + password[-2:]",
    "code_2": "def mask_password(password):\n    \"\"\"Return the password with all but the last two characters masked with '*'\"\"\"\n    return ''.join('*' if i < len(password) - 2 else ch for i, ch in enumerate(password))"
  },
  {
    "task": "Alternating Sequence Check",
    "input": "list of numbers",
    "output": "boolean indicating whether elements alternately increase and decrease",
    "function_name": "is_alternating",
    "code_1": "def is_alternating(arr):\n    \"\"\"\n    Check if the numeric sequence alternately increases and decreases.\n    Returns True for empty or single-element lists.\n    \"\"\"\n    n = len(arr)\n    if n < 2:\n        return True\n    # Initial comparison must be strict\n    if arr[0] == arr[1]:\n        return False\n    up = arr[0] < arr[1]\n    for i in range(1, n-1):\n        if up:\n            if arr[i] <= arr[i+1]:\n                return False\n        else:\n            if arr[i] >= arr[i+1]:\n                return False\n        up = not up\n    return True",
    "code_2": "def is_alternating(arr):\n    '''Check if the numeric sequence alternately increases and decreases.'''\n    if len(arr) < 2:\n        return True\n    # compute consecutive differences\n    diffs = [b - a for a, b in zip(arr, arr[1:])]\n    # no zeros allowed (strictly up or down)\n    if any(d == 0 for d in diffs):\n        return False\n    # ensure each pair of adjacent differences has opposite signs\n    return all(d1 * d2 < 0 for d1, d2 in zip(diffs, diffs[1:]))"
  },
  {
    "task": "Dictionary Maximum by Key",
    "input": "list of dictionaries and a string key",
    "output": "the dictionary with the highest value for that key",
    "function_name": "get_max_dict_by_key",
    "code_1": "def get_max_dict_by_key(dicts, key):\n    \"\"\"\n    Return the dictionary from a list that has the highest value for the given key.\n    If a dictionary is missing the key, it is treated as having value -infinity.\n    \"\"\"\n    return max(dicts, key=lambda d: d.get(key, float('-inf')))",
    "code_2": "def get_max_dict_by_key(dicts, key):\n    \"\"\"\n    Return the dictionary from a list that has the highest value for the given key.\n    If a dictionary is missing the key, it is treated as having value -infinity.\n    \"\"\"\n    best = None\n    best_val = float('-inf')\n    for d in dicts:\n        # retrieve value or negative infinity if key is absent\n        val = d.get(key, float('-inf'))\n        if best is None or val > best_val:\n            best, best_val = d, val\n    return best"
  },
  {
    "task": "Group Emails by Domain",
    "input": "list of email strings",
    "output": "dictionary mapping each domain to the list of emails with that domain",
    "function_name": "group_emails_by_domain",
    "code_1": "def group_emails_by_domain(emails):\n    \"\"\"\n    Groups a list of email strings by their domain.\n\n    Args:\n        emails (list of str): The list of email addresses to group.\n\n    Returns:\n        dict: A dictionary mapping each domain to the list of emails with that domain.\n    \"\"\"\n    domain_map = {}\n    for email in emails:\n        parts = email.split('@')\n        if len(parts) != 2:\n            # Skip invalid email formats\n            continue\n        domain = parts[1]\n        domain_map.setdefault(domain, []).append(email)\n    return domain_map",
    "code_2": "def group_emails_by_domain(emails):\n    import re\n    # Compile a regex to capture the part after a single '@'\n    pattern = re.compile(r'^[^@]+@([^@]+)$')\n    result = {}\n    for email in emails:\n        match = pattern.match(email)\n        if not match:\n            continue\n        domain = match.group(1)\n        # Build the list for this domain if needed\n        if domain not in result:\n            result[domain] = []\n        result[domain].append(email)\n    return result"
  },
  {
    "task": "Sum at Multiples of K",
    "input": "list of integers, integer k",
    "output": "integer sum of list elements at indices that are multiples of k (0-based)",
    "function_name": "sum_at_multiples_of_k",
    "code_1": "def sum_at_multiples_of_k(nums, k):\n    # Sum elements at indices that are multiples of k (0-based)\n    if k <= 0:\n        raise ValueError(\"k must be a positive integer\")\n    total = 0\n    for i in range(0, len(nums), k):\n        total += nums[i]\n    return total",
    "code_2": "def sum_at_multiples_of_k(nums, k):\n    if k <= 0:\n        raise ValueError(\"k must be a positive integer\")\n    from itertools import islice\n    # Use islice to pick every k-th item starting at index 0\n    return sum(islice(nums, 0, None, k))"
  },
  {
    "task": "Sum of Chunks",
    "input": "list of numbers and an integer chunk size",
    "output": "list of sums for each consecutive chunk of the given size (last chunk may be smaller)",
    "function_name": "sum_chunks",
    "code_1": "def sum_chunks(numbers, chunk_size):\n    \"\"\"\n    Returns a list of sums of each consecutive chunk of given size from the input list.\n    The last chunk may be smaller if the list size isn't a multiple of chunk_size.\n    \"\"\"\n    if chunk_size <= 0:\n        raise ValueError(\"chunk_size must be a positive integer\")\n    result = []\n    for i in range(0, len(numbers), chunk_size):\n        chunk = numbers[i:i + chunk_size]\n        result.append(sum(chunk))\n    return result",
    "code_2": "def sum_chunks(numbers, chunk_size):\n    \"\"\"\n    Returns a list of sums of each consecutive chunk of given size from the input list.\n    The last chunk may be smaller if the list size isn't a multiple of chunk_size.\n    \"\"\"\n    if chunk_size <= 0:\n        raise ValueError(\"chunk_size must be a positive integer\")\n    from itertools import groupby\n\n    # Group numbers by the chunk index computed from their positions\n    grouped = groupby(enumerate(numbers), key=lambda iv: iv[0] // chunk_size)\n    # Sum values in each group and return as a list\n    return [sum(val for _, val in group) for _, group in grouped]\n"
  },
  {
    "task": "Remove Duplicates Keep Last",
    "input": "list of elements",
    "output": "list with duplicates removed, retaining the last occurrence of each element",
    "function_name": "remove_duplicates_keep_last",
    "code_1": "def remove_duplicates_keep_last(lst):\n    \"\"\"\n    Remove duplicates from the list, keeping only the last occurrence of each element.\n\n    Args:\n        lst (list): The input list from which to remove duplicates.\n\n    Returns:\n        list: A new list with duplicates removed, retaining only the last occurrence of each element.\n    \"\"\"\n    seen = set()\n    result = []\n    # Iterate the list in reverse to keep last occurrences\n    for item in reversed(lst):\n        if item not in seen:\n            seen.add(item)\n            result.append(item)\n    # Reverse again to restore original order\n    return list(reversed(result))",
    "code_2": "def remove_duplicates_keep_last(lst):\n    # Use dict.fromkeys on the reversed list to remove dups and keep last occurrences\n    return [*dict.fromkeys(reversed(lst))][::-1]"
  },
  {
    "task": "Unique Pairwise Sums",
    "input": "list of numbers",
    "output": "sorted list of unique sums formed by adding every two distinct numbers",
    "function_name": "unique_pairwise_sums",
    "code_1": "def unique_pairwise_sums(numbers):\n    \"\"\"Return sorted list of unique sums of every two distinct numbers.\"\"\"\n    from itertools import combinations\n    sums = {a + b for a, b in combinations(numbers, 2)}\n    return sorted(sums)",
    "code_2": "def unique_pairwise_sums(numbers):\n    seen = set()\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            seen.add(numbers[i] + numbers[j])\n    return sorted(seen)"
  },
  {
    "task": "H-Index Calculator",
    "input": "list of non-negative integers (citation counts)",
    "output": "integer representing the h-index",
    "function_name": "h_index",
    "code_1": "def h_index(citations):\n    \"\"\"\n    Calculate the h-index given a list of citation counts.\n\n    Args:\n        citations (List[int]): List of non-negative citation counts.\n\n    Returns:\n        int: The h-index value.\n    \"\"\"\n    # Sort citations in descending order\n    citations_sorted = sorted(citations, reverse=True)\n    h = 0\n    # Iterate through sorted list and update h\n    for i, c in enumerate(citations_sorted):\n        if c >= i + 1:\n            h = i + 1\n        else:\n            break\n    return h",
    "code_2": "def h_index(citations):\n    \"\"\"\n    Calculate the h-index using binary search over possible h values.\n\n    Args:\n        citations (List[int]): List of non-negative citation counts.\n\n    Returns:\n        int: The h-index value.\n    \"\"\"\n    n = len(citations)\n    low, high = 0, n\n    while low < high:\n        mid = (low + high + 1) // 2\n        # Count how many papers have at least mid citations\n        if sum(1 for c in citations if c >= mid) >= mid:\n            low = mid\n        else:\n            high = mid - 1\n    return low"
  },
  {
    "task": "Lucky Ticket Checker",
    "input": "six-character string of digits",
    "output": "boolean indicating whether the sum of the first three digits equals the sum of the last three digits",
    "function_name": "is_lucky_ticket",
    "code_1": "def is_lucky_ticket(ticket):\n    if len(ticket) != 6 or not ticket.isdigit():\n        raise ValueError(\"Input must be a six-digit string of digits\")\n    return sum(int(d) for d in ticket[:3]) == sum(int(d) for d in ticket[3:])",
    "code_2": "def is_lucky_ticket(ticket):\n    if not isinstance(ticket, str) or len(ticket) != 6 or not ticket.isdigit():\n        raise ValueError(\"Input must be a six-digit string of digits\")\n    # Compare sums by pairwise subtraction of character codes\n    return sum(ord(ticket[i]) - ord(ticket[i+3]) for i in range(3)) == 0"
  },
  {
    "task": "Cartesian Product of Lists",
    "input": "two lists of elements",
    "output": "list of tuples representing the Cartesian product of the two lists",
    "function_name": "cartesian_product",
    "code_1": "def cartesian_product(list1, list2):\n    # Return the Cartesian product of two lists as a list of tuples\n    result = []\n    for a in list1:\n        for b in list2:\n            result.append((a, b))\n    return result",
    "code_2": "def cartesian_product(list1, list2):\n    from itertools import product\n    return list(product(list1, list2))"
  },
  {
    "task": "Mirror Strings",
    "input": "list of strings",
    "output": "list where each string is concatenated with its reverse (e.g., \"abc\" \u2192 \"abccba\")",
    "function_name": "mirror_strings",
    "code_1": "def mirror_strings(strings):\n    return [s + s[::-1] for s in strings]",
    "code_2": "def mirror_strings(strings):\n    result = []\n    for s in strings:\n        # build the reverse using the reversed() iterator\n        rev = ''.join(reversed(s))\n        # append the original string concatenated with its reverse\n        result.append(f'{s}{rev}')\n    return result"
  },
  {
    "task": "Filter by Frequency Threshold",
    "input": "list of elements and an integer k",
    "output": "list of elements that appear at least k times in the original list, in their original order",
    "function_name": "filter_by_frequency",
    "code_1": "def filter_by_frequency(lst, k):\n    from collections import Counter\n    freq = Counter(lst)\n    return [x for x in lst if freq[x] >= k]",
    "code_2": "def filter_by_frequency(lst, k):\n    # Build a frequency map without Counter\n    freq = {}\n    for item in lst:\n        freq[item] = freq.get(item, 0) + 1\n    # Use filter and a lambda to preserve order\n    return list(filter(lambda x: freq[x] >= k, lst))"
  },
  {
    "task": "Remove Whitespace",
    "input": "a string",
    "output": "the string with all whitespace characters removed",
    "function_name": "remove_whitespace",
    "code_1": "def remove_whitespace(text):\n    \"\"\"Return the string with all whitespace characters removed.\"\"\"\n    return ''.join(text.split())",
    "code_2": "def remove_whitespace(text):\n    \"\"\"Return the string with all whitespace characters removed.\"\"\"\n    return ''.join(ch for ch in text if not ch.isspace())"
  },
  {
    "task": "Sum of Character code_1s",
    "input": "a string",
    "output": "the sum of the ASCII (or Unicode_1) code_1 points of all characters in the string",
    "function_name": "sum_char_code_1s",
    "code_1": "def sum_char_code_1s(s):\n    \"\"\"\n    Return the sum of the ASCII/Unicode_1 code_1 points of all characters in the input string s.\n    \"\"\"\n    return sum(ord(c) for c in s)",
    "code_2": "from functools import reduce\nimport operator\n\ndef sum_char_code_1s(s):\n    \"\"\"\n    Return the sum of the ASCII/Unicode code points of all characters in the input string s\n    by reducing mapped ord values.\n    \"\"\"\n    return reduce(operator.add, map(ord, s), 0)\n"
  },
  {
    "task": "Delete Middle Element",
    "input": "a list",
    "output": "the list with its middle element removed (if even length, remove the lower-index middle)",
    "function_name": "delete_middle",
    "code_1": "def delete_middle(lst):\n    \"\"\"\n    Remove and return a new list without its middle element.\n    If the list has an even length, removes the lower-index middle element.\n    \"\"\"\n    # Calculate the index of the middle element (lower-index for even lengths)\n    index = (len(lst) - 1) // 2\n    # Return a new list without the middle element\n    return lst[:index] + lst[index+1:]\n",
    "code_2": "def delete_middle(lst):\n    '''\n    Remove and return a new list without its middle element.\n    If the list has an even length, removes the lower-index middle element.\n    '''\n    length = len(lst)\n    # Compute lower-index middle: for odd lengths, it's length//2; for even, one less\n    mid = length//2 - (1 - length%2)\n    return [v for i, v in enumerate(lst) if i != mid]"
  },
  {
    "task": "Filter Divisible Numbers",
    "input": "a list of integers and an integer divisor",
    "output": "a list of integers from the input list that are evenly divisible by the divisor",
    "function_name": "filter_divisible_numbers",
    "code_1": "def filter_divisible_numbers(numbers, divisor):\n    \"\"\"Return a list of integers from numbers that are evenly divisible by divisor.\"\"\"\n    return [n for n in numbers if n % divisor == 0]",
    "code_2": "def filter_divisible_numbers(numbers, divisor):\n    \"\"\"Return a list of integers from numbers that are evenly divisible by divisor using filter.\"\"\"\n    return list(filter(lambda x: x % divisor == 0, numbers))"
  },
  {
    "task": "Filter Strings by Suffix",
    "input": "a list of strings and a suffix string",
    "output": "a list of strings from the input list that end with the given suffix",
    "function_name": "filter_by_suffix",
    "code_1": "def filter_by_suffix(strings, suffix):\n    \"\"\"\n    Return a list of strings from the input list that end with the given suffix.\n\n    :param strings: List of strings to filter.\n    :param suffix: Suffix string to check.\n    :return: List of strings ending with the suffix.\n    \"\"\"\n    return [s for s in strings if s.endswith(suffix)]",
    "code_2": "def filter_by_suffix(strings, suffix):\n    \"\"\"\n    Return a list of strings from the input list that end with the given suffix.\n\n    :param strings: List of strings to filter.\n    :param suffix: Suffix string to check.\n    :return: List of strings ending with the suffix.\n    \"\"\"\n    # Use the built-in filter function for a functional style\n    return list(filter(lambda s, suf=suffix: s.endswith(suf), strings))"
  },
  {
    "task": "Shuffle Characters",
    "input": "a string",
    "output": "a new string with the characters of the input string in random order",
    "function_name": "shuffle_characters",
    "code_1": "def shuffle_characters(s):\n    import random\n    chars = list(s)\n    random.shuffle(chars)\n    return ''.join(chars)",
    "code_2": "def shuffle_characters(s):\n    import random\n    # Use random.sample to return a new shuffled list of characters\n    return ''.join(random.sample(s, len(s)))"
  },
  {
    "task": "List Palindromic Numbers",
    "input": "integer n",
    "output": "list of integers from 1 to n (inclusive) that read the same forward and backward",
    "function_name": "find_palindromic_numbers",
    "code_1": "def find_palindromic_numbers(n):\n    result = []\n    for i in range(1, n + 1):\n        s = str(i)\n        if s == s[::-1]:\n            result.append(i)\n    return result",
    "code_2": "def find_palindromic_numbers(n):\n    if n < 1:\n        return []\n    palindromes = []\n    max_len = len(str(n))\n    for length in range(1, max_len + 1):\n        if length == 1:\n            # single-digit palindromes\n            for i in range(1, min(n, 9) + 1):\n                palindromes.append(i)\n            continue\n        half = (length + 1) // 2\n        start = 10 ** (half - 1)\n        end = 10 ** half\n        for prefix in range(start, end):\n            s = str(prefix)\n            # mirror around the middle\n            if length % 2:\n                pal_str = s + s[-2::-1]\n            else:\n                pal_str = s + s[::-1]\n            val = int(pal_str)\n            if val > n:\n                break\n            palindromes.append(val)\n    return palindromes"
  },
  {
    "task": "Evaluate Prefix Expression",
    "input": "a string representing a prefix (Polish) expression with tokens separated by spaces",
    "output": "the integer result of evaluating the expression",
    "function_name": "evaluate_prefix",
    "code_1": "def evaluate_prefix(expr):\n    tokens = expr.split()\n    stack = []\n    for token in reversed(tokens):\n        # If the token is an operator, pop two operands and apply it\n        if token in '+-*/':\n            a = stack.pop()\n            b = stack.pop()\n            if token == '+':\n                stack.append(a + b)\n            elif token == '-':\n                stack.append(a - b)\n            elif token == '*':\n                stack.append(a * b)\n            else:\n                # integer division truncating toward zero\n                stack.append(int(a / b))\n        else:\n            # token is an integer operand\n            stack.append(int(token))\n    return stack[0] if stack else 0",
    "code_2": "def evaluate_prefix(expr):\n    from collections import deque\n    tokens = deque(expr.split())\n    def parse():\n        tok = tokens.popleft()\n        if tok in '+-*/':\n            left = parse()\n            right = parse()\n            if tok == '+':\n                return left + right\n            if tok == '-':\n                return left - right\n            if tok == '*':\n                return left * right\n            # integer division truncating toward zero\n            return int(left / right)\n        return int(tok)\n    # handle empty input\n    return parse() if expr.strip() else 0"
  },
  {
    "task": "Check Perfect Power",
    "input": "an integer",
    "output": "True if the integer can be expressed as a^b for integers a>0 and b>1, otherwise False",
    "function_name": "is_perfect_power",
    "code_1": "def is_perfect_power(n):\n    import math\n    # Only positive integers can be expressed as a^b with a>0 and b>1\n    if n < 1:\n        return False\n    # 1 = 1^b for any b>1\n    if n == 1:\n        return True\n    # The maximum exponent b to check is log2(n)\n    max_b = int(math.log2(n)) + 1\n    for b in range(2, max_b + 1):\n        # Find integer a such that a^b == n via binary search\n        low, high = 2, int(n ** (1.0 / b)) + 1\n        while low <= high:\n            mid = (low + high) // 2\n            power = mid ** b\n            if power == n:\n                return True\n            elif power < n:\n                low = mid + 1\n            else:\n                high = mid - 1\n    return False",
    "code_2": "def is_perfect_power(n):\n    # Only positive integers can be a^b with a>0, b>1\n    if n < 1:\n        return False\n    # 1 = 1^b for any b>1\n    if n == 1:\n        return True\n    # Factor n and collect exponents\n    temp = n\n    exponents = []\n    # Trial divide\n    p = 2\n    while p * p <= temp:\n        if temp % p == 0:\n            cnt = 0\n            while temp % p == 0:\n                temp //= p\n                cnt += 1\n            exponents.append(cnt)\n        p += 1\n    # If remainder >1 it's prime\n    if temp > 1:\n        exponents.append(1)\n    # If all prime-exponent counts share a common divisor >1, it's a perfect power\n    from math import gcd\n    g = exponents[0]\n    for e in exponents[1:]:\n        g = gcd(g, e)\n    return g > 1"
  },
  {
    "task": "Convert Decimal to Octal",
    "input": "an integer in decimal",
    "output": "a string representing its octal (base-8) form",
    "function_name": "decimal_to_octal",
    "code_1": "def decimal_to_octal(n):\n    if n == 0:\n        return \\\"0\\\"\n    sign = '-' if n < 0 else ''\n    n = abs(n)\n    digits = []\n    while n:\n        digits.append(str(n % 8))\n        n //= 8\n    return sign + ''.join(reversed(digits))",
    "code_2": "def decimal_to_octal(n):\n    # Utilize Python's format specification for octal conversion\n    return format(n, 'o')"
  },
  {
    "task": "Compute Age",
    "input": "string birthdate in 'YYYY-MM-DD' format",
    "output": "integer age in years as of today",
    "function_name": "calculate_age",
    "code_1": "def calculate_age(birthdate):\n    from datetime import datetime, date\n    birth = datetime.strptime(birthdate, '%Y-%m-%d').date()\n    today = date.today()\n    age = today.year - birth.year - ((today.month, today.day) < (birth.month, birth.day))\n    return age",
    "code_2": "def calculate_age(birthdate):\n    from datetime import date\n    # Parse the components\n    year, month, day = map(int, birthdate.split('-'))\n    birth = date(year, month, day)\n    today = date.today()\n    # Attempt to build this year's birthday, handle Feb 29\n    try:\n        this_year_bday = birth.replace(year=today.year)\n    except ValueError:\n        this_year_bday = date(today.year, 3, 1)\n    # Subtract one if birthday hasn't occurred yet this year\n    return today.year - birth.year - (today < this_year_bday)"
  },
  {
    "task": "Remove Duplicate Rows",
    "input": "list of lists of values (matrix)",
    "output": "new matrix (list of lists) with duplicate rows removed, preserving original order",
    "function_name": "remove_duplicate_rows",
    "code_1": "def remove_duplicate_rows(matrix):\n    seen = set()\n    new_matrix = []\n    for row in matrix:\n        t = tuple(row)\n        if t not in seen:\n            seen.add(t)\n            new_matrix.append(row)\n    return new_matrix",
    "code_2": "def remove_duplicate_rows(matrix):\n    # Use dict.fromkeys to preserve order of first occurrence\n    unique = dict.fromkeys(map(tuple, matrix))\n    # Convert keys back to lists\n    return [list(row) for row in unique]"
  },
  {
    "task": "Count HTML Tags",
    "input": "string containing HTML content",
    "output": "dictionary mapping each tag name (string) to its count (integer)",
    "function_name": "count_html_tags",
    "code_1": "def count_html_tags(html_content):\n    from html.parser import HTMLParser\n    class TagCounter(HTMLParser):\n        def __init__(self):\n            super().__init__()\n            self.counts = {}\n        def handle_starttag(self, tag, attrs):\n            self.counts[tag] = self.counts.get(tag, 0) + 1\n        def handle_startendtag(self, tag, attrs):\n            self.counts[tag] = self.counts.get(tag, 0) + 1\n    parser = TagCounter()\n    parser.feed(html_content)\n    return parser.counts",
    "code_2": "def count_html_tags(html_content):\n    import re\n    # find all start tags and self-closing tags\n    tags = re.findall(r'<\\s*([A-Za-z][A-Za-z0-9:-]*)\\b[^>]*?>', html_content)\n    counts = {}\n    for tag in tags:\n        tag = tag.lower()\n        counts[tag] = counts.get(tag, 0) + 1\n    return counts"
  },
  {
    "task": "Nth Root",
    "input": "float number, integer n",
    "output": "float representing the n-th root of number",
    "function_name": "nth_root",
    "code_1": "def nth_root(number, n):\n    \"\"\"\n    Compute the n-th root of a given number.\n    Supports negative n (returns reciprocal of positive root) and odd roots of negative numbers.\n    Raises ValueError for zeroth root or even root of negative number.\n    \"\"\"\n    if n == 0:\n        raise ValueError(\"Cannot compute zeroth root\")\n    # Handle negative root exponent by reciprocal\n    if n < 0:\n        return 1.0 / nth_root(number, -n)\n    # Handle negative base for odd roots\n    if number < 0:\n        if n % 2 == 1:\n            return -((-number) ** (1.0 / n))\n        else:\n            raise ValueError(\"Even root of negative number is not real\")\n    # Standard positive root\n    return number ** (1.0 / n)",
    "code_2": "def nth_root(number, n):\n    # Handle invalid root\n    if n == 0:\n        raise ValueError(\"Cannot compute zeroth root\")\n    # Negative exponent: reciprocal of positive root\n    if n < 0:\n        return 1.0 / nth_root(number, -n)\n    # Negative base with even root is not real\n    if number < 0:\n        if n % 2 == 0:\n            raise ValueError(\"Even root of negative number is not real\")\n        sign, num = -1.0, -number\n    else:\n        sign, num = 1.0, number\n    # Initial guess for Newton-Raphson\n    x = num if num >= 1.0 else 1.0\n    # Iterate to refine the estimate\n    for _ in range(20):\n        x = ((n - 1) * x + num / (x ** (n - 1))) / n\n    return sign * x"
  },
  {
    "task": "Parse URL Parameters",
    "input": "string URL containing query parameters",
    "output": "dictionary mapping parameter names (strings) to their values (strings)",
    "function_name": "parse_url_params",
    "code_1": "def parse_url_params(url):\n    \"\"\"\n    Parse the query parameters from a URL string and return a dictionary mapping\n    parameter names to their values as strings.\n    \"\"\"\n    from urllib.parse import urlparse, parse_qsl\n\n    # Parse the URL and extract the query component\n    parsed = urlparse(url)\n    query = parsed.query\n\n    # parse_qsl returns a list of (name, value) tuples\n    # keep_blank_values=True ensures parameters without values are included as ''\n    params_list = parse_qsl(query, keep_blank_values=True)\n\n    # Convert list of tuples to a dict (later values overwrite earlier ones)\n    return dict(params_list)\n",
    "code_2": "def parse_url_params(url):\n    \"\"\"\n    Parse the query parameters from a URL string and return a dictionary\n    mapping parameter names to their values as strings.\n    \"\"\"\n    from urllib.parse import unquote_plus\n\n    # Locate the start of the query\n    qpos = url.find('?')\n    if qpos < 0:\n        return {}\n    # Extract up to any fragment\n    hpos = url.find('#', qpos)\n    query = url[qpos+1:hpos] if hpos >= 0 else url[qpos+1:]\n    if not query:\n        return {}\n\n    result = {}\n    # Split on '&' and handle each key[=value]\n    for segment in query.split('&'):\n        if not segment:\n            continue\n        if '=' in segment:\n            name, value = segment.split('=', 1)\n        else:\n            name, value = segment, ''\n        # Decode percent-encoding and '+'\n        name = unquote_plus(name)\n        value = unquote_plus(value)\n        result[name] = value\n    return result"
  },
  {
    "task": "Reverse Bits",
    "input": "non-negative integer",
    "output": "integer whose binary representation is the reverse of the input\u2019s binary (no leading zeros)",
    "function_name": "reverse_bits",
    "code_1": "def reverse_bits(n):\n    b = bin(n)[2:]\n    rev = b[::-1]\n    return int(rev, 2)",
    "code_2": "def reverse_bits(n):\n    result = 0\n    while n > 0:\n        # Shift result to the left and add the least significant bit of n\n        result = (result << 1) | (n & 1)\n        # Drop the least significant bit from n\n        n >>= 1\n    return result"
  },
  {
    "task": "Longest Even Subsequence",
    "input": "list of integers",
    "output": "integer length of the longest consecutive run of even numbers in the list",
    "function_name": "longest_even_subsequence",
    "code_1": "def longest_even_subsequence(nums):\n    max_len = 0\n    current = 0\n    for n in nums:\n        if n % 2 == 0:\n            current += 1\n            if current > max_len:\n                max_len = current\n        else:\n            current = 0\n    return max_len",
    "code_2": "def longest_even_subsequence(nums):\n    from itertools import groupby\n    max_run = 0\n    for is_even, group in groupby(nums, key=lambda x: x % 2 == 0):\n        if is_even:\n            # count the size of this even-number group\n            length = sum(1 for _ in group)\n            if length > max_run:\n                max_run = length\n    return max_run"
  },
  {
    "task": "Hollow Square Pattern",
    "input": "integer n",
    "output": "list of strings where each string is a row of a hollow square of '*' characters of side length n",
    "function_name": "hollow_square",
    "code_1": "def hollow_square(n):\n    \"\"\"Return a list of strings representing a hollow square of side length n.\"\"\"\n    if n <= 0:\n        return []\n    if n == 1:\n        return ['*']\n    result = []\n    # Top row\n    result.append('*' * n)\n    # Middle rows\n    for _ in range(n - 2):\n        result.append('*' + ' ' * (n - 2) + '*')\n    # Bottom row\n    result.append('*' * n)\n    return result",
    "code_2": "def hollow_square(n):\n    # Build each row by checking border positions in a 2D comprehension\n    return [''.join(\n                '*' if i in (0, n-1) or j in (0, n-1) else ' '\n                for j in range(n)\n            ) for i in range(n)]"
  },
  {
    "task": "Multiply Odd Index Elements",
    "input": "A list of integers",
    "output": "The product of elements at odd indices (1, 3, 5, ...)",
    "function_name": "multiply_odd_index_elements",
    "code_1": "def multiply_odd_index_elements(lst):\n    \"\"\"\n    Multiply elements at odd indices of the input list.\n    Args:\n        lst (list of int): The input list of integers.\n    Returns:\n        int: Product of elements at indices 1, 3, 5, ...\n    \"\"\"\n    product = 1\n    for i in range(1, len(lst), 2):\n        product *= lst[i]\n    return product",
    "code_2": "def multiply_odd_index_elements(lst):\n    from functools import reduce\n    import operator\n    \"\"\"\n    Compute the product of elements at odd indices using a reducer and generator.\n    \"\"\"\n    return reduce(operator.mul, (val for idx, val in enumerate(lst) if idx % 2 == 1), 1)\n"
  },
  {
    "task": "Find Element Indices",
    "input": "A list and a value",
    "output": "A list of indices where the value occurs in the list",
    "function_name": "find_element_indices",
    "code_1": "def find_element_indices(lst, value):\n    \"\"\"\n    Return a list of indices where value occurs in lst.\n    :param lst: list of elements\n    :param value: value to find in the list\n    :return: list of integer indices\n    \"\"\"\n    return [i for i, x in enumerate(lst) if x == value]",
    "code_2": "def find_element_indices(lst, value):\n    \"\"\"\n    Return a list of indices where value occurs in lst using iterative search.\n    :param lst: list of elements\n    :param value: value to find\n    :return: list of integer indices\n    \"\"\"\n    indices = []\n    start = 0\n    while True:\n        try:\n            idx = lst.index(value, start)\n        except ValueError:\n            break\n        indices.append(idx)\n        start = idx + 1\n    return indices"
  },
  {
    "task": "Column-wise Sort Matrix",
    "input": "list of lists of numbers (matrix)",
    "output": "new matrix with each column independently sorted in ascending order",
    "function_name": "sort_matrix_columns",
    "code_1": "def sort_matrix_columns(matrix):\n    # Handle empty matrix or empty rows\n    if not matrix or not matrix[0]:\n        return matrix\n    # Transpose matrix to get columns, sort each column\n    columns = [sorted(col) for col in zip(*matrix)]\n    # Reconstruct rows from sorted columns\n    num_rows = len(matrix)\n    num_cols = len(columns)\n    return [[columns[j][i] for j in range(num_cols)] for i in range(num_rows)]",
    "code_2": "def sort_matrix_columns(matrix):\n    # Return early on empty matrix or empty rows\n    if not matrix or not matrix[0]:\n        return matrix\n    rows, cols = len(matrix), len(matrix[0])\n    # Make a deep copy of the matrix to avoid mutating the input\n    sorted_matrix = [row[:] for row in matrix]\n    # Sort each column in place\n    for j in range(cols):\n        # Extract column values\n        col_vals = [matrix[i][j] for i in range(rows)]\n        # Sort the column\n        col_vals.sort()\n        # Write sorted values back into the result matrix\n        for i in range(rows):\n            sorted_matrix[i][j] = col_vals[i]\n    return sorted_matrix"
  },
  {
    "task": "Swap Cases Even Positions",
    "input": "A string",
    "output": "A string where characters at even positions (0-based) have their case swapped",
    "function_name": "swap_even_case",
    "code_1": "def swap_even_case(s):\n    \"\"\"\n    Swap the case of characters at even positions (0-based) in the input string.\n    :param s: Input string\n    :return: String with case swapped at even indices\n    \"\"\"\n    result = []\n    for i, c in enumerate(s):\n        if i % 2 == 0:\n            result.append(c.swapcase())\n        else:\n            result.append(c)\n    return ''.join(result)",
    "code_2": "def swap_even_case(s):\n    \"\"\"\n    Swap the case of characters at even positions (0-based) in the input string.\n    :param s: Input string\n    :return: String with case swapped at even indices\n    \"\"\"\n    chars = list(s)\n    # Swap case for every even-indexed character using slicing\n    chars[0::2] = [c.swapcase() for c in chars[0::2]]\n    return ''.join(chars)"
  },
  {
    "task": "Matrix Corner Elements",
    "input": "A 2D list (matrix)",
    "output": "A list of the four corner elements of the matrix",
    "function_name": "get_matrix_corners",
    "code_1": "def get_matrix_corners(matrix):\n    # Return an empty list if the matrix is empty or has no columns\n    if not matrix or not matrix[0]:\n        return []\n    # Extract corner elements\n    top_left = matrix[0][0]\n    top_right = matrix[0][-1]\n    bottom_left = matrix[-1][0]\n    bottom_right = matrix[-1][-1]\n    return [top_left, top_right, bottom_left, bottom_right]",
    "code_2": "def get_matrix_corners(matrix):\n    # Return [] for empty matrix or no columns\n    if not (matrix and matrix[0]):\n        return []\n    # Define corner positions\n    coords = [(0, 0), (0, -1), (-1, 0), (-1, -1)]\n    # Extract and return corner elements\n    return [matrix[i][j] for i, j in coords]"
  },
  {
    "task": "Sum of Alphabetical Distances",
    "input": "A lowercase string",
    "output": "The sum of distances between consecutive characters based on their positions in the alphabet (a\u2192b distance=1)",
    "function_name": "sum_alphabetical_distances",
    "code_1": "def sum_alphabetical_distances(s):\n    total = 0\n    for i in range(1, len(s)):\n        total += abs(ord(s[i]) - ord(s[i-1]))\n    return total",
    "code_2": "def sum_alphabetical_distances(s):\n    # use a generator expression with zip to pair consecutive chars\n    return sum(\n        abs(ord(c1) - ord(c2))\n        for c1, c2 in zip(s, s[1:])\n    )"
  },
  {
    "task": "Average Min Max",
    "input": "A list of numbers",
    "output": "The average (float) of the minimum and maximum values in the list",
    "function_name": "average_min_max",
    "code_1": "def average_min_max(numbers):\n    \"\"\"Return the average of the minimum and maximum values in the list.\"\"\"\n    if not numbers:\n        raise ValueError(\"The input list must contain at least one number.\")\n    min_val = min(numbers)\n    max_val = max(numbers)\n    return (min_val + max_val) / 2.0",
    "code_2": "def average_min_max(numbers):\n    \"\"\"Return the average of the minimum and maximum values in the list using sorting.\"\"\"\n    if not numbers:\n        raise ValueError(\"The input list must contain at least one number.\")\n    low, *_, high = sorted(numbers)\n    return (low + high) / 2.0\n"
  },
  {
    "task": "Triangle Pattern List",
    "input": "A character and an integer n",
    "output": "A list of n strings forming a right triangle pattern using the character",
    "function_name": "triangle_pattern_list",
    "code_1": "def triangle_pattern_list(char, n):\n    result = []\n    for i in range(1, n + 1):\n        result.append(char * i)\n    return result",
    "code_2": "def triangle_pattern_list(char, n):\n    from itertools import accumulate, repeat\n    # accumulate successive concatenations of the character\n    return list(accumulate(repeat(char, n), lambda a, b: a + b))"
  },
  {
    "task": "Censor Forbidden Words",
    "input": "A string and a list of forbidden words",
    "output": "The string with each forbidden word replaced by asterisks (*) of the same length",
    "function_name": "censor_forbidden_words",
    "code_1": "def censor_forbidden_words(text, forbidden_words):\n    \"\"\"\n    Replaces each occurrence of the forbidden words in the input text with asterisks (*) of the same length.\n\n    Args:\n        text (str): The input string to be filtered.\n        forbidden_words (list of str): List of words to censor.\n\n    Returns:\n        str: The censored string.\n    \"\"\"\n    for word in forbidden_words:\n        if not word:\n            continue\n        replacement = '*' * len(word)\n        text = text.replace(word, replacement)\n    return text",
    "code_2": "def censor_forbidden_words(text, forbidden_words):\n    import re\n    # Escape and filter out empty forbidden words\n    patterns = [re.escape(w) for w in forbidden_words if w]\n    if not patterns:\n        return text\n    # Compile a single pattern to match any forbidden word\n    regex = re.compile('|'.join(patterns))\n    # Replace each match with asterisks of equal length\n    return regex.sub(lambda match: '*' * len(match.group()), text)"
  },
  {
    "task": "String to ASCII code_1s",
    "input": "A string",
    "output": "A list of ASCII integer code_1s corresponding to each character",
    "function_name": "string_to_ascii",
    "code_1": "def string_to_ascii(s):\n    # Convert each character in the string to its ASCII code_1\n    return [ord(c) for c in s]",
    "code_2": "def string_to_ascii(s):\n    from functools import reduce\n    # Use reduce to accumulate ASCII codes into a list\n    return reduce(lambda acc, ch: acc + [ord(ch)], s, [])"
  },
  {
    "task": "Count Vowel Triplets",
    "input": "A string",
    "output": "The count of substrings of length three containing only vowels (a, e, i, o, u)",
    "function_name": "count_vowel_triplets",
    "code_1": "def count_vowel_triplets(s):\n    vowels = set('aeiou')\n    sl = s.lower()\n    count = 0\n    for i in range(len(sl) - 2):\n        if all(ch in vowels for ch in sl[i:i+3]):\n            count += 1\n    return count",
    "code_2": "import re\n\ndef count_vowel_triplets(s):\n    return sum(1 for _ in re.finditer(r'(?=(?:[aeiou]{3}))', s, flags=re.IGNORECASE))"
  },
  {
    "task": "Multiply Elements by Index",
    "input": "list of integers",
    "output": "list of integers where each element is the original value multiplied by its index in the list",
    "function_name": "multiply_elements_by_index",
    "code_1": "def multiply_elements_by_index(nums):\n    \"\"\"\n    Multiply each element in the list by its index.\n\n    Args:\n        nums (list of int): The input list of integers.\n\n    Returns:\n        list of int: New list where each element is original value times its index.\n    \"\"\"\n    result = []\n    for index, value in enumerate(nums):\n        result.append(index * value)\n    return result",
    "code_2": "def multiply_elements_by_index(nums):\n    return [i * nums[i] for i in range(len(nums))]"
  },
  {
    "task": "Count Numbers with Prime Digit Sum",
    "input": "list of positive integers",
    "output": "integer count of how many numbers have a sum of digits that is a prime number",
    "function_name": "count_prime_digit_sum",
    "code_1": "def count_prime_digit_sum(nums):\n    def is_prime(n):\n        if n < 2:\n            return False\n        i = 2\n        while i * i <= n:\n            if n % i == 0:\n                return False\n            i += 1\n        return True\n    count = 0\n    for num in nums:\n        digit_sum = sum(int(d) for d in str(num))\n        if is_prime(digit_sum):\n            count += 1\n    return count",
    "code_2": "def count_prime_digit_sum(nums):\n    # Precompute primes up to the maximum possible digit sum using a sieve\n    if not nums:\n        return 0\n    # Determine the upper bound for digit sums (max digits * 9)\n    max_sum = max(len(str(n)) for n in nums) * 9\n    sieve = [True] * (max_sum + 1)\n    sieve[0:2] = [False, False]\n    for i in range(2, int(max_sum**0.5) + 1):\n        if sieve[i]:\n            sieve[i*i:max_sum+1:i] = [False] * (((max_sum - i*i) // i) + 1)\n    prime_sums = {i for i, is_p in enumerate(sieve) if is_p}\n\n    # Count numbers whose digit sum is in the prime set\n    return sum(1 for n in nums if sum(map(int, str(n))) in prime_sums)"
  },
  {
    "task": "Replace List Elements by Rank",
    "input": "list of distinct numbers",
    "output": "list of integers where each number is replaced by its rank (1 for smallest, 2 for next smallest, etc.)",
    "function_name": "replace_with_rank",
    "code_1": "def replace_with_rank(nums):\n    sorted_nums = sorted(nums)\n    ranks = {num: i+1 for i, num in enumerate(sorted_nums)}\n    return [ranks[num] for num in nums]",
    "code_2": "def replace_with_rank(nums):\n    # Create a list to hold ranks matching original positions\n    ranks = [0] * len(nums)\n    # Sort indices by their corresponding value and assign ranks\n    for rank, idx in enumerate(sorted(range(len(nums)), key=lambda i: nums[i]), start=1):\n        ranks[idx] = rank\n    return ranks"
  },
  {
    "task": "Remove Sublist",
    "input": "list of any items, integer start index, integer end index",
    "output": "list with elements from start index (inclusive) up to end index (exclusive) removed",
    "function_name": "remove_sublist",
    "code_1": "def remove_sublist(lst, start, end):\n    \"\"\"Return a new list with elements from index start (inclusive) to end (exclusive) removed.\"\"\"\n    # Use slicing to omit the specified range\n    return lst[:start] + lst[end:]",
    "code_2": "def remove_sublist(lst, start, end):\n    return [item for i, item in enumerate(lst) if i < start or i >= end]"
  },
  {
    "task": "Separate Negative and Non-Negative Numbers",
    "input": "list of integers",
    "output": "tuple of two lists: first list of all negative numbers, second list of all non-negative numbers in their original order",
    "function_name": "separate_negatives",
    "code_1": "def separate_negatives(nums):\n    negatives = []\n    non_negatives = []\n    for num in nums:\n        if num < 0:\n            negatives.append(num)\n        else:\n            non_negatives.append(num)\n    return negatives, non_negatives",
    "code_2": "def separate_negatives(nums):\n    # Use list comprehensions to partition the list\n    negatives = [n for n in nums if n < 0]\n    non_negatives = [n for n in nums if n >= 0]\n    return negatives, non_negatives"
  },
  {
    "task": "Integer Bit Parity",
    "input": "non-negative integer",
    "output": "1 if the number of set bits in its binary representation is odd, otherwise 0",
    "function_name": "bit_parity",
    "code_1": "def bit_parity(n):\n    \"\"\"Return 1 if the number of set bits in n is odd, else 0.\"\"\"\n    # Using Python 3.8+'s int.bit_count() for efficiency\n    return n.bit_count() % 2",
    "code_2": "def bit_parity(n):\n    \"\"\"Return 1 if the number of set bits in n is odd, else 0.\"\"\"\n    parity = 0\n    while n:\n        # flip parity if lowest bit is set\n        parity ^= (n & 1)\n        n >>= 1\n    return parity\n"
  },
  {
    "task": "Secondary Diagonal Sum",
    "input": "square matrix as a list of lists of numbers",
    "output": "sum of the elements on the secondary (anti-) diagonal of the matrix",
    "function_name": "secondary_diagonal_sum",
    "code_1": "def secondary_diagonal_sum(matrix):\n    \"\"\"Return the sum of the secondary (anti-) diagonal of a square matrix.\"\"\"\n    n = len(matrix)\n    # Sum elements where column index is (n - i - 1)\n    return sum(matrix[i][n - i - 1] for i in range(n))",
    "code_2": "def secondary_diagonal_sum(matrix):\n    \"\"\"Return the sum of the secondary (anti-) diagonal of a square matrix.\"\"\"\n    # Reverse the row order and pick the i-th element from each\n    return sum(row[i] for i, row in enumerate(reversed(matrix)))"
  },
  {
    "task": "FizzBuzz List",
    "input": "integer n",
    "output": "list of length n where for each position i (1-indexed): \u201cFizz\u201d if i divisible by 3, \u201cBuzz\u201d if divisible by 5, \u201cFizzBuzz\u201d if divisible by both, otherwise the integer i",
    "function_name": "fizz_buzz_list",
    "code_1": "def fizz_buzz_list(n):\n    result = []\n    for i in range(1, n+1):\n        if i % 15 == 0:\n            result.append(\"FizzBuzz\")\n        elif i % 3 == 0:\n            result.append(\"Fizz\")\n        elif i % 5 == 0:\n            result.append(\"Buzz\")\n        else:\n            result.append(i)\n    return result",
    "code_2": "def fizz_buzz_list(n):\n    return [((('Fizz' if i % 3 == 0 else '') + ('Buzz' if i % 5 == 0 else '')) or i) for i in range(1, n+1)]"
  },
  {
    "task": "Generate Multiples",
    "input": "two integers num and count",
    "output": "list of integers containing the first count multiples of num",
    "function_name": "generate_multiples",
    "code_1": "def generate_multiples(num, count):\n    \"\"\"Return a list containing the first 'count' multiples of 'num'.\"\"\"\n    return [num * i for i in range(1, count + 1)]",
    "code_2": "def generate_multiples(num, count):\n    from itertools import accumulate, repeat\n    # accumulate sums a repeated sequence of 'num' to produce multiples\n    return list(accumulate(repeat(num, count)))"
  },
  {
    "task": "Nearest Neighbor Distances",
    "input": "sorted list of numbers",
    "output": "list of floats where each element is the minimum absolute difference between that element and its nearest neighbor in the list",
    "function_name": "nearest_neighbor_distances",
    "code_1": "def nearest_neighbor_distances(sorted_list):\n    \"\"\"\n    Given a sorted list of numbers, return a list of floats where each element\n    is the minimum absolute difference between that element and its nearest neighbor.\n    \"\"\"\n    n = len(sorted_list)\n    if n == 0:\n        return []\n    distances = []\n    for i in range(n):\n        if n == 1:\n            dist = 0.0\n        elif i == 0:\n            dist = sorted_list[1] - sorted_list[0]\n        elif i == n - 1:\n            dist = sorted_list[n - 1] - sorted_list[n - 2]\n        else:\n            left_diff = sorted_list[i] - sorted_list[i - 1]\n            right_diff = sorted_list[i + 1] - sorted_list[i]\n            dist = left_diff if left_diff < right_diff else right_diff\n        distances.append(float(dist))\n    return distances",
    "code_2": "def nearest_neighbor_distances(sorted_list):\n    \"\"\"\n    Given a sorted list of numbers, return a list of floats where each element\n    is the minimum absolute difference between that element and its nearest neighbor.\n    \"\"\"\n    n = len(sorted_list)\n    if n == 0:\n        return []\n    if n == 1:\n        return [0.0]\n    # compute differences between consecutive elements\n    diffs = [b - a for a, b in zip(sorted_list, sorted_list[1:])]\n    # build result: first and last have only one neighbor\n    result = [diffs[0]]\n    # internal points take the smaller of adjacent diffs\n    result += [min(diffs[i-1], diffs[i]) for i in range(1, n-1)]\n    result.append(diffs[-1])\n    # cast to float\n    return [float(d) for d in result]"
  },
  {
    "task": "Matrix Multiplication Compatibility",
    "input": "two matrices represented as lists of lists of numbers",
    "output": "boolean indicating whether the number of columns in the first equals the number of rows in the second",
    "function_name": "is_multiplication_compatible",
    "code_1": "def is_multiplication_compatible(matrix1, matrix2):\n    \"\"\"Return True if the number of columns in matrix1 equals the number of rows in matrix2.\"\"\"\n    # Check for empty matrices\n    if not matrix1 or not matrix2:\n        return False\n    # Ensure matrix1 has at least one row with uniform column count\n    cols1 = len(matrix1[0])\n    # Number of rows in matrix2\n    rows2 = len(matrix2)\n    return cols1 == rows2",
    "code_2": "def is_multiplication_compatible(matrix1, matrix2):\n    # Return False if either matrix is empty\n    if not matrix1 or not matrix2:\n        return False\n    # Determine number of columns in matrix1 by transposing it\n    cols1 = len(list(zip(*matrix1)))\n    # Number of rows in matrix2\n    rows2 = len(matrix2)\n    return cols1 == rows2"
  },
  {
    "task": "Find Local Maxima Indices",
    "input": "list of numbers",
    "output": "list of integer indices where each element is strictly greater than its immediate neighbors",
    "function_name": "find_local_maxima_indices",
    "code_1": "def find_local_maxima_indices(nums):\n    \"\"\"Return list of indices where each element is strictly greater than its immediate neighbors.\"\"\"\n    result = []\n    for i in range(1, len(nums) - 1):\n        if nums[i] > nums[i - 1] and nums[i] > nums[i + 1]:\n            result.append(i)\n    return result",
    "code_2": "def find_local_maxima_indices(nums):\n    # use sliding window via zip and enumerate\n    return [i+1 for i, (a, b, c) in enumerate(zip(nums, nums[1:], nums[2:])) if b > a and b > c]\n"
  },
  {
    "task": "Three List Intersection",
    "input": "three lists of integers",
    "output": "list of integers present in all three input lists",
    "function_name": "three_list_intersection",
    "code_1": "def three_list_intersection(list1, list2, list3):\n    set2, set3 = set(list2), set(list3)\n    seen = set()\n    result = []\n    for x in list1:\n        if x in set2 and x in set3 and x not in seen:\n            result.append(x)\n            seen.add(x)\n    return result",
    "code_2": "def three_list_intersection(list1, list2, list3):\n    # compute common elements of list2 and list3\n    common = set(list2) & set(list3)\n    # filter list1 by those common values\n    filtered = [x for x in list1 if x in common]\n    # use dict.fromkeys to remove duplicates while preserving order\n    return list(dict.fromkeys(filtered))"
  },
  {
    "task": "Count Palindromic Substrings",
    "input": "string",
    "output": "integer count of all substrings of the input that are palindromes (length \u2265 1)",
    "function_name": "count_palindromic_substrings",
    "code_1": "def count_palindromic_substrings(s):\n    n = len(s)\n    count = 0\n    for center in range(n):\n        # odd length palindromes\n        left = right = center\n        while left >= 0 and right < n and s[left] == s[right]:\n            count += 1\n            left -= 1\n            right += 1\n        # even length palindromes\n        left, right = center, center + 1\n        while left >= 0 and right < n and s[left] == s[right]:\n            count += 1\n            left -= 1\n            right += 1\n    return count",
    "code_2": "def count_palindromic_substrings(s):\n    n = len(s)\n    # dp[i][j] will be True if s[i:j+1] is a palindrome\n    dp = [[False] * n for _ in range(n)]\n    count = 0\n    # Build table bottom-up: start from the end to ensure dp[i+1][j-1] is ready\n    for i in range(n - 1, -1, -1):\n        for j in range(i, n):\n            if s[i] == s[j] and (j - i < 2 or dp[i + 1][j - 1]):\n                dp[i][j] = True\n                count += 1\n    return count"
  },
  {
    "task": "First Duplicate Finder",
    "input": "list of elements",
    "output": "the first element that appears more than once, or None if there are no duplicates",
    "function_name": "find_first_duplicate",
    "code_1": "def find_first_duplicate(lst):\n    \"\"\"\n    Returns the first element in the list that appears more than once.\n    If no duplicates are found, returns None.\n    \"\"\"\n    seen = set()\n    for element in lst:\n        if element in seen:\n            return element\n        seen.add(element)\n    return None",
    "code_2": "def find_first_duplicate(lst):\n    from collections import Counter\n    counts = Counter(lst)\n    earliest_second = None\n    result = None\n    for elem, cnt in counts.items():\n        if cnt > 1:\n            first_idx = lst.index(elem)\n            second_idx = lst.index(elem, first_idx + 1)\n            if earliest_second is None or second_idx < earliest_second:\n                earliest_second = second_idx\n                result = elem\n    return result"
  },
  {
    "task": "Circle Circumference Calculator",
    "input": "float radius",
    "output": "float circumference of the circle (2 * pi * radius)",
    "function_name": "calculate_circumference",
    "code_1": "def calculate_circumference(radius):\n    import math\n    return 2 * math.pi * radius",
    "code_2": "def calculate_circumference(radius):\n    from math import tau\n    \"\"\"Compute the circumference using tau (2\u03c0) constant.\"\"\"\n    return radius * tau"
  },
  {
    "task": "Count Distinct Substrings of Length K",
    "input": "a string and an integer k",
    "output": "integer count of distinct substrings of length k in the string",
    "function_name": "count_distinct_substrings",
    "code_1": "def count_distinct_substrings(s, k):\n    \"\"\"\n    Count the number of distinct substrings of length k in string s.\n    :param s: input string\n    :param k: length of substrings to consider\n    :return: count of distinct substrings of length k\n    \"\"\"\n    if k <= 0 or k > len(s):\n        return 0\n    seen = set()\n    for i in range(len(s) - k + 1):\n        seen.add(s[i:i+k])\n    return len(seen)",
    "code_2": "def count_distinct_substrings(s, k):\n    if k < 1 or k > len(s):\n        return 0\n    # Generate all length-k sliding windows via zip and collect unique ones\n    windows = zip(*(s[i:] for i in range(k)))\n    return len({''.join(window) for window in windows})"
  },
  {
    "task": "Kilometer to Mile Converter",
    "input": "float kilometers",
    "output": "float miles (using the conversion 1 km = 0.621371 miles)",
    "function_name": "kilometers_to_miles",
    "code_1": "def kilometers_to_miles(kilometers):\n    \"\"\"Convert kilometers to miles using the factor 1 km = 0.621371 miles.\"\"\"\n    return kilometers * 0.621371\n",
    "code_2": "def kilometers_to_miles(kilometers):\n    \"\"\"Convert kilometers to miles via meters: 1 mile = 1609.344 meters.\"\"\"\n    meters = kilometers * 1000\n    return meters / 1609.344"
  },
  {
    "task": "Filter Dictionary by Value Threshold",
    "input": "a dictionary with comparable values and a threshold value",
    "output": "a dictionary containing only the key\u2013value pairs whose values are greater than the threshold",
    "function_name": "filter_dict_by_threshold",
    "code_1": "def filter_dict_by_threshold(d, threshold):\n    '''Return a dictionary containing only the key\u2013value pairs whose values are greater than threshold.'''\n    return {k: v for k, v in d.items() if v > threshold}",
    "code_2": "def filter_dict_by_threshold(d, threshold):\n    \"\"\"Return a dictionary containing only the key\u2013value pairs whose values are greater than threshold.\"\"\"\n    return dict(filter(lambda kv: kv[1] > threshold, d.items()))"
  },
  {
    "task": "Sum of Geometric Series",
    "input": "float first_term, float ratio, int n",
    "output": "float (sum of first n terms)",
    "function_name": "sum_geometric_series",
    "code_1": "def sum_geometric_series(first_term, ratio, n):\n    \"\"\"\n    Calculate the sum of the first n terms of a geometric series.\n    first_term: the first term of the series (float)\n    ratio: the common ratio of the series (float)\n    n: number of terms (int)\n    Returns the sum as a float.\n    \"\"\"\n    if n <= 0:\n        return 0.0\n    if ratio == 1:\n        return first_term * n\n    return first_term * (1 - ratio ** n) / (1 - ratio)",
    "code_2": "def sum_geometric_series(first_term, ratio, n):\n    \"\"\"\n    Calculate the sum of the first n terms of a geometric series by iterating.\n    first_term: the first term of the series (float)\n    ratio: the common ratio of the series (float)\n    n: number of terms (int)\n    Returns the sum as a float.\n    \"\"\"\n    total = 0.0\n    term = first_term\n    for _ in range(n):\n        total += term\n        term *= ratio\n    return total\n"
  },
  {
    "task": "RGB to Grayscale",
    "input": "three ints R, G, B (each 0\u2013255)",
    "output": "int (grayscale value 0\u2013255)",
    "function_name": "rgb_to_grayscale",
    "code_1": "def rgb_to_grayscale(R, G, B):\n    # Convert RGB to grayscale using the luminance method\n    gray = int(0.299 * R + 0.587 * G + 0.114 * B)\n    # Ensure the result is within the valid range\n    return max(0, min(255, gray))",
    "code_2": "def rgb_to_grayscale(R, G, B):\n    \"\"\"Convert RGB to grayscale using an integer fixed-point approximation.\"\"\"\n    # Fixed\u2010point weights scaled by 2^16 (~0.299, 0.587, 0.114)\n    lum = (19562 * R + 38550 * G +  7424 * B) >> 16\n    # Clamp to valid 0\u2013255 range\n    return max(0, min(255, lum))"
  },
  {
    "task": "Cylinder Volume Calculator",
    "input": "float radius and float height",
    "output": "float volume of the cylinder (pi * radius^2 * height)",
    "function_name": "calculate_cylinder_volume",
    "code_1": "import math\n\ndef calculate_cylinder_volume(radius, height):\n    \"\"\"Return the volume of a cylinder given its radius and height.\"\"\"\n    return math.pi * radius**2 * height",
    "code_2": "def calculate_cylinder_volume(radius, height):\n    \"\"\"Compute the volume of a cylinder by deriving \u03c0 via the arccosine function.\"\"\"\n    from math import acos, pow\n    pi = acos(-1)\n    return pi * pow(radius, 2) * height"
  },
  {
    "task": "3D Distance Calculator",
    "input": "two tuples of floats (x1, y1, z1) and (x2, y2, z2)",
    "output": "float (Euclidean distance)",
    "function_name": "calculate_distance_3d",
    "code_1": "def calculate_distance_3d(point1, point2):\n    \"\"\"Calculate the Euclidean distance between two points in 3D space.\"\"\"\n    x1, y1, z1 = point1\n    x2, y2, z2 = point2\n    return ((x2 - x1)**2 + (y2 - y1)**2 + (z2 - z1)**2) ** 0.5",
    "code_2": "import math\n\ndef calculate_distance_3d(point1, point2):\n    '''Calculate the Euclidean distance between two points in 3D space.'''\n    # Compute component differences and use math.hypot for Euclidean norm\n    diffs = (b - a for a, b in zip(point1, point2))\n    return math.hypot(*diffs)\n"
  },
  {
    "task": "ASCII Only Check",
    "input": "str",
    "output": "bool (True if all characters are in ASCII range)",
    "function_name": "is_ascii",
    "code_1": "def is_ascii(s):\n    \"\"\"Return True if all characters in the string are in the ASCII range (0-127).\"\"\"\n    return all(ord(c) < 128 for c in s)",
    "code_2": "def is_ascii(s):\n    \"\"\"Return True if all characters in the string are in the ASCII range (0-127).\"\"\"\n    try:\n        s.encode('ascii')\n    except UnicodeEncodeError:\n        return False\n    return True"
  },
  {
    "task": "Extract Integers",
    "input": "list of mixed types",
    "output": "list of ints (all integer elements in original order)",
    "function_name": "extract_integers",
    "code_1": "def extract_integers(input_list):\n    \"\"\"Return a list of integer elements from the input list, preserving order.\"\"\"\n    return [item for item in input_list if type(item) is int]",
    "code_2": "def extract_integers(input_list):\n    '''Return a list of integer elements from the input list, preserving order.'''\n    return list(filter(lambda v: type(v) is int, input_list))"
  },
  {
    "task": "Even Digit Count",
    "input": "list of non-negative ints",
    "output": "int (count of numbers with an even number of digits)",
    "function_name": "even_digit_count",
    "code_1": "def even_digit_count(nums):\n    \"\"\"\n    Given a list of non-negative integers, return the count of numbers that have an even number of digits.\n    \"\"\"\n    count = 0\n    for n in nums:\n        if len(str(n)) % 2 == 0:\n            count += 1\n    return count",
    "code_2": "def even_digit_count(nums):\n    def count_digits(n):\n        if n == 0:\n            return 1\n        digits = 0\n        while n:\n            n //= 10\n            digits += 1\n        return digits\n    return sum(1 for x in nums if count_digits(x) % 2 == 0)"
  },
  {
    "task": "Matrix Column Sum",
    "input": "list of equal-length lists of numbers",
    "output": "list of numbers (sum of each column)",
    "function_name": "column_sums",
    "code_1": "def column_sums(matrix):\n    # If the matrix is empty, return an empty list\n    if not matrix:\n        return []\n    # Determine the number of columns from the first row\n    num_cols = len(matrix[0])\n    # Initialize a list of zeros for the column sums\n    sums = [0] * num_cols\n    # Iterate over each row and add each element to the corresponding column sum\n    for row in matrix:\n        for i, val in enumerate(row):\n            sums[i] += val\n    return sums",
    "code_2": "def column_sums(matrix):\n    # Use zip to transpose rows into columns and sum each column\n    if not matrix:\n        return []\n    return [sum(col) for col in zip(*matrix)]\n"
  },
  {
    "task": "Pandigital Number Check",
    "input": "int number",
    "output": "bool (True if number contains each digit from 1 to n exactly once)",
    "function_name": "is_pandigital",
    "code_1": "def is_pandigital(number):\n    # A pandigital number of length n must contain each digit from 1 to n exactly once\n    if number <= 0:\n        return False\n    s = str(number)\n    n = len(s)\n    # Required digits are '1' through str(n)\n    required = {str(i) for i in range(1, n+1)}\n    # Check that the set of digits matches required digits\n    return set(s) == required",
    "code_2": "def is_pandigital(number):\n    if number < 1:\n        return False\n    mask = 0\n    length = 0\n    num = number\n    while num > 0:\n        digit = num % 10\n        if digit == 0:\n            return False\n        bit = 1 << digit\n        if mask & bit:\n            return False\n        mask |= bit\n        length += 1\n        num //= 10\n    # Check bits 1 through length are all set\n    return mask == ((1 << (length + 1)) - 2)"
  },
  {
    "task": "Compress Number Ranges",
    "input": "sorted list of ints",
    "output": "list of strings (consecutive runs as \"start-end\", singles as \"num\")",
    "function_name": "compress_ranges",
    "code_1": "def compress_ranges(nums):\n    if not nums:\n        return []\n    result = []\n    start = prev = nums[0]\n    for n in nums[1:]:\n        if n == prev + 1:\n            prev = n\n        else:\n            if start == prev:\n                result.append(str(start))\n            else:\n                result.append(f'{start}-{prev}')\n            start = prev = n\n    if start == prev:\n        result.append(str(start))\n    else:\n        result.append(f'{start}-{prev}')\n    return result",
    "code_2": "def compress_ranges(nums):\n    from itertools import groupby\n    ranges = []\n    # group by the difference between value and index to find consecutive runs\n    for _, group in groupby(enumerate(nums), key=lambda x: x[1] - x[0]):\n        seq = [n for _, n in group]\n        if len(seq) == 1:\n            ranges.append(str(seq[0]))\n        else:\n            ranges.append(f\"{seq[0]}-{seq[-1]}\")\n    return ranges"
  },
  {
    "task": "HTML Entity Decode_1r",
    "input": "str containing HTML entities (&amp;, &lt;, &gt;, &quot;, &#39;)",
    "output": "str (decode_1d text)",
    "function_name": "decode_1_html_entities",
    "code_1": "def decode_1_html_entities(text):\n    replacements = {\"&amp;\": \"&\", \"&lt;\": \"<\", \"&gt;\": \">\", \"&quot;\": \"\\\"\", \"&#39;\": \"'\"}\n    for entity, char in replacements.items():\n        text = text.replace(entity, char)\n    return text",
    "code_2": "import re\ndef decode_1_html_entities(text):\n    mapping = {\"amp\": \"&\", \"lt\": \"<\", \"gt\": \">\", \"quot\": \"\\\"\", \"#39\": \"'\"}\n    return re.sub(r'&(amp|lt|gt|quot|#39);', lambda m: mapping[m.group(1)], text)"
  },
  {
    "task": "Month Name Converter",
    "input": "integer (1\u201312)",
    "output": "string (month name, e.g. \"January\")",
    "function_name": "get_month_name",
    "code_1": "def get_month_name(month_number):\n    \"\"\"\n    Convert an integer (1\u201312) to its corresponding month name.\n\n    Args:\n        month_number (int): An integer between 1 and 12.\n\n    Returns:\n        str: The name of the month.\n\n    Raises:\n        ValueError: If month_number is not between 1 and 12.\n    \"\"\"\n    months = [\n        \"January\", \"February\", \"March\", \"April\", \"May\", \"June\",\n        \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"\n    ]\n    if not isinstance(month_number, int) or not 1 <= month_number <= 12:\n        raise ValueError(\"month_number must be an integer between 1 and 12\")\n    return months[month_number - 1]",
    "code_2": "def get_month_name(month_number):\n    '''\n    Convert an integer (1-12) to its corresponding month name using datetime.\n\n    Args:\n        month_number (int): An integer between 1 and 12.\n\n    Returns:\n        str: The name of the month.\n\n    Raises:\n        ValueError: If month_number is not between 1 and 12.\n    '''\n    import datetime\n    try:\n        # Use a fixed date to leverage strftime for month names\n        return datetime.date(2000, month_number, 1).strftime('%B')\n    except (ValueError, TypeError):\n        raise ValueError(\"month_number must be an integer between 1 and 12\")\n"
  },
  {
    "task": "Age Group Classifier",
    "input": "integer (age)",
    "output": "string (\"Child\", \"Teen\", \"Adult\" or \"Senior\")",
    "function_name": "classify_age_group",
    "code_1": "def classify_age_group(age):\n    if age < 13:\n        return \"Child\"\n    elif age < 20:\n        return \"Teen\"\n    elif age < 65:\n        return \"Adult\"\n    else:\n        return \"Senior\"",
    "code_2": "def classify_age_group(age):\n    from bisect import bisect_right\n    boundaries = [13, 20, 65]\n    labels = [\"Child\", \"Teen\", \"Adult\", \"Senior\"]\n    return labels[bisect_right(boundaries, age)]"
  },
  {
    "task": "Atbash Cipher",
    "input": "string",
    "output": "string (Atbash\u2010encode_1d text)",
    "function_name": "atbash_cipher",
    "code_1": "def atbash_cipher(s):\n    result = []\n    for c in s:\n        if 'A' <= c <= 'Z':\n            result.append(chr(ord('Z') - (ord(c) - ord('A'))))\n        elif 'a' <= c <= 'z':\n            result.append(chr(ord('z') - (ord(c) - ord('a'))))\n        else:\n            result.append(c)\n    return ''.join(result)",
    "code_2": "import string\n\ndef atbash_cipher(s):\n    # Build translation table mapping A-Z and a-z to their Atbash counterparts\n    forward = string.ascii_uppercase + string.ascii_lowercase\n    backward = forward[::-1]\n    table = str.maketrans(forward, backward)\n    return s.translate(table)"
  },
  {
    "task": "Sum of Prime Digits",
    "input": "integer",
    "output": "integer (sum of digits that are 2, 3, 5 or 7)",
    "function_name": "sum_prime_digits",
    "code_1": "def sum_prime_digits(n):\n    s = str(abs(n))\n    primes = {'2', '3', '5', '7'}\n    return sum(int(ch) for ch in s if ch in primes)",
    "code_2": "def sum_prime_digits(n):\n    n = abs(n)\n    primes = {2, 3, 5, 7}\n    total = 0\n    while n:\n        digit = n % 10\n        if digit in primes:\n            total += digit\n        n //= 10\n    return total"
  },
  {
    "task": "Split Digits by Parity",
    "input": "integer",
    "output": "two lists of integers: (even_digits, odd_digits)",
    "function_name": "split_digits_by_parity",
    "code_1": "def split_digits_by_parity(n):\n    even_digits = []\n    odd_digits = []\n    for digit in str(abs(n)):\n        d = int(digit)\n        if d % 2 == 0:\n            even_digits.append(d)\n        else:\n            odd_digits.append(d)\n    return even_digits, odd_digits",
    "code_2": "def split_digits_by_parity(n):\n    n_abs = abs(n)\n    if n_abs == 0:\n        return [0], []\n    evens, odds = [], []\n    while n_abs:\n        d = n_abs % 10\n        (evens if d % 2 == 0 else odds).append(d)\n        n_abs //= 10\n    return evens[::-1], odds[::-1]"
  },
  {
    "task": "Replace with First Occurrence Index",
    "input": "list of elements",
    "output": "list of integers where each element is replaced by the index of its first occurrence",
    "function_name": "first_occurrence_indices",
    "code_1": "def first_occurrence_indices(lst):\n    index_map = {}\n    result = []\n    for i, el in enumerate(lst):\n        if el not in index_map:\n            index_map[el] = i\n        result.append(index_map[el])\n    return result",
    "code_2": "def first_occurrence_indices(lst):\n    # Use list.index to find the first occurrence of each element\n    return [lst.index(el) for el in lst]"
  },
  {
    "task": "Add Two Matrices",
    "input": "two lists of lists of numbers of equal dimensions",
    "output": "list of lists of numbers (element-wise sum)",
    "function_name": "add_matrices",
    "code_1": "def add_matrices(A, B):\n    \"\"\"\n    Add two matrices A and B of equal dimensions element-wise.\n    \"\"\"\n    # Check if the outer dimensions match\n    if len(A) != len(B):\n        raise ValueError(\"Matrices must have the same number of rows\")\n    # Check if each corresponding row has the same length\n    for row_a, row_b in zip(A, B):\n        if len(row_a) != len(row_b):\n            raise ValueError(\"Matrices must have the same number of columns in each row\")\n    # Compute element-wise sum\n    return [[a + b for a, b in zip(row_a, row_b)] for row_a, row_b in zip(A, B)]",
    "code_2": "def add_matrices(A, B):\n    \"\"\"\n    Add two matrices A and B of equal dimensions element-wise.\n    \"\"\"\n    # Ensure same number of rows\n    if len(A) != len(B):\n        raise ValueError(\"Matrices must have the same number of rows\")\n    # Ensure each row pair has same length\n    if any(len(row_a) != len(row_b) for row_a, row_b in zip(A, B)):\n        raise ValueError(\"Matrices must have the same number of columns in each row\")\n    # Use map and sum to compute each element-wise sum\n    return [list(map(sum, zip(row_a, row_b))) for row_a, row_b in zip(A, B)]"
  },
  {
    "task": "Second Most Frequent Element",
    "input": "list of hashable elements",
    "output": "element (the one with the second highest frequency)",
    "function_name": "second_most_frequent",
    "code_1": "def second_most_frequent(lst):\n    from collections import Counter\n    # Count frequencies of each element\n    counts = Counter(lst)\n    # If fewer than 2 distinct elements, no second most frequent\n    if len(counts) < 2:\n        return None\n    # Get the two most common elements\n    two_most = counts.most_common(2)\n    # Return the element with the second highest frequency\n    return two_most[1][0]",
    "code_2": "def second_most_frequent(lst):\n    # Build frequency map manually\n    freq = {}\n    for item in lst:\n        freq[item] = freq.get(item, 0) + 1\n    # If fewer than two unique elements, return None\n    if len(freq) < 2:\n        return None\n    # Use heapq to find the two items with highest frequencies\n    import heapq\n    top_two = heapq.nlargest(2, freq.items(), key=lambda kv: kv[1])\n    # Return the element of the second entry\n    return top_two[1][0]"
  },
  {
    "task": "Word with Most Vowels",
    "input": "string (sentence)",
    "output": "string (word containing the highest number of vowels)",
    "function_name": "word_with_most_vowels",
    "code_1": "def word_with_most_vowels(sentence):\n    vowels = set(\"aeiouAEIOU\")\n    max_count = 0\n    result = \"\"\n    for word in sentence.split():\n        count = sum(1 for c in word if c in vowels)\n        if count > max_count:\n            max_count = count\n            result = word\n    return result",
    "code_2": "def word_with_most_vowels(sentence):\n    import re\n    # split the sentence and pick the word with the highest count of vowels using regex\n    return max(\n        sentence.split(),\n        key=lambda w: len(re.findall(r'[aeiou]', w, flags=re.I)),\n        default=\"\"\n    )"
  },
  {
    "task": "Double Characters",
    "input": "a string",
    "output": "a string where each character from the input is repeated twice",
    "function_name": "double_characters",
    "code_1": "def double_characters(s):\n    \"\"\"Return a string where each character in s is repeated twice.\"\"\"\n    return ''.join(c*2 for c in s)",
    "code_2": "import re\n\ndef double_characters(s):\n    return re.sub(r'(.)', r'\\1\\1', s)"
  },
  {
    "task": "Longest Unique-Character Substring",
    "input": "string",
    "output": "string (longest substring without repeating characters)",
    "function_name": "longest_unique_substring",
    "code_1": "def longest_unique_substring(s):\n    start = 0\n    max_len = 0\n    max_sub = \"\"\n    last_seen = {}\n    for i, c in enumerate(s):\n        if c in last_seen and last_seen[c] >= start:\n            start = last_seen[c] + 1\n        last_seen[c] = i\n        if i - start + 1 > max_len:\n            max_len = i - start + 1\n            max_sub = s[start:i+1]\n    return max_sub",
    "code_2": "def longest_unique_substring(s):\n    seen = set()\n    left = 0\n    best = \"\"\n    for right, char in enumerate(s):\n        while char in seen:\n            seen.remove(s[left])\n            left += 1\n        seen.add(char)\n        current = s[left:right+1]\n        if len(current) > len(best):\n            best = current\n    return best"
  },
  {
    "task": "Kebab to Snake Case",
    "input": "a string in kebab-case",
    "output": "the string converted to snake_case",
    "function_name": "kebab_to_snake",
    "code_1": "def kebab_to_snake(s):\n    \"\"\"Convert a kebab-case string to snake_case.\"\"\"\n    return s.replace('-', '_')",
    "code_2": "def kebab_to_snake(s):\n    \"\"\"Convert a kebab-case string to snake_case using str.translate.\"\"\"\n    trans = str.maketrans('-', '_')\n    return s.translate(trans)\n"
  },
  {
    "task": "Multiplicative Digital Root",
    "input": "a positive integer",
    "output": "the single-digit result obtained by repeatedly multiplying the digits until one digit remains",
    "function_name": "multiplicative_digital_root",
    "code_1": "def multiplicative_digital_root(n):\n    # Repeat multiplying digits until a single digit remains\n    while n >= 10:\n        prod = 1\n        for d in str(n):\n            prod *= int(d)\n        n = prod\n    return n",
    "code_2": "def multiplicative_digital_root(n):\n    if n < 10:\n        return n\n    from functools import reduce\n    prod = reduce(lambda a, b: a * b, (int(d) for d in str(n)), 1)\n    return multiplicative_digital_root(prod)"
  },
  {
    "task": "Longest Palindromic Word",
    "input": "a string containing words separated by spaces",
    "output": "the longest word in the input that reads the same forwards and backwards",
    "function_name": "longest_palindromic_word",
    "code_1": "def longest_palindromic_word(s):\n    \"\"\"Return the longest palindromic word in a space-separated string s.\"\"\"\n    max_word = \"\"\n    for word in s.split():\n        # Check if word is a palindrome\n        if word == word[::-1] and len(word) > len(max_word):\n            max_word = word\n    return max_word",
    "code_2": "def longest_palindromic_word(s):\n    \"\"\"Return the longest palindromic word in a space-separated string s.\"\"\"\n    # Use a generator to filter palindromes and max() to pick the longest\n    return max((w for w in s.split() if w == w[::-1]), key=len, default=\"\")"
  },
  {
    "task": "Sort Words by Last Character",
    "input": "a string containing words separated by spaces",
    "output": "a list of words sorted in ascending order by their last character",
    "function_name": "sort_words_by_last_char",
    "code_1": "def sort_words_by_last_char(s):\n    \"\"\"\n    Sort words in the input string by their last character in ascending order.\n\n    Args:\n        s (str): A string containing words separated by spaces.\n\n    Returns:\n        list: A list of words sorted by their last character.\n    \"\"\"\n    words = s.split()\n    # Sort using the last character of each word as the key\n    return sorted(words, key=lambda w: w[-1] if w else '')",
    "code_2": "def sort_words_by_last_char(s):\n    words = s.split()\n    sorted_list = []\n    for w in words:\n        last_char = w[-1] if w else ''\n        idx = 0\n        while idx < len(sorted_list) and (sorted_list[idx][-1] if sorted_list[idx] else '') <= last_char:\n            idx += 1\n        sorted_list.insert(idx, w)\n    return sorted_list"
  },
  {
    "task": "Chebyshev Distance",
    "input": "two tuples of equal length containing numeric coordinates",
    "output": "the Chebyshev distance (maximum absolute difference) between the two points",
    "function_name": "chebyshev_distance",
    "code_1": "def chebyshev_distance(point1, point2):\n    if len(point1) != len(point2):\n        raise ValueError(\"Points must have the same dimension\")\n    return max(abs(a - b) for a, b in zip(point1, point2))",
    "code_2": "def chebyshev_distance(point1, point2):\n    if len(point1) != len(point2):\n        raise ValueError(\"Points must have the same dimension\")\n    max_diff = 0\n    for idx, coord in enumerate(point1):\n        diff = abs(coord - point2[idx])\n        if diff > max_diff:\n            max_diff = diff\n    return max_diff"
  },
  {
    "task": "Swap Adjacent Characters",
    "input": "a string",
    "output": "a string where each pair of adjacent characters is swapped (if length is odd, last character remains)",
    "function_name": "swap_adjacent_chars",
    "code_1": "def swap_adjacent_chars(s):\n    result = []\n    for i in range(0, len(s) - 1, 2):\n        result.append(s[i+1])\n        result.append(s[i])\n    if len(s) % 2:\n        result.append(s[-1])\n    return ''.join(result)",
    "code_2": "def swap_adjacent_chars(s):\n    # Take slices of two characters and reverse each slice\n    return ''.join(s[i:i+2][::-1] for i in range(0, len(s), 2))"
  },
  {
    "task": "Integer to Gray code_1",
    "input": "a non-negative integer",
    "output": "a string representing the binary Gray code_1 of the input integer",
    "function_name": "integer_to_gray",
    "code_1": "def integer_to_gray(n):\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"Input must be a non-negative integer\")\n    gray = n ^ (n >> 1)\n    return bin(gray)[2:]",
    "code_2": "def integer_to_gray(n):\n    if type(n) is not int or n < 0:\n        raise ValueError('Input must be a non-negative integer')\n    b = format(n, 'b')\n    # first Gray bit is same as MSB\n    g = [b[0]]\n    # subsequent bits are XOR of adjacent bits in binary\n    for i in range(1, len(b)):\n        g.append('1' if b[i] != b[i-1] else '0')\n    return ''.join(g)"
  },
  {
    "task": "Find Local Minima Indices",
    "input": "List of numbers",
    "output": "List of indices where each element is strictly less than its immediate neighbors",
    "function_name": "find_local_minima_indices",
    "code_1": "def find_local_minima_indices(nums):\n    minima = []\n    for i in range(1, len(nums) - 1):\n        if nums[i] < nums[i - 1] and nums[i] < nums[i + 1]:\n            minima.append(i)\n    return minima",
    "code_2": "def find_local_minima_indices(nums):\n    # Compare sliding windows of size 3 using zip and enumerate\n    return [i for i, (l, m, r) in enumerate(zip(nums, nums[1:], nums[2:]), start=1) if m < l and m < r]"
  },
  {
    "task": "Collatz Sequence Generator",
    "input": "a positive integer",
    "output": "a list of integers representing the Collatz sequence starting from the input and ending at 1",
    "function_name": "generate_collatz_sequence",
    "code_1": "def generate_collatz_sequence(n):\n    \"\"\"Generate the Collatz sequence starting from a positive integer n and ending at 1.\"\"\"\n    sequence = []\n    while n != 1:\n        sequence.append(n)\n        if n % 2 == 0:\n            n //= 2\n        else:\n            n = 3 * n + 1\n    sequence.append(1)\n    return sequence",
    "code_2": "def generate_collatz_sequence(n):\n    \"\"\"Generate the Collatz sequence starting from n and ending at 1 using a recursive generator.\"\"\"\n    def collatz_gen(k):\n        yield k\n        if k != 1:\n            next_k = k // 2 if k % 2 == 0 else 3 * k + 1\n            yield from collatz_gen(next_k)\n    return list(collatz_gen(n))"
  },
  {
    "task": "Remove Until Sum",
    "input": "List of positive integers, integer threshold",
    "output": "List of elements removed from the start until their cumulative sum is at least the threshold",
    "function_name": "remove_until_sum",
    "code_1": "def remove_until_sum(lst, threshold):\n    \"\"\"\n    Remove elements from the start of lst until their cumulative sum is at least threshold.\n    Return the list of removed elements.\n    \"\"\"\n    removed = []\n    total = 0\n    for num in lst:\n        if total >= threshold:\n            break\n        removed.append(num)\n        total += num\n    return removed",
    "code_2": "def remove_until_sum(lst, threshold):\n    from itertools import accumulate\n    # If threshold is non-positive, nothing to remove\n    if threshold <= 0:\n        return []\n    # Compute running totals\n    running = accumulate(lst)\n    # Find the first index where the sum meets or exceeds the threshold\n    idx = next((i for i, total in enumerate(running) if total >= threshold), None)\n    # Slice the original list accordingly\n    return lst[:idx+1] if idx is not None else lst[:]\n"
  },
  {
    "task": "Divisible by Digit Sum",
    "input": "List of positive integers",
    "output": "List of booleans indicating if each integer is divisible by the sum of its digits",
    "function_name": "divisible_by_digit_sum",
    "code_1": "def divisible_by_digit_sum(numbers):\n    result = []\n    for n in numbers:\n        digit_sum = sum(int(d) for d in str(n))\n        result.append(n % digit_sum == 0)\n    return result",
    "code_2": "def divisible_by_digit_sum(numbers):\n    def digit_sum(n):\n        s = 0\n        while n:\n            n, d = divmod(n, 10)\n            s += d\n        return s\n    return [n % digit_sum(n) == 0 for n in numbers]"
  },
  {
    "task": "Count Pairs Divisible by K",
    "input": "List of integers, integer K",
    "output": "Integer count of unique unordered pairs whose sum is divisible by K",
    "function_name": "count_pairs_divisible_by_k",
    "code_1": "def count_pairs_divisible_by_k(nums, k):\n    from collections import Counter\n    counter = Counter()\n    count = 0\n    for num in nums:\n        mod = num % k\n        complement = (-mod) % k\n        count += counter[complement]\n        counter[mod] += 1\n    return count",
    "code_2": "def count_pairs_divisible_by_k(nums, k):\n    # count occurrences of each remainder\n    freq = [0] * k\n    for n in nums:\n        freq[n % k] += 1\n    # pairs where both remainders are 0\n    count = freq[0] * (freq[0] - 1) // 2\n    # handle general cases\n    half = k // 2\n    for r in range(1, half + 1):\n        # skip the midpoint when k is even\n        if r != k - r:\n            count += freq[r] * freq[k - r]\n    # if k even, add pairs where remainder == k/2\n    if k % 2 == 0:\n        count += freq[half] * (freq[half] - 1) // 2\n    return count"
  },
  {
    "task": "Wave Sort",
    "input": "List of integers",
    "output": "List rearranged into wave form by sorting then swapping each adjacent pair",
    "function_name": "wave_sort",
    "code_1": "def wave_sort(nums):\n    nums.sort()\n    for i in range(0, len(nums) - 1, 2):\n        nums[i], nums[i+1] = nums[i+1], nums[i]\n    return nums",
    "code_2": "def wave_sort(nums):\n    # sort into a new list and build the wave pattern\n    sorted_nums = sorted(nums)\n    wave = []\n    for i in range(0, len(sorted_nums), 2):\n        if i + 1 < len(sorted_nums):\n            # swap each pair\n            wave.extend([sorted_nums[i+1], sorted_nums[i]])\n        else:\n            # handle the last element if odd length\n            wave.append(sorted_nums[i])\n    # modify the original list in place\n    nums[:] = wave\n    return nums"
  },
  {
    "task": "Union and Intersection of Sets",
    "input": "List of sets of integers",
    "output": "Tuple of two sets: (union of all sets, intersection of all sets)",
    "function_name": "compute_union_intersection",
    "code_1": "def compute_union_intersection(sets_list):\n    \"\"\"\n    Compute the union and intersection of a list of integer sets.\n    Args:\n        sets_list (list of set of int): The input sets.\n    Returns:\n        tuple: A tuple containing the union set and the intersection set.\n    \"\"\"\n    if not sets_list:\n        # No sets provided: return two empty sets\n        return set(), set()\n    # Initialize union as empty set and intersection as a copy of the first set\n    union_set = set()\n    intersection_set = sets_list[0].copy()\n    for s in sets_list:\n        union_set |= s\n        intersection_set &= s\n    return union_set, intersection_set",
    "code_2": "def compute_union_intersection(sets_list):\n    '''Compute the union and intersection of a list of integer sets.'''\n    if not sets_list:\n        return set(), set()\n    # Use built-in class methods with argument unpacking\n    return set.union(*sets_list), set.intersection(*sets_list)\n"
  },
  {
    "task": "Center Align Text",
    "input": "List of strings",
    "output": "List of strings padded with spaces to center each string based on the longest string length",
    "function_name": "center_align_text",
    "code_1": "def center_align_text(strings):\n    # Determine the maximum length among all strings\n    max_len = max((len(s) for s in strings), default=0)\n    # Center each string with spaces\n    aligned = []\n    for s in strings:\n        total_pad = max_len - len(s)\n        left_pad = total_pad // 2\n        right_pad = total_pad - left_pad\n        aligned.append(' ' * left_pad + s + ' ' * right_pad)\n    return aligned",
    "code_2": "def center_align_text(strings):\n    from functools import reduce\n    # find the maximum string length using reduce\n    max_len = reduce(lambda m, s: m if m > len(s) else len(s), strings, 0)\n    # use str.center to pad each string\n    return [s.center(max_len) for s in strings]"
  },
  {
    "task": "Validate MAC Address",
    "input": "String",
    "output": "Boolean indicating whether it is a valid MAC address (six pairs of hexadecimal digits separated by colons)",
    "function_name": "is_valid_mac_address",
    "code_1": "def is_valid_mac_address(mac):\n    import re\n    pattern = r'^[0-9A-Fa-f]{2}(:[0-9A-Fa-f]{2}){5}$'\n    return bool(re.match(pattern, mac))",
    "code_2": "def is_valid_mac_address(mac):\n    \"\"\"Validate a MAC address by splitting and parsing each hex pair without regex.\"\"\"\n    try:\n        parts = mac.split(':')\n        if len(parts) != 6:\n            return False\n        for part in parts:\n            if len(part) != 2:\n                return False\n            # Attempt to parse each part as a hexadecimal number\n            int(part, 16)\n        return True\n    except (ValueError, TypeError):\n        return False"
  },
  {
    "task": "Alternating Digit Sum",
    "input": "Integer",
    "output": "Integer equal to the sum of its digits with alternating signs starting with positive for the most significant digit",
    "function_name": "alternating_digit_sum",
    "code_1": "def alternating_digit_sum(n):\n    s = str(abs(n))\n    total = 0\n    for i, ch in enumerate(s):\n        d = int(ch)\n        if i % 2 == 0:\n            total += d\n        else:\n            total -= d\n    return total",
    "code_2": "def alternating_digit_sum(n):\n    s = str(abs(n))\n    return sum(map(int, s[::2])) - sum(map(int, s[1::2]))\n"
  },
  {
    "task": "Main Diagonal Product",
    "input": "Square matrix as a list of lists of numbers",
    "output": "Product of the main diagonal elements",
    "function_name": "main_diagonal_product",
    "code_1": "def main_diagonal_product(matrix):\n    \"\"\"Return the product of the main diagonal elements of a square matrix.\"\"\"\n    product = 1\n    for i in range(len(matrix)):\n        product *= matrix[i][i]\n    return product",
    "code_2": "def main_diagonal_product(matrix):\n    from functools import reduce\n    from operator import mul\n    return reduce(mul, (row[i] for i, row in enumerate(matrix)), 1)"
  },
  {
    "task": "Quadrant Point Count",
    "input": "List of tuples (x, y) coordinates",
    "output": "Dictionary with keys 'Q1','Q2','Q3','Q4' and counts of points in each quadrant (exclude points on axes)",
    "function_name": "quadrant_point_count",
    "code_1": "def quadrant_point_count(points):\n    counts = {'Q1': 0, 'Q2': 0, 'Q3': 0, 'Q4': 0}\n    for x, y in points:\n        # Exclude points on axes\n        if x == 0 or y == 0:\n            continue\n        if x > 0 and y > 0:\n            counts['Q1'] += 1\n        elif x < 0 and y > 0:\n            counts['Q2'] += 1\n        elif x < 0 and y < 0:\n            counts['Q3'] += 1\n        elif x > 0 and y < 0:\n            counts['Q4'] += 1\n    return counts",
    "code_2": "def quadrant_point_count(points):\n    from collections import Counter\n    # Map sign tuples to quadrant labels\n    sign_to_quad = {(1, 1): 'Q1', (-1, 1): 'Q2', (-1, -1): 'Q3', (1, -1): 'Q4'}\n    # Build counts using a generator comprehension, skipping axes\n    quad_counts = Counter(\n        sign_to_quad[(1 if x > 0 else -1, 1 if y > 0 else -1)]\n        for x, y in points\n        if x != 0 and y != 0\n    )\n    # Ensure all quadrants are present\n    return {q: quad_counts.get(q, 0) for q in ['Q1', 'Q2', 'Q3', 'Q4']}"
  },
  {
    "task": "Sum of Primes in Matrix",
    "input": "Two-dimensional list of integers",
    "output": "Sum of all prime numbers in the matrix",
    "function_name": "sum_primes_in_matrix",
    "code_1": "def sum_primes_in_matrix(matrix):\n    \"\"\"\n    Returns the sum of all prime numbers in a 2D matrix.\n    matrix: list of lists of integers\n    \"\"\"\n    def is_prime(n):\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    total = 0\n    for row in matrix:\n        for num in row:\n            if is_prime(num):\n                total += num\n    return total",
    "code_2": "def sum_primes_in_matrix(matrix):\n    # Gather all numbers greater than 1\n    nums = [n for row in matrix for n in row if n > 1]\n    if not nums:\n        return 0\n    # Build a sieve up to the maximum number\n    max_n = max(nums)\n    sieve = [True] * (max_n + 1)\n    sieve[0] = sieve[1] = False\n    for i in range(2, int(max_n**0.5) + 1):\n        if sieve[i]:\n            for j in range(i*i, max_n + 1, i):\n                sieve[j] = False\n    # Sum only those in the sieve marked as prime\n    return sum(n for n in nums if sieve[n])"
  },
  {
    "task": "Insertion Sort",
    "input": "List of numbers",
    "output": "List of numbers sorted in ascending order",
    "function_name": "insertion_sort",
    "code_1": "def insertion_sort(arr):\n    \"\"\"Sorts a list of numbers in ascending order using insertion sort.\"\"\"\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        # Move elements of arr[0..i-1], that are greater than key, one position ahead\n        while j >= 0 and arr[j] > key:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n    return arr",
    "code_2": "import bisect\n\ndef insertion_sort(arr):\n    \"\"\"Sorts a list of numbers in ascending order using bisect for insertion.\"\"\"\n    sorted_list = []\n    for value in arr:\n        bisect.insort(sorted_list, value)\n    return sorted_list"
  },
  {
    "task": "Smallest Missing Even Number",
    "input": "List of integers",
    "output": "Smallest missing positive even integer",
    "function_name": "smallest_missing_even",
    "code_1": "def smallest_missing_even(nums):\n    \"\"\"Return the smallest missing positive even integer from the list.\"\"\"\n    evens = set(n for n in nums if n > 0 and n % 2 == 0)\n    x = 2\n    while True:\n        if x not in evens:\n            return x\n        x += 2",
    "code_2": "def smallest_missing_even(nums):\n    # Convert positive evens to their half-values\n    halves = [n // 2 for n in nums if n > 0 and n % 2 == 0]\n    size = len(halves)\n    # Boolean marker for each half-value position\n    seen = [False] * (size + 2)\n    for h in halves:\n        if 1 <= h <= size + 1:\n            seen[h] = True\n    # Find the smallest missing half-value and convert back to even\n    for i in range(1, size + 2):\n        if not seen[i]:\n            return i * 2\n"
  },
  {
    "task": "List Permutation Check",
    "input": "Two lists",
    "output": "Boolean indicating whether one list is a permutation of the other",
    "function_name": "is_permutation",
    "code_1": "def is_permutation(list1, list2):\n    \"\"\"Return True if list1 is a permutation of list2.\"\"\"\n    if len(list1) != len(list2):\n        return False\n    from collections import Counter\n    return Counter(list1) == Counter(list2)",
    "code_2": "def is_permutation(list1, list2):\n    \"\"\"Return True if list1 is a permutation of list2.\"\"\"\n    if len(list1) != len(list2):\n        return False\n    # Compare sorted versions for permutation check\n    return sorted(list1) == sorted(list2)"
  },
  {
    "task": "Levenshtein Distance",
    "input": "Two strings",
    "output": "Integer representing the minimum edit distance between them",
    "function_name": "levenshtein_distance",
    "code_1": "def levenshtein_distance(s1, s2):\n    if len(s1) < len(s2):\n        return levenshtein_distance(s2, s1)\n    previous_row = list(range(len(s2) + 1))\n    for i, c1 in enumerate(s1, start=1):\n        current_row = [i]\n        for j, c2 in enumerate(s2, start=1):\n            insertions = previous_row[j] + 1\n            deletions = current_row[j - 1] + 1\n            substitutions = previous_row[j - 1] + (c1 != c2)\n            current_row.append(min(insertions, deletions, substitutions))\n        previous_row = current_row\n    return previous_row[-1]",
    "code_2": "def levenshtein_distance(s1, s2):\n    from functools import lru_cache\n\n    @lru_cache(maxsize=None)\n    def dp(i, j):\n        if i == 0:\n            return j\n        if j == 0:\n            return i\n        if s1[i-1] == s2[j-1]:\n            return dp(i-1, j-1)\n        return 1 + min(dp(i-1, j),    # deletion\n                       dp(i, j-1),    # insertion\n                       dp(i-1, j-1))  # substitution\n\n    return dp(len(s1), len(s2))"
  },
  {
    "task": "String Overlap Length",
    "input": "Two strings",
    "output": "Length of the longest suffix of the first string matching a prefix of the second",
    "function_name": "longest_overlap_length",
    "code_1": "def longest_overlap_length(s1, s2):\n    \"\"\"\n    Return the length of the longest suffix of s1 that matches a prefix of s2.\n    \"\"\"\n    max_len = min(len(s1), len(s2))\n    for l in range(max_len, 0, -1):\n        if s1.endswith(s2[:l]):\n            return l\n    return 0",
    "code_2": "def longest_overlap_length(s1, s2):\n    \"\"\"\n    Return the length of the longest suffix of s1 that matches a prefix of s2 using a prefix-function approach.\n    \"\"\"\n    # Only need to consider up to the shorter length\n    n = min(len(s1), len(s2))\n    # Use a delimiter unlikely in inputs\n    delim = '\\x00'\n    # Build a combined string: pattern + delim + text suffix\n    combined = s2 + delim + s1[-n:]\n    # Compute prefix function (KMP table)\n    pi = [0] * len(combined)\n    for i in range(1, len(combined)):\n        j = pi[i-1]\n        while j > 0 and combined[i] != combined[j]:\n            j = pi[j-1]\n        if combined[i] == combined[j]:\n            j += 1\n        pi[i] = j\n    # The last value gives the longest prefix of s2 matching a suffix of s1[-n:]\n    return pi[-1]"
  },
  {
    "task": "Time to Minutes",
    "input": "three integers representing days, hours, and minutes",
    "output": "integer total minutes",
    "function_name": "time_to_minutes",
    "code_1": "def time_to_minutes(days, hours, minutes):\n    return days * 24 * 60 + hours * 60 + minutes",
    "code_2": "from datetime import timedelta\n\ndef time_to_minutes(days, hours, minutes):\n    td = timedelta(days=days, hours=hours, minutes=minutes)\n    return td.days * 1440 + td.seconds // 60"
  },
  {
    "task": "Extract Even-Position Characters",
    "input": "A string",
    "output": "String formed by characters at even indices (0-based)",
    "function_name": "extract_even_chars",
    "code_1": "def extract_even_chars(s):\n    \"\"\"Return a string consisting of characters at even indices (0-based).\"\"\"\n    return s[::2]",
    "code_2": "def extract_even_chars(s):\n    \"\"\"Return a string of characters at even indices (0-based).\"\"\"\n    result_chars = []\n    for idx, char in enumerate(s):\n        if idx % 2 == 0:\n            result_chars.append(char)\n    return ''.join(result_chars)"
  },
  {
    "task": "Longest Decreasing Run",
    "input": "List of numbers",
    "output": "Length of the longest contiguous strictly decreasing subsequence",
    "function_name": "longest_decreasing_run",
    "code_1": "def longest_decreasing_run(nums):\n    if not nums:\n        return 0\n    max_len = 1\n    curr_len = 1\n    for i in range(1, len(nums)):\n        if nums[i] < nums[i-1]:\n            curr_len += 1\n            if curr_len > max_len:\n                max_len = curr_len\n        else:\n            curr_len = 1\n    return max_len",
    "code_2": "import itertools\n\ndef longest_decreasing_run(nums):\n    if not nums:\n        return 0\n    # mark each adjacent pair as decreasing or not\n    dec = [curr < prev for prev, curr in zip(nums, nums[1:])]\n    # find the longest streak of True in dec\n    max_pairs = 0\n    for key, group in itertools.groupby(dec):\n        if key:\n            length = sum(1 for _ in group)\n            if length > max_pairs:\n                max_pairs = length\n    return max_pairs + 1"
  },
  {
    "task": "Z-Score Normalization",
    "input": "List of numbers",
    "output": "List of numbers normalized by z-score (x\u2212mean)/standard_deviation",
    "function_name": "z_score_normalization",
    "code_1": "def z_score_normalization(data):\n    if not data:\n        return []\n    mean = sum(data) / len(data)\n    variance = sum((x - mean)**2 for x in data) / len(data)\n    std = variance**0.5\n    if std == 0:\n        return [0 for _ in data]\n    return [(x - mean) / std for x in data]",
    "code_2": "import statistics\n\ndef z_score_normalization(data):\n    if not data:\n        return []\n    mu = statistics.mean(data)\n    sigma = statistics.pstdev(data, mu)\n    if sigma == 0:\n        return [0] * len(data)\n    return [(x - mu) / sigma for x in data]\n"
  },
  {
    "task": "Divisible by Three Check",
    "input": "integer",
    "output": "boolean indicating if the integer is divisible by 3",
    "function_name": "is_divisible_by_three",
    "code_1": "def is_divisible_by_three(n):\n    \"\"\"Return True if n is divisible by 3, else False.\"\"\"\n    return n % 3 == 0",
    "code_2": "def is_divisible_by_three(n):\n    \"\"\"Return True if n is divisible by 3, else False using digit-sum reduction.\"\"\"\n    n = abs(n)\n    while n > 9:\n        n = sum(int(d) for d in str(n))\n    return n in (0, 3, 6, 9)\n"
  },
  {
    "task": "Count Binary Palindromes",
    "input": "list of integers",
    "output": "integer count of numbers whose binary representation is a palindrome",
    "function_name": "count_binary_palindromes",
    "code_1": "def count_binary_palindromes(nums):\n    \"\"\"Return the count of numbers whose binary representation is a palindrome.\"\"\"\n    count = 0\n    for n in nums:\n        # Get binary representation without '0b' prefix\n        b = bin(n)[2:]\n        # Check if palindrome\n        if b == b[::-1]:\n            count += 1\n    return count",
    "code_2": "def count_binary_palindromes(nums):\n    \"\"\"Return the count of numbers whose binary representation is a palindrome.\"\"\"\n    def is_pal(n):\n        # Check bits from both ends without converting to string\n        length = n.bit_length()\n        for i in range(length // 2):\n            if ((n >> i) & 1) != ((n >> (length - 1 - i)) & 1):\n                return False\n        # Handle 0 as a palindrome ('0')\n        return True\n    # Sum up all numbers that satisfy the bitwise palindrome test\n    return sum(1 for n in nums if is_pal(n))"
  },
  {
    "task": "Longest Increasing Digit Run",
    "input": "integer",
    "output": "integer length of the longest run of strictly increasing consecutive digits",
    "function_name": "longest_increasing_digit_run",
    "code_1": "def longest_increasing_digit_run(n):\n    s = str(abs(n))\n    # Initialize both current and maximum run lengths to 1\n    max_run = current_run = 1\n    # Iterate over consecutive digit pairs\n    for prev, curr in zip(s, s[1:]):\n        if curr > prev:\n            # Continue the run\n            current_run += 1\n        else:\n            # Reset the run\n            current_run = 1\n        # Update maximum run length\n        max_run = max(max_run, current_run)\n    return max_run",
    "code_2": "import itertools\n\ndef longest_increasing_digit_run(n):\n    s = str(abs(n))\n    # mark each adjacent pair as increasing or not\n    diffs = [a < b for a, b in zip(s, s[1:])]\n    # group consecutive True values and find the longest group\n    longest_true = max((sum(1 for _ in group) for key, group in itertools.groupby(diffs) if key), default=0)\n    # the run length is number of True gaps + 1\n    return longest_true + 1"
  },
  {
    "task": "List Proper Divisors",
    "input": "integer",
    "output": "list of integers representing all proper divisors of the integer (excluding itself)",
    "function_name": "list_proper_divisors",
    "code_1": "def list_proper_divisors(n):\n    # Return all proper divisors of n (excluding n itself)\n    divisors = []\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            divisors.append(i)\n    return divisors",
    "code_2": "import math\n\ndef list_proper_divisors(n):\n    \"\"\"Return all proper divisors of n (excluding n itself).\"\"\"\n    if n <= 1:\n        return []\n    divisors = {1}\n    root = math.isqrt(n)\n    for i in range(2, root + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sorted(divisors)"
  },
  {
    "task": "ASCII Difference Sum",
    "input": "string",
    "output": "integer sum of absolute differences between ASCII values of adjacent characters",
    "function_name": "ascii_diff_sum",
    "code_1": "def ascii_diff_sum(s):\n    total = 0\n    for i in range(1, len(s)):\n        total += abs(ord(s[i]) - ord(s[i-1]))\n    return total",
    "code_2": "def ascii_diff_sum(s):\n    return sum(map(lambda a, b: abs(ord(b) - ord(a)), s, s[1:]))"
  },
  {
    "task": "Reverse Vowels",
    "input": "string",
    "output": "string with the vowels\u2019 positions reversed",
    "function_name": "reverse_vowels",
    "code_1": "def reverse_vowels(s):\n    vowels = set('aeiouAEIOU')\n    s_list = list(s)\n    i, j = 0, len(s) - 1\n    while i < j:\n        if s_list[i] not in vowels:\n            i += 1\n        elif s_list[j] not in vowels:\n            j -= 1\n        else:\n            s_list[i], s_list[j] = s_list[j], s_list[i]\n            i += 1\n            j -= 1\n    return ''.join(s_list)",
    "code_2": "import re\n\ndef reverse_vowels(s):\n    # find all vowels in the string\n    vowels = re.findall(r\"[aeiouAEIOU]\", s)\n    # replace each vowel with the last one from the list\n    return re.sub(r\"[aeiouAEIOU]\", lambda match: vowels.pop(), s)"
  },
  {
    "task": "Kth Bit Value",
    "input": "two integers: number and k (0-based index)",
    "output": "integer (0 or 1) representing the k-th bit of the number",
    "function_name": "get_kth_bit",
    "code_1": "def get_kth_bit(number, k):\n    return (number >> k) & 1",
    "code_2": "def get_kth_bit(number, k):\n    b = bin(number)[2:]\n    idx = len(b) - 1 - k\n    return int(b[idx]) if idx >= 0 else 0"
  },
  {
    "task": "Alternate Word Capitalization",
    "input": "string of words separated by spaces",
    "output": "string where every second word is capitalized",
    "function_name": "alternate_word_capitalization",
    "code_1": "def alternate_word_capitalization(s):\n    words = s.split(' ')\n    for i in range(len(words)):\n        if i % 2 == 1:\n            words[i] = words[i].upper()\n    return ' '.join(words)",
    "code_2": "def alternate_word_capitalization(s):\n    parts = s.split(' ')\n    # Use list comprehension with enumerate to transform every second word\n    transformed = [word.upper() if idx % 2 else word for idx, word in enumerate(parts)]\n    return ' '.join(transformed)"
  },
  {
    "task": "Unit Vector",
    "input": "a list of three numbers",
    "output": "a list of three floats representing the normalized (unit) vector",
    "function_name": "unit_vector",
    "code_1": "def unit_vector(vec):\n    import math\n    if len(vec) != 3:\n        raise ValueError(\"Input must be a list of three numbers\")\n    x, y, z = vec\n    norm = math.sqrt(x*x + y*y + z*z)\n    if norm == 0:\n        raise ValueError(\"Zero vector cannot be normalized\")\n    return [x/norm, y/norm, z/norm]",
    "code_2": "from functools import reduce\nimport math\n\ndef unit_vector(vec):\n    # Ensure we have exactly three components\n    if len(vec) != 3:\n        raise ValueError(\"Input must be a list of three numbers\")\n    # Compute squared norm via reduction\n    norm_sq = reduce(lambda total, v: total + v*v, vec, 0)\n    if norm_sq == 0:\n        raise ValueError(\"Zero vector cannot be normalized\")\n    # Normalize each component\n    norm = math.sqrt(norm_sq)\n    return list(map(lambda v: v / norm, vec))"
  },
  {
    "task": "3D Vector Cross Product",
    "input": "two lists of three numbers",
    "output": "a list of three numbers representing the cross product",
    "function_name": "cross_product",
    "code_1": "def cross_product(a, b):\n    \"\"\"Return the cross product of two 3D vectors a and b.\"\"\"\n    return [\n        a[1] * b[2] - a[2] * b[1],\n        a[2] * b[0] - a[0] * b[2],\n        a[0] * b[1] - a[1] * b[0]\n    ]",
    "code_2": "def cross_product(a, b):\n    \"\"\"Compute the cross product of two 3D vectors using modular indexing.\"\"\"\n    # For each component i, take determinant of the 2x2 submatrix skipping index i\n    return [\n        a[(i+1) % 3] * b[(i+2) % 3] - a[(i+2) % 3] * b[(i+1) % 3]\n        for i in range(3)\n    ]\n"
  },
  {
    "task": "Remove Duplicate Words",
    "input": "a string",
    "output": "a string with duplicate words removed, preserving their original order",
    "function_name": "remove_duplicate_words",
    "code_1": "def remove_duplicate_words(s):\n    seen = set()\n    result = []\n    for word in s.split():\n        if word not in seen:\n            seen.add(word)\n            result.append(word)\n    return ' '.join(result)",
    "code_2": "def remove_duplicate_words(s):\n    # Use dict.fromkeys to preserve order and remove duplicates\n    unique_words = dict.fromkeys(s.split())\n    return ' '.join(unique_words)"
  },
  {
    "task": "Chessboard Pattern",
    "input": "an integer n",
    "output": "a two\u2010dimensional n\u00d7n list with entries 'B' and 'W' in alternating pattern",
    "function_name": "chessboard_pattern",
    "code_1": "def chessboard_pattern(n):\n    board = []\n    for i in range(n):\n        row = []\n        for j in range(n):\n            if (i + j) % 2 == 0:\n                row.append('B')\n            else:\n                row.append('W')\n        board.append(row)\n    return board",
    "code_2": "def chessboard_pattern(n):\n    pattern1 = ['B' if j % 2 == 0 else 'W' for j in range(n)]\n    pattern2 = ['W' if j % 2 == 0 else 'B' for j in range(n)]\n    return [pattern1 if i % 2 == 0 else pattern2 for i in range(n)]"
  },
  {
    "task": "Missing Rectangle Corner",
    "input": "three tuples of two integers (x, y) representing axis\u2010aligned rectangle vertices",
    "output": "a tuple of two integers for the fourth corner",
    "function_name": "find_missing_corner",
    "code_1": "def find_missing_corner(p1, p2, p3):\n    \"\"\"\n    Given three vertices of an axis-aligned rectangle, return the fourth missing vertex.\n    Each p is a tuple (x, y).\n    \"\"\"\n    xs = [p1[0], p2[0], p3[0]]\n    ys = [p1[1], p2[1], p3[1]]\n    # For axis-aligned rectangle, duplicate x's and y's cancel via XOR\n    x4 = xs[0] ^ xs[1] ^ xs[2]\n    y4 = ys[0] ^ ys[1] ^ ys[2]\n    return (x4, y4)",
    "code_2": "def find_missing_corner(p1, p2, p3):\n    xs = [p1[0], p2[0], p3[0]]\n    ys = [p1[1], p2[1], p3[1]]\n    # each coordinate in an axis-aligned rectangle appears twice\n    x4 = 2 * sum(set(xs)) - sum(xs)\n    y4 = 2 * sum(set(ys)) - sum(ys)\n    return (x4, y4)"
  },
  {
    "task": "Linear Interpolation",
    "input": "two numbers (start, end) and an integer n > 1",
    "output": "a list of n evenly spaced numbers from start to end inclusive",
    "function_name": "linear_interpolation",
    "code_1": "def linear_interpolation(start, end, n):\n    \"\"\"\n    Returns a list of n evenly spaced numbers from start to end inclusive.\n    \"\"\"\n    if n < 2:\n        raise ValueError(\"n must be greater than 1\")\n    step = (end - start) / (n - 1)\n    return [start + i * step for i in range(n)]",
    "code_2": "def linear_interpolation(start, end, n):\n    \"\"\"\n    Returns a list of n evenly spaced numbers from start to end inclusive.\n    \"\"\"\n    if n < 2:\n        raise ValueError(\"n must be greater than 1\")\n    # Compute each point as a weighted average to avoid explicit step calculation\n    return [(start * (n - 1 - i) + end * i) / (n - 1) for i in range(n)]"
  },
  {
    "task": "All Elements Unique",
    "input": "a list of elements",
    "output": "a boolean indicating whether all elements are unique",
    "function_name": "all_elements_unique",
    "code_1": "def all_elements_unique(lst):\n    \"\"\"Return True if all elements in lst are unique, otherwise False.\"\"\"\n    return len(lst) == len(set(lst))",
    "code_2": "def all_elements_unique(lst):\n    \"\"\"Return True if all elements in lst are unique, otherwise False.\"\"\"\n    seen = set()\n    for item in lst:\n        if item in seen:\n            return False\n        seen.add(item)\n    return True"
  },
  {
    "task": "Consecutive Differences",
    "input": "a list of numbers",
    "output": "a list of numbers representing the differences between successive elements",
    "function_name": "consecutive_differences",
    "code_1": "def consecutive_differences(numbers):\n    \"\"\"\n    Return a list of differences between successive elements in the input list.\n    \"\"\"\n    return [numbers[i+1] - numbers[i] for i in range(len(numbers) - 1)]",
    "code_2": "def consecutive_differences(numbers):\n    from operator import sub\n    # Use map with operator.sub to compute successive differences\n    return list(map(sub, numbers[1:], numbers[:-1]))"
  },
  {
    "task": "Common Unique Characters Count",
    "input": "two strings",
    "output": "an integer count of unique characters present in both strings",
    "function_name": "common_unique_chars_count",
    "code_1": "def common_unique_chars_count(s1, s2):\n    \"\"\"Return the count of unique characters present in both s1 and s2.\"\"\"\n    return len(set(s1) & set(s2))",
    "code_2": "def common_unique_chars_count(s1, s2):\n    # Build a list of unique characters from s1\n    unique_s1 = []\n    for ch in s1:\n        if ch not in unique_s1:\n            unique_s1.append(ch)\n    # Count how many of those appear in s2\n    count = 0\n    for ch in unique_s1:\n        if ch in s2:\n            count += 1\n    return count"
  },
  {
    "task": "Remove Every Nth Character",
    "input": "a string and an integer n",
    "output": "a string with every n\u1d57\u02b0 character removed",
    "function_name": "remove_every_nth_char",
    "code_1": "def remove_every_nth_char(s, n):\n    if n <= 0:\n        return s\n    return ''.join(ch for idx, ch in enumerate(s, start=1) if idx % n != 0)",
    "code_2": "def remove_every_nth_char(s, n):\n    if n <= 0:\n        return s\n    # Split the string into chunks of size n\n    chunks = [s[i:i+n] for i in range(0, len(s), n)]\n    # Drop the last character of each full-sized chunk\n    return ''.join(chunk[:-1] if len(chunk) == n else chunk for chunk in chunks)"
  }
]